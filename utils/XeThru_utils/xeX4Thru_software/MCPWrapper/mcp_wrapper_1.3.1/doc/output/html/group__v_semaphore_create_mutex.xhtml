<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Module Communication Protocol Wrapper - MCPW: vSemaphoreCreateMutex</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- Platform title -->
    <div class="page-title-bar container-fluid">
      <div id="projectalign" class="row">
        <div id="projectname" class="col-sm-12">Module Communication Protocol Wrapper - MCPW
        </div>
        <div id="projectbrief" class="col-sm-12">Host side implementation of MCP</div>
      </div>
    </div>
    <div class="topbar">
      <div class="container">
        <div id="titlearea">
          <div class="xethru-logo">
            <img src="xethru-logo_220x55HD.png" alt="Novelda XeThru web site" id="logo-image" />
          </div>
        </div>
        <!-- end header part -->
        <!-- Generated by Doxygen 1.8.12 -->
        <!--BEGIN MAIN-NAV AND SEARCHENGINE-->
        <div id="main-nav"></div>
        <!--END MAIN-NAV AND SEARCHENGINE-->
      </div>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">vSemaphoreCreateMutex</div>  </div>
</div><!--header-->
<div class="contents">

<p>semphr.  
<a href="#details">More...</a></p>
<p>semphr. </p>
<p>h </p><pre>xSemaphoreHandle <a class="el" href="semphr_8h.xhtml#aa6a00aa9b91a9e5b3ebe4ae1c3f115c6">xSemaphoreCreateMutex( void )</a></pre><p><em>Macro</em> that implements a mutex semaphore by using the existing queue mechanism.</p>
<p>Mutexes created using this macro can be accessed using the <a class="el" href="semphr_8h.xhtml#af116e436d2a5ae5bd72dbade2b5ea930">xSemaphoreTake()</a> and <a class="el" href="semphr_8h.xhtml#aae55761cabfa9bf85c8f4430f78c0953">xSemaphoreGive()</a> macros. The <a class="el" href="semphr_8h.xhtml#ad395f4bba51eea6af3397d72bc079e4d">xSemaphoreTakeRecursive()</a> and <a class="el" href="semphr_8h.xhtml#a398d66b17856c22dd49d39aaac42f105">xSemaphoreGiveRecursive()</a> macros should not be used.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See <a class="el" href="semphr_8h.xhtml#ae10bffadd26fbd5bcce76bf33a83ef30">vSemaphoreCreateBinary()</a> for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p>
<dl class="section return"><dt>Returns</dt><dd>xSemaphore Handle to the created mutex semaphore. Should be of type xSemaphoreHandle.</dd></dl>
<p>Example usage: </p><pre>
xSemaphoreHandle xSemaphore;</pre><pre>void vATask( void * pvParameters )
{
   // Semaphore cannot be used before a call to <a class="el" href="semphr_8h.xhtml#aa6a00aa9b91a9e5b3ebe4ae1c3f115c6">xSemaphoreCreateMutex()</a>.
   // This is a macro so pass the variable in directly.
   xSemaphore = <a class="el" href="semphr_8h.xhtml#aa6a00aa9b91a9e5b3ebe4ae1c3f115c6">xSemaphoreCreateMutex()</a>;</pre><pre>   if( xSemaphore != NULL )
   {
       // The semaphore was created successfully.
       // The semaphore can now be used.
   }
}
</pre><p>h </p><pre>xSemaphoreHandle <a class="el" href="semphr_8h.xhtml#a1bbc843be5a41ea83d2693b2189fc0f8">xSemaphoreCreateRecursiveMutex( void )</a></pre><p><em>Macro</em> that implements a recursive mutex by using the existing queue mechanism.</p>
<p>Mutexes created using this macro can be accessed using the <a class="el" href="semphr_8h.xhtml#ad395f4bba51eea6af3397d72bc079e4d">xSemaphoreTakeRecursive()</a> and <a class="el" href="semphr_8h.xhtml#a398d66b17856c22dd49d39aaac42f105">xSemaphoreGiveRecursive()</a> macros. The <a class="el" href="semphr_8h.xhtml#af116e436d2a5ae5bd72dbade2b5ea930">xSemaphoreTake()</a> and <a class="el" href="semphr_8h.xhtml#aae55761cabfa9bf85c8f4430f78c0953">xSemaphoreGive()</a> macros should not be used.</p>
<p>A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called <a class="el" href="semphr_8h.xhtml#a398d66b17856c22dd49d39aaac42f105">xSemaphoreGiveRecursive()</a> for each successful 'take' request. For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also 'given' the mutex back exactly five times.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See <a class="el" href="semphr_8h.xhtml#ae10bffadd26fbd5bcce76bf33a83ef30">vSemaphoreCreateBinary()</a> for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p>
<dl class="section return"><dt>Returns</dt><dd>xSemaphore Handle to the created mutex semaphore. Should be of type xSemaphoreHandle.</dd></dl>
<p>Example usage: </p><pre>
xSemaphoreHandle xSemaphore;</pre><pre>void vATask( void * pvParameters )
{
   // Semaphore cannot be used before a call to <a class="el" href="semphr_8h.xhtml#aa6a00aa9b91a9e5b3ebe4ae1c3f115c6">xSemaphoreCreateMutex()</a>.
   // This is a macro so pass the variable in directly.
   xSemaphore = <a class="el" href="semphr_8h.xhtml#a1bbc843be5a41ea83d2693b2189fc0f8">xSemaphoreCreateRecursiveMutex()</a>;</pre><pre>   if( xSemaphore != NULL )
   {
       // The semaphore was created successfully.
       // The semaphore can now be used.
   }
}
</pre> </div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/>
 <address class="footer">
 Copyright &copy; 2016 Novelda AS - <a href="http://www.xethru.com">www.xehtru.com</a><br />
 <small>
  Generated by &#160;<a href="http://www.doxygen.org/index.html">
  <img class="footer" src="doxygen.png" alt="doxygen"/>
  </a> 1.8.12
 </small>
 </address>
</body>
</html>
