# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_moduleconnectorwrapper', [dirname(__file__)])
        except ImportError:
            import _moduleconnectorwrapper
            return _moduleconnectorwrapper
        if fp is not None:
            try:
                _mod = imp.load_module('_moduleconnectorwrapper', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _moduleconnectorwrapper = swig_import_helper()
    del swig_import_helper
else:
    import _moduleconnectorwrapper
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _moduleconnectorwrapper.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        """value(SwigPyIterator self) -> PyObject *"""
        return _moduleconnectorwrapper.SwigPyIterator_value(self)


    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _moduleconnectorwrapper.SwigPyIterator_incr(self, n)


    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _moduleconnectorwrapper.SwigPyIterator_decr(self, n)


    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _moduleconnectorwrapper.SwigPyIterator_distance(self, x)


    def equal(self, x: 'SwigPyIterator') -> "bool":
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _moduleconnectorwrapper.SwigPyIterator_equal(self, x)


    def copy(self) -> "swig::SwigPyIterator *":
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.SwigPyIterator_copy(self)


    def next(self) -> "PyObject *":
        """next(SwigPyIterator self) -> PyObject *"""
        return _moduleconnectorwrapper.SwigPyIterator_next(self)


    def __next__(self) -> "PyObject *":
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _moduleconnectorwrapper.SwigPyIterator___next__(self)


    def previous(self) -> "PyObject *":
        """previous(SwigPyIterator self) -> PyObject *"""
        return _moduleconnectorwrapper.SwigPyIterator_previous(self)


    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _moduleconnectorwrapper.SwigPyIterator_advance(self, n)


    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _moduleconnectorwrapper.SwigPyIterator___eq__(self, x)


    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _moduleconnectorwrapper.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _moduleconnectorwrapper.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _moduleconnectorwrapper.SwigPyIterator___isub__(self, n)


    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _moduleconnectorwrapper.SwigPyIterator___add__(self, n)


    def __sub__(self, *args) -> "ptrdiff_t":
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _moduleconnectorwrapper.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _moduleconnectorwrapper.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def new_uint32_t_ptr() -> "uint32_t *":
    """new_uint32_t_ptr() -> uint32_t *"""
    return _moduleconnectorwrapper.new_uint32_t_ptr()

def copy_uint32_t_ptr(value: 'uint32_t') -> "uint32_t *":
    """copy_uint32_t_ptr(uint32_t value) -> uint32_t *"""
    return _moduleconnectorwrapper.copy_uint32_t_ptr(value)

def delete_uint32_t_ptr(obj: 'uint32_t *') -> "void":
    """delete_uint32_t_ptr(uint32_t * obj)"""
    return _moduleconnectorwrapper.delete_uint32_t_ptr(obj)

def uint32_t_ptr_assign(obj: 'uint32_t *', value: 'uint32_t') -> "void":
    """uint32_t_ptr_assign(uint32_t * obj, uint32_t value)"""
    return _moduleconnectorwrapper.uint32_t_ptr_assign(obj, value)

def uint32_t_ptr_value(obj: 'uint32_t *') -> "uint32_t":
    """uint32_t_ptr_value(uint32_t * obj) -> uint32_t"""
    return _moduleconnectorwrapper.uint32_t_ptr_value(obj)

def new_uint8_t_ptr() -> "uint8_t *":
    """new_uint8_t_ptr() -> uint8_t *"""
    return _moduleconnectorwrapper.new_uint8_t_ptr()

def copy_uint8_t_ptr(value: 'uint8_t') -> "uint8_t *":
    """copy_uint8_t_ptr(uint8_t value) -> uint8_t *"""
    return _moduleconnectorwrapper.copy_uint8_t_ptr(value)

def delete_uint8_t_ptr(obj: 'uint8_t *') -> "void":
    """delete_uint8_t_ptr(uint8_t * obj)"""
    return _moduleconnectorwrapper.delete_uint8_t_ptr(obj)

def uint8_t_ptr_assign(obj: 'uint8_t *', value: 'uint8_t') -> "void":
    """uint8_t_ptr_assign(uint8_t * obj, uint8_t value)"""
    return _moduleconnectorwrapper.uint8_t_ptr_assign(obj, value)

def uint8_t_ptr_value(obj: 'uint8_t *') -> "uint8_t":
    """uint8_t_ptr_value(uint8_t * obj) -> uint8_t"""
    return _moduleconnectorwrapper.uint8_t_ptr_value(obj)

def new_float_ptr() -> "float *":
    """new_float_ptr() -> float *"""
    return _moduleconnectorwrapper.new_float_ptr()

def copy_float_ptr(value: 'float') -> "float *":
    """copy_float_ptr(float value) -> float *"""
    return _moduleconnectorwrapper.copy_float_ptr(value)

def delete_float_ptr(obj: 'float *') -> "void":
    """delete_float_ptr(float * obj)"""
    return _moduleconnectorwrapper.delete_float_ptr(obj)

def float_ptr_assign(obj: 'float *', value: 'float') -> "void":
    """float_ptr_assign(float * obj, float value)"""
    return _moduleconnectorwrapper.float_ptr_assign(obj, value)

def float_ptr_value(obj: 'float *') -> "float":
    """float_ptr_value(float * obj) -> float"""
    return _moduleconnectorwrapper.float_ptr_value(obj)

def new_string_ptr() -> "std::string *":
    """new_string_ptr() -> std::string *"""
    return _moduleconnectorwrapper.new_string_ptr()

def copy_string_ptr(value: 'std::string') -> "std::string *":
    """copy_string_ptr(std::string value) -> std::string *"""
    return _moduleconnectorwrapper.copy_string_ptr(value)

def delete_string_ptr(obj: 'std::string *') -> "void":
    """delete_string_ptr(std::string * obj)"""
    return _moduleconnectorwrapper.delete_string_ptr(obj)

def string_ptr_assign(obj: 'std::string *', value: 'std::string') -> "void":
    """string_ptr_assign(std::string * obj, std::string value)"""
    return _moduleconnectorwrapper.string_ptr_assign(obj, value)

def string_ptr_value(obj: 'std::string *') -> "std::string":
    """string_ptr_value(std::string * obj) -> std::string"""
    return _moduleconnectorwrapper.string_ptr_value(obj)
class uiVector(_object):
    """Proxy of C++ std::vector<(unsigned int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uiVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uiVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(uiVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.uiVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(uiVector self) -> bool"""
        return _moduleconnectorwrapper.uiVector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(uiVector self) -> bool"""
        return _moduleconnectorwrapper.uiVector___bool__(self)


    def __len__(self) -> "std::vector< unsigned int >::size_type":
        """__len__(uiVector self) -> std::vector< unsigned int >::size_type"""
        return _moduleconnectorwrapper.uiVector___len__(self)


    def __getslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        """__getslice__(uiVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> uiVector"""
        return _moduleconnectorwrapper.uiVector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(uiVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        __setslice__(uiVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, uiVector v)
        """
        return _moduleconnectorwrapper.uiVector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "void":
        """__delslice__(uiVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _moduleconnectorwrapper.uiVector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(uiVector self, std::vector< unsigned int >::difference_type i)
        __delitem__(uiVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.uiVector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        """
        __getitem__(uiVector self, PySliceObject * slice) -> uiVector
        __getitem__(uiVector self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _moduleconnectorwrapper.uiVector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(uiVector self, PySliceObject * slice, uiVector v)
        __setitem__(uiVector self, PySliceObject * slice)
        __setitem__(uiVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _moduleconnectorwrapper.uiVector___setitem__(self, *args)


    def pop(self) -> "std::vector< unsigned int >::value_type":
        """pop(uiVector self) -> std::vector< unsigned int >::value_type"""
        return _moduleconnectorwrapper.uiVector_pop(self)


    def append(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """append(uiVector self, std::vector< unsigned int >::value_type const & x)"""
        return _moduleconnectorwrapper.uiVector_append(self, x)


    def empty(self) -> "bool":
        """empty(uiVector self) -> bool"""
        return _moduleconnectorwrapper.uiVector_empty(self)


    def size(self) -> "std::vector< unsigned int >::size_type":
        """size(uiVector self) -> std::vector< unsigned int >::size_type"""
        return _moduleconnectorwrapper.uiVector_size(self)


    def swap(self, v: 'uiVector') -> "void":
        """swap(uiVector self, uiVector v)"""
        return _moduleconnectorwrapper.uiVector_swap(self, v)


    def begin(self) -> "std::vector< unsigned int >::iterator":
        """begin(uiVector self) -> std::vector< unsigned int >::iterator"""
        return _moduleconnectorwrapper.uiVector_begin(self)


    def end(self) -> "std::vector< unsigned int >::iterator":
        """end(uiVector self) -> std::vector< unsigned int >::iterator"""
        return _moduleconnectorwrapper.uiVector_end(self)


    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        """rbegin(uiVector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _moduleconnectorwrapper.uiVector_rbegin(self)


    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        """rend(uiVector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _moduleconnectorwrapper.uiVector_rend(self)


    def clear(self) -> "void":
        """clear(uiVector self)"""
        return _moduleconnectorwrapper.uiVector_clear(self)


    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        """get_allocator(uiVector self) -> std::vector< unsigned int >::allocator_type"""
        return _moduleconnectorwrapper.uiVector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(uiVector self)"""
        return _moduleconnectorwrapper.uiVector_pop_back(self)


    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        """
        erase(uiVector self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(uiVector self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _moduleconnectorwrapper.uiVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned int)> self) -> uiVector
        __init__(std::vector<(unsigned int)> self, uiVector arg2) -> uiVector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size) -> uiVector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> uiVector
        """
        this = _moduleconnectorwrapper.new_uiVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """push_back(uiVector self, std::vector< unsigned int >::value_type const & x)"""
        return _moduleconnectorwrapper.uiVector_push_back(self, x)


    def front(self) -> "std::vector< unsigned int >::value_type const &":
        """front(uiVector self) -> std::vector< unsigned int >::value_type const &"""
        return _moduleconnectorwrapper.uiVector_front(self)


    def back(self) -> "std::vector< unsigned int >::value_type const &":
        """back(uiVector self) -> std::vector< unsigned int >::value_type const &"""
        return _moduleconnectorwrapper.uiVector_back(self)


    def assign(self, n: 'std::vector< unsigned int >::size_type', x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """assign(uiVector self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _moduleconnectorwrapper.uiVector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(uiVector self, std::vector< unsigned int >::size_type new_size)
        resize(uiVector self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _moduleconnectorwrapper.uiVector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(uiVector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(uiVector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)
        """
        return _moduleconnectorwrapper.uiVector_insert(self, *args)


    def reserve(self, n: 'std::vector< unsigned int >::size_type') -> "void":
        """reserve(uiVector self, std::vector< unsigned int >::size_type n)"""
        return _moduleconnectorwrapper.uiVector_reserve(self, n)


    def capacity(self) -> "std::vector< unsigned int >::size_type":
        """capacity(uiVector self) -> std::vector< unsigned int >::size_type"""
        return _moduleconnectorwrapper.uiVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_uiVector
    __del__ = lambda self: None
uiVector_swigregister = _moduleconnectorwrapper.uiVector_swigregister
uiVector_swigregister(uiVector)

class iVector(_object):
    """Proxy of C++ std::vector<(int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, iVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, iVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(iVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.iVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(iVector self) -> bool"""
        return _moduleconnectorwrapper.iVector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(iVector self) -> bool"""
        return _moduleconnectorwrapper.iVector___bool__(self)


    def __len__(self) -> "std::vector< int >::size_type":
        """__len__(iVector self) -> std::vector< int >::size_type"""
        return _moduleconnectorwrapper.iVector___len__(self)


    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        """__getslice__(iVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> iVector"""
        return _moduleconnectorwrapper.iVector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(iVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(iVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, iVector v)
        """
        return _moduleconnectorwrapper.iVector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        """__delslice__(iVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _moduleconnectorwrapper.iVector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(iVector self, std::vector< int >::difference_type i)
        __delitem__(iVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.iVector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        """
        __getitem__(iVector self, PySliceObject * slice) -> iVector
        __getitem__(iVector self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _moduleconnectorwrapper.iVector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(iVector self, PySliceObject * slice, iVector v)
        __setitem__(iVector self, PySliceObject * slice)
        __setitem__(iVector self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _moduleconnectorwrapper.iVector___setitem__(self, *args)


    def pop(self) -> "std::vector< int >::value_type":
        """pop(iVector self) -> std::vector< int >::value_type"""
        return _moduleconnectorwrapper.iVector_pop(self)


    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        """append(iVector self, std::vector< int >::value_type const & x)"""
        return _moduleconnectorwrapper.iVector_append(self, x)


    def empty(self) -> "bool":
        """empty(iVector self) -> bool"""
        return _moduleconnectorwrapper.iVector_empty(self)


    def size(self) -> "std::vector< int >::size_type":
        """size(iVector self) -> std::vector< int >::size_type"""
        return _moduleconnectorwrapper.iVector_size(self)


    def swap(self, v: 'iVector') -> "void":
        """swap(iVector self, iVector v)"""
        return _moduleconnectorwrapper.iVector_swap(self, v)


    def begin(self) -> "std::vector< int >::iterator":
        """begin(iVector self) -> std::vector< int >::iterator"""
        return _moduleconnectorwrapper.iVector_begin(self)


    def end(self) -> "std::vector< int >::iterator":
        """end(iVector self) -> std::vector< int >::iterator"""
        return _moduleconnectorwrapper.iVector_end(self)


    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        """rbegin(iVector self) -> std::vector< int >::reverse_iterator"""
        return _moduleconnectorwrapper.iVector_rbegin(self)


    def rend(self) -> "std::vector< int >::reverse_iterator":
        """rend(iVector self) -> std::vector< int >::reverse_iterator"""
        return _moduleconnectorwrapper.iVector_rend(self)


    def clear(self) -> "void":
        """clear(iVector self)"""
        return _moduleconnectorwrapper.iVector_clear(self)


    def get_allocator(self) -> "std::vector< int >::allocator_type":
        """get_allocator(iVector self) -> std::vector< int >::allocator_type"""
        return _moduleconnectorwrapper.iVector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(iVector self)"""
        return _moduleconnectorwrapper.iVector_pop_back(self)


    def erase(self, *args) -> "std::vector< int >::iterator":
        """
        erase(iVector self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(iVector self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _moduleconnectorwrapper.iVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int)> self) -> iVector
        __init__(std::vector<(int)> self, iVector arg2) -> iVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> iVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> iVector
        """
        this = _moduleconnectorwrapper.new_iVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        """push_back(iVector self, std::vector< int >::value_type const & x)"""
        return _moduleconnectorwrapper.iVector_push_back(self, x)


    def front(self) -> "std::vector< int >::value_type const &":
        """front(iVector self) -> std::vector< int >::value_type const &"""
        return _moduleconnectorwrapper.iVector_front(self)


    def back(self) -> "std::vector< int >::value_type const &":
        """back(iVector self) -> std::vector< int >::value_type const &"""
        return _moduleconnectorwrapper.iVector_back(self)


    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        """assign(iVector self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _moduleconnectorwrapper.iVector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(iVector self, std::vector< int >::size_type new_size)
        resize(iVector self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _moduleconnectorwrapper.iVector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(iVector self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(iVector self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _moduleconnectorwrapper.iVector_insert(self, *args)


    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        """reserve(iVector self, std::vector< int >::size_type n)"""
        return _moduleconnectorwrapper.iVector_reserve(self, n)


    def capacity(self) -> "std::vector< int >::size_type":
        """capacity(iVector self) -> std::vector< int >::size_type"""
        return _moduleconnectorwrapper.iVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_iVector
    __del__ = lambda self: None
iVector_swigregister = _moduleconnectorwrapper.iVector_swigregister
iVector_swigregister(iVector)

class DoubleVector(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(DoubleVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.DoubleVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(DoubleVector self) -> bool"""
        return _moduleconnectorwrapper.DoubleVector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(DoubleVector self) -> bool"""
        return _moduleconnectorwrapper.DoubleVector___bool__(self)


    def __len__(self) -> "std::vector< double >::size_type":
        """__len__(DoubleVector self) -> std::vector< double >::size_type"""
        return _moduleconnectorwrapper.DoubleVector___len__(self)


    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        """__getslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> DoubleVector"""
        return _moduleconnectorwrapper.DoubleVector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, DoubleVector v)
        """
        return _moduleconnectorwrapper.DoubleVector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        """__delslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _moduleconnectorwrapper.DoubleVector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(DoubleVector self, std::vector< double >::difference_type i)
        __delitem__(DoubleVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.DoubleVector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        """
        __getitem__(DoubleVector self, PySliceObject * slice) -> DoubleVector
        __getitem__(DoubleVector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _moduleconnectorwrapper.DoubleVector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(DoubleVector self, PySliceObject * slice, DoubleVector v)
        __setitem__(DoubleVector self, PySliceObject * slice)
        __setitem__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _moduleconnectorwrapper.DoubleVector___setitem__(self, *args)


    def pop(self) -> "std::vector< double >::value_type":
        """pop(DoubleVector self) -> std::vector< double >::value_type"""
        return _moduleconnectorwrapper.DoubleVector_pop(self)


    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        """append(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _moduleconnectorwrapper.DoubleVector_append(self, x)


    def empty(self) -> "bool":
        """empty(DoubleVector self) -> bool"""
        return _moduleconnectorwrapper.DoubleVector_empty(self)


    def size(self) -> "std::vector< double >::size_type":
        """size(DoubleVector self) -> std::vector< double >::size_type"""
        return _moduleconnectorwrapper.DoubleVector_size(self)


    def swap(self, v: 'DoubleVector') -> "void":
        """swap(DoubleVector self, DoubleVector v)"""
        return _moduleconnectorwrapper.DoubleVector_swap(self, v)


    def begin(self) -> "std::vector< double >::iterator":
        """begin(DoubleVector self) -> std::vector< double >::iterator"""
        return _moduleconnectorwrapper.DoubleVector_begin(self)


    def end(self) -> "std::vector< double >::iterator":
        """end(DoubleVector self) -> std::vector< double >::iterator"""
        return _moduleconnectorwrapper.DoubleVector_end(self)


    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        """rbegin(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _moduleconnectorwrapper.DoubleVector_rbegin(self)


    def rend(self) -> "std::vector< double >::reverse_iterator":
        """rend(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _moduleconnectorwrapper.DoubleVector_rend(self)


    def clear(self) -> "void":
        """clear(DoubleVector self)"""
        return _moduleconnectorwrapper.DoubleVector_clear(self)


    def get_allocator(self) -> "std::vector< double >::allocator_type":
        """get_allocator(DoubleVector self) -> std::vector< double >::allocator_type"""
        return _moduleconnectorwrapper.DoubleVector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(DoubleVector self)"""
        return _moduleconnectorwrapper.DoubleVector_pop_back(self)


    def erase(self, *args) -> "std::vector< double >::iterator":
        """
        erase(DoubleVector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(DoubleVector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _moduleconnectorwrapper.DoubleVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> DoubleVector
        __init__(std::vector<(double)> self, DoubleVector arg2) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> DoubleVector
        """
        this = _moduleconnectorwrapper.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        """push_back(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _moduleconnectorwrapper.DoubleVector_push_back(self, x)


    def front(self) -> "std::vector< double >::value_type const &":
        """front(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _moduleconnectorwrapper.DoubleVector_front(self)


    def back(self) -> "std::vector< double >::value_type const &":
        """back(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _moduleconnectorwrapper.DoubleVector_back(self)


    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        """assign(DoubleVector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _moduleconnectorwrapper.DoubleVector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(DoubleVector self, std::vector< double >::size_type new_size)
        resize(DoubleVector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _moduleconnectorwrapper.DoubleVector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _moduleconnectorwrapper.DoubleVector_insert(self, *args)


    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        """reserve(DoubleVector self, std::vector< double >::size_type n)"""
        return _moduleconnectorwrapper.DoubleVector_reserve(self, n)


    def capacity(self) -> "std::vector< double >::size_type":
        """capacity(DoubleVector self) -> std::vector< double >::size_type"""
        return _moduleconnectorwrapper.DoubleVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _moduleconnectorwrapper.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class FloatVector(_object):
    """Proxy of C++ std::vector<(float)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(FloatVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.FloatVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(FloatVector self) -> bool"""
        return _moduleconnectorwrapper.FloatVector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(FloatVector self) -> bool"""
        return _moduleconnectorwrapper.FloatVector___bool__(self)


    def __len__(self) -> "std::vector< float >::size_type":
        """__len__(FloatVector self) -> std::vector< float >::size_type"""
        return _moduleconnectorwrapper.FloatVector___len__(self)


    def __getslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "std::vector< float,std::allocator< float > > *":
        """__getslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> FloatVector"""
        return _moduleconnectorwrapper.FloatVector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        __setslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, FloatVector v)
        """
        return _moduleconnectorwrapper.FloatVector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "void":
        """__delslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _moduleconnectorwrapper.FloatVector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(FloatVector self, std::vector< float >::difference_type i)
        __delitem__(FloatVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.FloatVector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        """
        __getitem__(FloatVector self, PySliceObject * slice) -> FloatVector
        __getitem__(FloatVector self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _moduleconnectorwrapper.FloatVector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(FloatVector self, PySliceObject * slice, FloatVector v)
        __setitem__(FloatVector self, PySliceObject * slice)
        __setitem__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _moduleconnectorwrapper.FloatVector___setitem__(self, *args)


    def pop(self) -> "std::vector< float >::value_type":
        """pop(FloatVector self) -> std::vector< float >::value_type"""
        return _moduleconnectorwrapper.FloatVector_pop(self)


    def append(self, x: 'std::vector< float >::value_type const &') -> "void":
        """append(FloatVector self, std::vector< float >::value_type const & x)"""
        return _moduleconnectorwrapper.FloatVector_append(self, x)


    def empty(self) -> "bool":
        """empty(FloatVector self) -> bool"""
        return _moduleconnectorwrapper.FloatVector_empty(self)


    def size(self) -> "std::vector< float >::size_type":
        """size(FloatVector self) -> std::vector< float >::size_type"""
        return _moduleconnectorwrapper.FloatVector_size(self)


    def swap(self, v: 'FloatVector') -> "void":
        """swap(FloatVector self, FloatVector v)"""
        return _moduleconnectorwrapper.FloatVector_swap(self, v)


    def begin(self) -> "std::vector< float >::iterator":
        """begin(FloatVector self) -> std::vector< float >::iterator"""
        return _moduleconnectorwrapper.FloatVector_begin(self)


    def end(self) -> "std::vector< float >::iterator":
        """end(FloatVector self) -> std::vector< float >::iterator"""
        return _moduleconnectorwrapper.FloatVector_end(self)


    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        """rbegin(FloatVector self) -> std::vector< float >::reverse_iterator"""
        return _moduleconnectorwrapper.FloatVector_rbegin(self)


    def rend(self) -> "std::vector< float >::reverse_iterator":
        """rend(FloatVector self) -> std::vector< float >::reverse_iterator"""
        return _moduleconnectorwrapper.FloatVector_rend(self)


    def clear(self) -> "void":
        """clear(FloatVector self)"""
        return _moduleconnectorwrapper.FloatVector_clear(self)


    def get_allocator(self) -> "std::vector< float >::allocator_type":
        """get_allocator(FloatVector self) -> std::vector< float >::allocator_type"""
        return _moduleconnectorwrapper.FloatVector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(FloatVector self)"""
        return _moduleconnectorwrapper.FloatVector_pop_back(self)


    def erase(self, *args) -> "std::vector< float >::iterator":
        """
        erase(FloatVector self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(FloatVector self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _moduleconnectorwrapper.FloatVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(float)> self) -> FloatVector
        __init__(std::vector<(float)> self, FloatVector arg2) -> FloatVector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size) -> FloatVector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> FloatVector
        """
        this = _moduleconnectorwrapper.new_FloatVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< float >::value_type const &') -> "void":
        """push_back(FloatVector self, std::vector< float >::value_type const & x)"""
        return _moduleconnectorwrapper.FloatVector_push_back(self, x)


    def front(self) -> "std::vector< float >::value_type const &":
        """front(FloatVector self) -> std::vector< float >::value_type const &"""
        return _moduleconnectorwrapper.FloatVector_front(self)


    def back(self) -> "std::vector< float >::value_type const &":
        """back(FloatVector self) -> std::vector< float >::value_type const &"""
        return _moduleconnectorwrapper.FloatVector_back(self)


    def assign(self, n: 'std::vector< float >::size_type', x: 'std::vector< float >::value_type const &') -> "void":
        """assign(FloatVector self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _moduleconnectorwrapper.FloatVector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(FloatVector self, std::vector< float >::size_type new_size)
        resize(FloatVector self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _moduleconnectorwrapper.FloatVector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(FloatVector self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(FloatVector self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _moduleconnectorwrapper.FloatVector_insert(self, *args)


    def reserve(self, n: 'std::vector< float >::size_type') -> "void":
        """reserve(FloatVector self, std::vector< float >::size_type n)"""
        return _moduleconnectorwrapper.FloatVector_reserve(self, n)


    def capacity(self) -> "std::vector< float >::size_type":
        """capacity(FloatVector self) -> std::vector< float >::size_type"""
        return _moduleconnectorwrapper.FloatVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_FloatVector
    __del__ = lambda self: None
FloatVector_swigregister = _moduleconnectorwrapper.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

class sVector(_object):
    """Proxy of C++ std::vector<(int16_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(sVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.sVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(sVector self) -> bool"""
        return _moduleconnectorwrapper.sVector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(sVector self) -> bool"""
        return _moduleconnectorwrapper.sVector___bool__(self)


    def __len__(self) -> "std::vector< short >::size_type":
        """__len__(sVector self) -> std::vector< short >::size_type"""
        return _moduleconnectorwrapper.sVector___len__(self)


    def __getslice__(self, i: 'std::vector< short >::difference_type', j: 'std::vector< short >::difference_type') -> "std::vector< short,std::allocator< short > > *":
        """__getslice__(sVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j) -> sVector"""
        return _moduleconnectorwrapper.sVector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(sVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j)
        __setslice__(sVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j, sVector v)
        """
        return _moduleconnectorwrapper.sVector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< short >::difference_type', j: 'std::vector< short >::difference_type') -> "void":
        """__delslice__(sVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j)"""
        return _moduleconnectorwrapper.sVector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(sVector self, std::vector< short >::difference_type i)
        __delitem__(sVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.sVector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< short >::value_type const &":
        """
        __getitem__(sVector self, PySliceObject * slice) -> sVector
        __getitem__(sVector self, std::vector< short >::difference_type i) -> std::vector< short >::value_type const &
        """
        return _moduleconnectorwrapper.sVector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(sVector self, PySliceObject * slice, sVector v)
        __setitem__(sVector self, PySliceObject * slice)
        __setitem__(sVector self, std::vector< short >::difference_type i, std::vector< short >::value_type const & x)
        """
        return _moduleconnectorwrapper.sVector___setitem__(self, *args)


    def pop(self) -> "std::vector< short >::value_type":
        """pop(sVector self) -> std::vector< short >::value_type"""
        return _moduleconnectorwrapper.sVector_pop(self)


    def append(self, x: 'std::vector< short >::value_type const &') -> "void":
        """append(sVector self, std::vector< short >::value_type const & x)"""
        return _moduleconnectorwrapper.sVector_append(self, x)


    def empty(self) -> "bool":
        """empty(sVector self) -> bool"""
        return _moduleconnectorwrapper.sVector_empty(self)


    def size(self) -> "std::vector< short >::size_type":
        """size(sVector self) -> std::vector< short >::size_type"""
        return _moduleconnectorwrapper.sVector_size(self)


    def swap(self, v: 'sVector') -> "void":
        """swap(sVector self, sVector v)"""
        return _moduleconnectorwrapper.sVector_swap(self, v)


    def begin(self) -> "std::vector< short >::iterator":
        """begin(sVector self) -> std::vector< short >::iterator"""
        return _moduleconnectorwrapper.sVector_begin(self)


    def end(self) -> "std::vector< short >::iterator":
        """end(sVector self) -> std::vector< short >::iterator"""
        return _moduleconnectorwrapper.sVector_end(self)


    def rbegin(self) -> "std::vector< short >::reverse_iterator":
        """rbegin(sVector self) -> std::vector< short >::reverse_iterator"""
        return _moduleconnectorwrapper.sVector_rbegin(self)


    def rend(self) -> "std::vector< short >::reverse_iterator":
        """rend(sVector self) -> std::vector< short >::reverse_iterator"""
        return _moduleconnectorwrapper.sVector_rend(self)


    def clear(self) -> "void":
        """clear(sVector self)"""
        return _moduleconnectorwrapper.sVector_clear(self)


    def get_allocator(self) -> "std::vector< short >::allocator_type":
        """get_allocator(sVector self) -> std::vector< short >::allocator_type"""
        return _moduleconnectorwrapper.sVector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(sVector self)"""
        return _moduleconnectorwrapper.sVector_pop_back(self)


    def erase(self, *args) -> "std::vector< short >::iterator":
        """
        erase(sVector self, std::vector< short >::iterator pos) -> std::vector< short >::iterator
        erase(sVector self, std::vector< short >::iterator first, std::vector< short >::iterator last) -> std::vector< short >::iterator
        """
        return _moduleconnectorwrapper.sVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int16_t)> self) -> sVector
        __init__(std::vector<(int16_t)> self, sVector arg2) -> sVector
        __init__(std::vector<(int16_t)> self, std::vector< short >::size_type size) -> sVector
        __init__(std::vector<(int16_t)> self, std::vector< short >::size_type size, std::vector< short >::value_type const & value) -> sVector
        """
        this = _moduleconnectorwrapper.new_sVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< short >::value_type const &') -> "void":
        """push_back(sVector self, std::vector< short >::value_type const & x)"""
        return _moduleconnectorwrapper.sVector_push_back(self, x)


    def front(self) -> "std::vector< short >::value_type const &":
        """front(sVector self) -> std::vector< short >::value_type const &"""
        return _moduleconnectorwrapper.sVector_front(self)


    def back(self) -> "std::vector< short >::value_type const &":
        """back(sVector self) -> std::vector< short >::value_type const &"""
        return _moduleconnectorwrapper.sVector_back(self)


    def assign(self, n: 'std::vector< short >::size_type', x: 'std::vector< short >::value_type const &') -> "void":
        """assign(sVector self, std::vector< short >::size_type n, std::vector< short >::value_type const & x)"""
        return _moduleconnectorwrapper.sVector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(sVector self, std::vector< short >::size_type new_size)
        resize(sVector self, std::vector< short >::size_type new_size, std::vector< short >::value_type const & x)
        """
        return _moduleconnectorwrapper.sVector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(sVector self, std::vector< short >::iterator pos, std::vector< short >::value_type const & x) -> std::vector< short >::iterator
        insert(sVector self, std::vector< short >::iterator pos, std::vector< short >::size_type n, std::vector< short >::value_type const & x)
        """
        return _moduleconnectorwrapper.sVector_insert(self, *args)


    def reserve(self, n: 'std::vector< short >::size_type') -> "void":
        """reserve(sVector self, std::vector< short >::size_type n)"""
        return _moduleconnectorwrapper.sVector_reserve(self, n)


    def capacity(self) -> "std::vector< short >::size_type":
        """capacity(sVector self) -> std::vector< short >::size_type"""
        return _moduleconnectorwrapper.sVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_sVector
    __del__ = lambda self: None
sVector_swigregister = _moduleconnectorwrapper.sVector_swigregister
sVector_swigregister(sVector)

class ucVector(_object):
    """Proxy of C++ std::vector<(unsigned char)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ucVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ucVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(ucVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.ucVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(ucVector self) -> bool"""
        return _moduleconnectorwrapper.ucVector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(ucVector self) -> bool"""
        return _moduleconnectorwrapper.ucVector___bool__(self)


    def __len__(self) -> "std::vector< unsigned char >::size_type":
        """__len__(ucVector self) -> std::vector< unsigned char >::size_type"""
        return _moduleconnectorwrapper.ucVector___len__(self)


    def __getslice__(self, i: 'std::vector< unsigned char >::difference_type', j: 'std::vector< unsigned char >::difference_type') -> "std::vector< unsigned char,std::allocator< unsigned char > > *":
        """__getslice__(ucVector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j) -> ucVector"""
        return _moduleconnectorwrapper.ucVector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(ucVector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)
        __setslice__(ucVector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j, ucVector v)
        """
        return _moduleconnectorwrapper.ucVector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< unsigned char >::difference_type', j: 'std::vector< unsigned char >::difference_type') -> "void":
        """__delslice__(ucVector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)"""
        return _moduleconnectorwrapper.ucVector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(ucVector self, std::vector< unsigned char >::difference_type i)
        __delitem__(ucVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.ucVector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< unsigned char >::value_type const &":
        """
        __getitem__(ucVector self, PySliceObject * slice) -> ucVector
        __getitem__(ucVector self, std::vector< unsigned char >::difference_type i) -> std::vector< unsigned char >::value_type const &
        """
        return _moduleconnectorwrapper.ucVector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(ucVector self, PySliceObject * slice, ucVector v)
        __setitem__(ucVector self, PySliceObject * slice)
        __setitem__(ucVector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::value_type const & x)
        """
        return _moduleconnectorwrapper.ucVector___setitem__(self, *args)


    def pop(self) -> "std::vector< unsigned char >::value_type":
        """pop(ucVector self) -> std::vector< unsigned char >::value_type"""
        return _moduleconnectorwrapper.ucVector_pop(self)


    def append(self, x: 'std::vector< unsigned char >::value_type const &') -> "void":
        """append(ucVector self, std::vector< unsigned char >::value_type const & x)"""
        return _moduleconnectorwrapper.ucVector_append(self, x)


    def empty(self) -> "bool":
        """empty(ucVector self) -> bool"""
        return _moduleconnectorwrapper.ucVector_empty(self)


    def size(self) -> "std::vector< unsigned char >::size_type":
        """size(ucVector self) -> std::vector< unsigned char >::size_type"""
        return _moduleconnectorwrapper.ucVector_size(self)


    def swap(self, v: 'ucVector') -> "void":
        """swap(ucVector self, ucVector v)"""
        return _moduleconnectorwrapper.ucVector_swap(self, v)


    def begin(self) -> "std::vector< unsigned char >::iterator":
        """begin(ucVector self) -> std::vector< unsigned char >::iterator"""
        return _moduleconnectorwrapper.ucVector_begin(self)


    def end(self) -> "std::vector< unsigned char >::iterator":
        """end(ucVector self) -> std::vector< unsigned char >::iterator"""
        return _moduleconnectorwrapper.ucVector_end(self)


    def rbegin(self) -> "std::vector< unsigned char >::reverse_iterator":
        """rbegin(ucVector self) -> std::vector< unsigned char >::reverse_iterator"""
        return _moduleconnectorwrapper.ucVector_rbegin(self)


    def rend(self) -> "std::vector< unsigned char >::reverse_iterator":
        """rend(ucVector self) -> std::vector< unsigned char >::reverse_iterator"""
        return _moduleconnectorwrapper.ucVector_rend(self)


    def clear(self) -> "void":
        """clear(ucVector self)"""
        return _moduleconnectorwrapper.ucVector_clear(self)


    def get_allocator(self) -> "std::vector< unsigned char >::allocator_type":
        """get_allocator(ucVector self) -> std::vector< unsigned char >::allocator_type"""
        return _moduleconnectorwrapper.ucVector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(ucVector self)"""
        return _moduleconnectorwrapper.ucVector_pop_back(self)


    def erase(self, *args) -> "std::vector< unsigned char >::iterator":
        """
        erase(ucVector self, std::vector< unsigned char >::iterator pos) -> std::vector< unsigned char >::iterator
        erase(ucVector self, std::vector< unsigned char >::iterator first, std::vector< unsigned char >::iterator last) -> std::vector< unsigned char >::iterator
        """
        return _moduleconnectorwrapper.ucVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned char)> self) -> ucVector
        __init__(std::vector<(unsigned char)> self, ucVector arg2) -> ucVector
        __init__(std::vector<(unsigned char)> self, std::vector< unsigned char >::size_type size) -> ucVector
        __init__(std::vector<(unsigned char)> self, std::vector< unsigned char >::size_type size, std::vector< unsigned char >::value_type const & value) -> ucVector
        """
        this = _moduleconnectorwrapper.new_ucVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned char >::value_type const &') -> "void":
        """push_back(ucVector self, std::vector< unsigned char >::value_type const & x)"""
        return _moduleconnectorwrapper.ucVector_push_back(self, x)


    def front(self) -> "std::vector< unsigned char >::value_type const &":
        """front(ucVector self) -> std::vector< unsigned char >::value_type const &"""
        return _moduleconnectorwrapper.ucVector_front(self)


    def back(self) -> "std::vector< unsigned char >::value_type const &":
        """back(ucVector self) -> std::vector< unsigned char >::value_type const &"""
        return _moduleconnectorwrapper.ucVector_back(self)


    def assign(self, n: 'std::vector< unsigned char >::size_type', x: 'std::vector< unsigned char >::value_type const &') -> "void":
        """assign(ucVector self, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)"""
        return _moduleconnectorwrapper.ucVector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(ucVector self, std::vector< unsigned char >::size_type new_size)
        resize(ucVector self, std::vector< unsigned char >::size_type new_size, std::vector< unsigned char >::value_type const & x)
        """
        return _moduleconnectorwrapper.ucVector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(ucVector self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::value_type const & x) -> std::vector< unsigned char >::iterator
        insert(ucVector self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)
        """
        return _moduleconnectorwrapper.ucVector_insert(self, *args)


    def reserve(self, n: 'std::vector< unsigned char >::size_type') -> "void":
        """reserve(ucVector self, std::vector< unsigned char >::size_type n)"""
        return _moduleconnectorwrapper.ucVector_reserve(self, n)


    def capacity(self) -> "std::vector< unsigned char >::size_type":
        """capacity(ucVector self) -> std::vector< unsigned char >::size_type"""
        return _moduleconnectorwrapper.ucVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_ucVector
    __del__ = lambda self: None
ucVector_swigregister = _moduleconnectorwrapper.ucVector_swigregister
ucVector_swigregister(ucVector)

class vVector(_object):
    """Proxy of C++ std::vector<(std::vector<(unsigned char)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(vVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.vVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(vVector self) -> bool"""
        return _moduleconnectorwrapper.vVector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(vVector self) -> bool"""
        return _moduleconnectorwrapper.vVector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< unsigned char > >::size_type":
        """__len__(vVector self) -> std::vector< std::vector< unsigned char > >::size_type"""
        return _moduleconnectorwrapper.vVector___len__(self)


    def __getslice__(self, i: 'std::vector< std::vector< unsigned char > >::difference_type', j: 'std::vector< std::vector< unsigned char > >::difference_type') -> "std::vector< std::vector< unsigned char,std::allocator< unsigned char > >,std::allocator< std::vector< unsigned char,std::allocator< unsigned char > > > > *":
        """__getslice__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i, std::vector< std::vector< unsigned char > >::difference_type j) -> vVector"""
        return _moduleconnectorwrapper.vVector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i, std::vector< std::vector< unsigned char > >::difference_type j)
        __setslice__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i, std::vector< std::vector< unsigned char > >::difference_type j, vVector v)
        """
        return _moduleconnectorwrapper.vVector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< unsigned char > >::difference_type', j: 'std::vector< std::vector< unsigned char > >::difference_type') -> "void":
        """__delslice__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i, std::vector< std::vector< unsigned char > >::difference_type j)"""
        return _moduleconnectorwrapper.vVector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i)
        __delitem__(vVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.vVector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< unsigned char > >::value_type const &":
        """
        __getitem__(vVector self, PySliceObject * slice) -> vVector
        __getitem__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i) -> ucVector
        """
        return _moduleconnectorwrapper.vVector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(vVector self, PySliceObject * slice, vVector v)
        __setitem__(vVector self, PySliceObject * slice)
        __setitem__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i, ucVector x)
        """
        return _moduleconnectorwrapper.vVector___setitem__(self, *args)


    def pop(self) -> "std::vector< std::vector< unsigned char > >::value_type":
        """pop(vVector self) -> ucVector"""
        return _moduleconnectorwrapper.vVector_pop(self)


    def append(self, x: 'ucVector') -> "void":
        """append(vVector self, ucVector x)"""
        return _moduleconnectorwrapper.vVector_append(self, x)


    def empty(self) -> "bool":
        """empty(vVector self) -> bool"""
        return _moduleconnectorwrapper.vVector_empty(self)


    def size(self) -> "std::vector< std::vector< unsigned char > >::size_type":
        """size(vVector self) -> std::vector< std::vector< unsigned char > >::size_type"""
        return _moduleconnectorwrapper.vVector_size(self)


    def swap(self, v: 'vVector') -> "void":
        """swap(vVector self, vVector v)"""
        return _moduleconnectorwrapper.vVector_swap(self, v)


    def begin(self) -> "std::vector< std::vector< unsigned char > >::iterator":
        """begin(vVector self) -> std::vector< std::vector< unsigned char > >::iterator"""
        return _moduleconnectorwrapper.vVector_begin(self)


    def end(self) -> "std::vector< std::vector< unsigned char > >::iterator":
        """end(vVector self) -> std::vector< std::vector< unsigned char > >::iterator"""
        return _moduleconnectorwrapper.vVector_end(self)


    def rbegin(self) -> "std::vector< std::vector< unsigned char > >::reverse_iterator":
        """rbegin(vVector self) -> std::vector< std::vector< unsigned char > >::reverse_iterator"""
        return _moduleconnectorwrapper.vVector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< unsigned char > >::reverse_iterator":
        """rend(vVector self) -> std::vector< std::vector< unsigned char > >::reverse_iterator"""
        return _moduleconnectorwrapper.vVector_rend(self)


    def clear(self) -> "void":
        """clear(vVector self)"""
        return _moduleconnectorwrapper.vVector_clear(self)


    def get_allocator(self) -> "std::vector< std::vector< unsigned char > >::allocator_type":
        """get_allocator(vVector self) -> std::vector< std::vector< unsigned char > >::allocator_type"""
        return _moduleconnectorwrapper.vVector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(vVector self)"""
        return _moduleconnectorwrapper.vVector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< unsigned char > >::iterator":
        """
        erase(vVector self, std::vector< std::vector< unsigned char > >::iterator pos) -> std::vector< std::vector< unsigned char > >::iterator
        erase(vVector self, std::vector< std::vector< unsigned char > >::iterator first, std::vector< std::vector< unsigned char > >::iterator last) -> std::vector< std::vector< unsigned char > >::iterator
        """
        return _moduleconnectorwrapper.vVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(unsigned char)>)> self) -> vVector
        __init__(std::vector<(std::vector<(unsigned char)>)> self, vVector arg2) -> vVector
        __init__(std::vector<(std::vector<(unsigned char)>)> self, std::vector< std::vector< unsigned char > >::size_type size) -> vVector
        __init__(std::vector<(std::vector<(unsigned char)>)> self, std::vector< std::vector< unsigned char > >::size_type size, ucVector value) -> vVector
        """
        this = _moduleconnectorwrapper.new_vVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'ucVector') -> "void":
        """push_back(vVector self, ucVector x)"""
        return _moduleconnectorwrapper.vVector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< unsigned char > >::value_type const &":
        """front(vVector self) -> ucVector"""
        return _moduleconnectorwrapper.vVector_front(self)


    def back(self) -> "std::vector< std::vector< unsigned char > >::value_type const &":
        """back(vVector self) -> ucVector"""
        return _moduleconnectorwrapper.vVector_back(self)


    def assign(self, n: 'std::vector< std::vector< unsigned char > >::size_type', x: 'ucVector') -> "void":
        """assign(vVector self, std::vector< std::vector< unsigned char > >::size_type n, ucVector x)"""
        return _moduleconnectorwrapper.vVector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(vVector self, std::vector< std::vector< unsigned char > >::size_type new_size)
        resize(vVector self, std::vector< std::vector< unsigned char > >::size_type new_size, ucVector x)
        """
        return _moduleconnectorwrapper.vVector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(vVector self, std::vector< std::vector< unsigned char > >::iterator pos, ucVector x) -> std::vector< std::vector< unsigned char > >::iterator
        insert(vVector self, std::vector< std::vector< unsigned char > >::iterator pos, std::vector< std::vector< unsigned char > >::size_type n, ucVector x)
        """
        return _moduleconnectorwrapper.vVector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< unsigned char > >::size_type') -> "void":
        """reserve(vVector self, std::vector< std::vector< unsigned char > >::size_type n)"""
        return _moduleconnectorwrapper.vVector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< unsigned char > >::size_type":
        """capacity(vVector self) -> std::vector< std::vector< unsigned char > >::size_type"""
        return _moduleconnectorwrapper.vVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_vVector
    __del__ = lambda self: None
vVector_swigregister = _moduleconnectorwrapper.vVector_swigregister
vVector_swigregister(vVector)

class DataType(_object):
    """Proxy of C++ XeThru::DataType class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType, name)
    __repr__ = _swig_repr
    BasebandApDataType = _moduleconnectorwrapper.DataType_BasebandApDataType
    BasebandIqDataType = _moduleconnectorwrapper.DataType_BasebandIqDataType
    SleepDataType = _moduleconnectorwrapper.DataType_SleepDataType
    RespirationDataType = _moduleconnectorwrapper.DataType_RespirationDataType
    PerformanceStatusType = _moduleconnectorwrapper.DataType_PerformanceStatusType
    StringDataType = _moduleconnectorwrapper.DataType_StringDataType
    PulseDopplerFloatDataType = _moduleconnectorwrapper.DataType_PulseDopplerFloatDataType
    PulseDopplerByteDataType = _moduleconnectorwrapper.DataType_PulseDopplerByteDataType
    NoiseMapFloatDataType = _moduleconnectorwrapper.DataType_NoiseMapFloatDataType
    NoiseMapByteDataType = _moduleconnectorwrapper.DataType_NoiseMapByteDataType
    FloatDataType = _moduleconnectorwrapper.DataType_FloatDataType
    ByteDataType = _moduleconnectorwrapper.DataType_ByteDataType
    PresenceSingleDataType = _moduleconnectorwrapper.DataType_PresenceSingleDataType
    PresenceMovingListDataType = _moduleconnectorwrapper.DataType_PresenceMovingListDataType
    RespirationDetectionListDataType = _moduleconnectorwrapper.DataType_RespirationDetectionListDataType
    RespirationMovingListDataType = _moduleconnectorwrapper.DataType_RespirationMovingListDataType
    VitalSignsDataType = _moduleconnectorwrapper.DataType_VitalSignsDataType
    SleepStageDataType = _moduleconnectorwrapper.DataType_SleepStageDataType
    RespirationNormalizedMovementListDataType = _moduleconnectorwrapper.DataType_RespirationNormalizedMovementListDataType
    RadarRfDataType = _moduleconnectorwrapper.DataType_RadarRfDataType
    RadarRfNormalizedDataType = _moduleconnectorwrapper.DataType_RadarRfNormalizedDataType
    RadarBasebandFloatDataType = _moduleconnectorwrapper.DataType_RadarBasebandFloatDataType
    RadarBasebandQ15DataType = _moduleconnectorwrapper.DataType_RadarBasebandQ15DataType

    def __init__(self):
        """__init__(XeThru::DataType self) -> DataType"""
        this = _moduleconnectorwrapper.new_DataType()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_DataType
    __del__ = lambda self: None
DataType_swigregister = _moduleconnectorwrapper.DataType_swigregister
DataType_swigregister(DataType)

class RawNormalizedData(_object):
    """Proxy of C++ XeThru::RawNormalizedData class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RawNormalizedData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RawNormalizedData, name)
    __repr__ = _swig_repr

    def get_frame_counter(self) -> "uint32_t":
        """get_frame_counter(RawNormalizedData self) -> uint32_t"""
        return _moduleconnectorwrapper.RawNormalizedData_get_frame_counter(self)


    def get_data(self) -> "std::vector< float,std::allocator< float > > &":
        """get_data(RawNormalizedData self) -> FloatVector"""
        return _moduleconnectorwrapper.RawNormalizedData_get_data(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RawNormalizedData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RawNormalizedData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RawNormalizedData_frame_counter_get, _moduleconnectorwrapper.RawNormalizedData_frame_counter_set)
    __swig_setmethods__["data"] = _moduleconnectorwrapper.RawNormalizedData_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.RawNormalizedData_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.RawNormalizedData_data_get, _moduleconnectorwrapper.RawNormalizedData_data_set)

    def __init__(self):
        """__init__(XeThru::RawNormalizedData self) -> RawNormalizedData"""
        this = _moduleconnectorwrapper.new_RawNormalizedData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RawNormalizedData
    __del__ = lambda self: None
RawNormalizedData_swigregister = _moduleconnectorwrapper.RawNormalizedData_swigregister
RawNormalizedData_swigregister(RawNormalizedData)
cvar = _moduleconnectorwrapper.cvar
InvalidDataType = cvar.InvalidDataType
AllDataTypes = cvar.AllDataTypes

class DetectionZoneLimits(_object):
    """


    Is an aggrgation of parameters used to represent the detection zone limits.  

    Parameters
    ----------
    * `start` :  
        the start of the detection zone.  
    * `end` :  
        the end of the detection zone.  
    * `step` :  
        the steps in the detection zone.  

    Attributes
    ----------
    * `start` : `float`  

    * `end` : `float`  

    * `step` : `float`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DetectionZoneLimits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DetectionZoneLimits, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _moduleconnectorwrapper.DetectionZoneLimits_start_set
    __swig_getmethods__["start"] = _moduleconnectorwrapper.DetectionZoneLimits_start_get
    if _newclass:
        start = _swig_property(_moduleconnectorwrapper.DetectionZoneLimits_start_get, _moduleconnectorwrapper.DetectionZoneLimits_start_set)
    __swig_setmethods__["end"] = _moduleconnectorwrapper.DetectionZoneLimits_end_set
    __swig_getmethods__["end"] = _moduleconnectorwrapper.DetectionZoneLimits_end_get
    if _newclass:
        end = _swig_property(_moduleconnectorwrapper.DetectionZoneLimits_end_get, _moduleconnectorwrapper.DetectionZoneLimits_end_set)
    __swig_setmethods__["step"] = _moduleconnectorwrapper.DetectionZoneLimits_step_set
    __swig_getmethods__["step"] = _moduleconnectorwrapper.DetectionZoneLimits_step_get
    if _newclass:
        step = _swig_property(_moduleconnectorwrapper.DetectionZoneLimits_step_get, _moduleconnectorwrapper.DetectionZoneLimits_step_set)

    def __init__(self):
        """__init__(XeThru::DetectionZoneLimits self) -> DetectionZoneLimits"""
        this = _moduleconnectorwrapper.new_DetectionZoneLimits()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_DetectionZoneLimits
    __del__ = lambda self: None
DetectionZoneLimits_swigregister = _moduleconnectorwrapper.DetectionZoneLimits_swigregister
DetectionZoneLimits_swigregister(DetectionZoneLimits)

class DataFloat(_object):
    """


    Encapulates a vector of float elements, for example baseband data.  

    This package can be retrieved from the module with the use of
    read_message_data_float in the XEP interface.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Parameters
    ----------
    * `content_id` :  
        id that tells what the content is.  
    * `info` :  
        this might be some generic information, but usually it is the frame counter
        value.  
    * `data` :  
        the vector of float elements.  

    Attributes
    ----------
    * `content_id` : `uint32_t`  

    * `info` : `uint32_t`  

    * `data` : `std::vector< float >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataFloat, name)
    __repr__ = _swig_repr
    __swig_setmethods__["content_id"] = _moduleconnectorwrapper.DataFloat_content_id_set
    __swig_getmethods__["content_id"] = _moduleconnectorwrapper.DataFloat_content_id_get
    if _newclass:
        content_id = _swig_property(_moduleconnectorwrapper.DataFloat_content_id_get, _moduleconnectorwrapper.DataFloat_content_id_set)
    __swig_setmethods__["info"] = _moduleconnectorwrapper.DataFloat_info_set
    __swig_getmethods__["info"] = _moduleconnectorwrapper.DataFloat_info_get
    if _newclass:
        info = _swig_property(_moduleconnectorwrapper.DataFloat_info_get, _moduleconnectorwrapper.DataFloat_info_set)

    def get_data(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_data(DataFloat self) -> FloatVector



        """
        return _moduleconnectorwrapper.DataFloat_get_data(self)


    def get_copy(self) -> "std::vector< float,std::allocator< float > >":
        """
        get_copy(DataFloat self) -> FloatVector



        """
        return _moduleconnectorwrapper.DataFloat_get_copy(self)

    __swig_setmethods__["data"] = _moduleconnectorwrapper.DataFloat_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.DataFloat_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.DataFloat_data_get, _moduleconnectorwrapper.DataFloat_data_set)

    def __init__(self):
        """__init__(XeThru::DataFloat self) -> DataFloat"""
        this = _moduleconnectorwrapper.new_DataFloat()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_DataFloat
    __del__ = lambda self: None
DataFloat_swigregister = _moduleconnectorwrapper.DataFloat_swigregister
DataFloat_swigregister(DataFloat)

class FrameArea(_object):
    """


    Parameters
    ----------
    * `start` :  
        the start of the frame area.  
    * `end` :  
        the end of the frame area.  

    Attributes
    ----------
    * `start` : `float`  

    * `end` : `float`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameArea, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FrameArea, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _moduleconnectorwrapper.FrameArea_start_set
    __swig_getmethods__["start"] = _moduleconnectorwrapper.FrameArea_start_get
    if _newclass:
        start = _swig_property(_moduleconnectorwrapper.FrameArea_start_get, _moduleconnectorwrapper.FrameArea_start_set)
    __swig_setmethods__["end"] = _moduleconnectorwrapper.FrameArea_end_set
    __swig_getmethods__["end"] = _moduleconnectorwrapper.FrameArea_end_get
    if _newclass:
        end = _swig_property(_moduleconnectorwrapper.FrameArea_end_get, _moduleconnectorwrapper.FrameArea_end_set)

    def __init__(self):
        """__init__(XeThru::FrameArea self) -> FrameArea"""
        this = _moduleconnectorwrapper.new_FrameArea()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_FrameArea
    __del__ = lambda self: None
FrameArea_swigregister = _moduleconnectorwrapper.FrameArea_swigregister
FrameArea_swigregister(FrameArea)

class DetectionZone(_object):
    """


    Representation of the detection zone.  

    Attributes
    ----------
    * `start` : `float`  
        Start of detection zone in meters from the radar module.  

    * `end` : `float`  
        End of detection zone in meters from the radar module.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DetectionZone, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DetectionZone, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _moduleconnectorwrapper.DetectionZone_start_set
    __swig_getmethods__["start"] = _moduleconnectorwrapper.DetectionZone_start_get
    if _newclass:
        start = _swig_property(_moduleconnectorwrapper.DetectionZone_start_get, _moduleconnectorwrapper.DetectionZone_start_set)
    __swig_setmethods__["end"] = _moduleconnectorwrapper.DetectionZone_end_set
    __swig_getmethods__["end"] = _moduleconnectorwrapper.DetectionZone_end_get
    if _newclass:
        end = _swig_property(_moduleconnectorwrapper.DetectionZone_end_get, _moduleconnectorwrapper.DetectionZone_end_set)

    def __init__(self):
        """__init__(XeThru::DetectionZone self) -> DetectionZone"""
        this = _moduleconnectorwrapper.new_DetectionZone()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_DetectionZone
    __del__ = lambda self: None
DetectionZone_swigregister = _moduleconnectorwrapper.DetectionZone_swigregister
DetectionZone_swigregister(DetectionZone)

class PeriodicNoisemapStore(_object):
    """


    Representation of periodic noisemap store parameters.  

    Attributes
    ----------
    * `interval_minutes` : `uint32_t`  

    * `reserved` : `uint32_t`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PeriodicNoisemapStore, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PeriodicNoisemapStore, name)
    __repr__ = _swig_repr
    __swig_setmethods__["interval_minutes"] = _moduleconnectorwrapper.PeriodicNoisemapStore_interval_minutes_set
    __swig_getmethods__["interval_minutes"] = _moduleconnectorwrapper.PeriodicNoisemapStore_interval_minutes_get
    if _newclass:
        interval_minutes = _swig_property(_moduleconnectorwrapper.PeriodicNoisemapStore_interval_minutes_get, _moduleconnectorwrapper.PeriodicNoisemapStore_interval_minutes_set)
    __swig_setmethods__["reserved"] = _moduleconnectorwrapper.PeriodicNoisemapStore_reserved_set
    __swig_getmethods__["reserved"] = _moduleconnectorwrapper.PeriodicNoisemapStore_reserved_get
    if _newclass:
        reserved = _swig_property(_moduleconnectorwrapper.PeriodicNoisemapStore_reserved_get, _moduleconnectorwrapper.PeriodicNoisemapStore_reserved_set)

    def __init__(self):
        """__init__(XeThru::PeriodicNoisemapStore self) -> PeriodicNoisemapStore"""
        this = _moduleconnectorwrapper.new_PeriodicNoisemapStore()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PeriodicNoisemapStore
    __del__ = lambda self: None
PeriodicNoisemapStore_swigregister = _moduleconnectorwrapper.PeriodicNoisemapStore_swigregister
PeriodicNoisemapStore_swigregister(PeriodicNoisemapStore)

class IoPinControl(_object):
    """


    Representation of io pin control configuration.  

    Attributes
    ----------
    * `setup` : `uint32_t`  

    * `feature` : `uint32_t`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IoPinControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IoPinControl, name)
    __repr__ = _swig_repr
    __swig_setmethods__["setup"] = _moduleconnectorwrapper.IoPinControl_setup_set
    __swig_getmethods__["setup"] = _moduleconnectorwrapper.IoPinControl_setup_get
    if _newclass:
        setup = _swig_property(_moduleconnectorwrapper.IoPinControl_setup_get, _moduleconnectorwrapper.IoPinControl_setup_set)
    __swig_setmethods__["feature"] = _moduleconnectorwrapper.IoPinControl_feature_set
    __swig_getmethods__["feature"] = _moduleconnectorwrapper.IoPinControl_feature_get
    if _newclass:
        feature = _swig_property(_moduleconnectorwrapper.IoPinControl_feature_get, _moduleconnectorwrapper.IoPinControl_feature_set)

    def __init__(self):
        """__init__(XeThru::IoPinControl self) -> IoPinControl"""
        this = _moduleconnectorwrapper.new_IoPinControl()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_IoPinControl
    __del__ = lambda self: None
IoPinControl_swigregister = _moduleconnectorwrapper.IoPinControl_swigregister
IoPinControl_swigregister(IoPinControl)

class RespirationData(_object):
    """


    Represents the respiration status data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `sensor_state` : `uint32_t`  
        This represent the steady state of the sensor module.  

    * `respiration_rate` : `uint32_t`  
        Respiration rate (respirations per minute / RPM).  

        Valid when SensorState is Breathing.  

    * `distance` : `float`  
        The distance from the sensor to the subject (which the sensor is currently
        locked on to).  

    * `movement` : `float`  
        Breathing pattern of closest breathing target: Detected respiratory movement
        in mm perpendicular to the sensor.  

    * `signal_quality` : `uint32_t`  
        Quality measure of the signal quality, describing the signal-to-noise ratio
        of the current respiration lock.  

        Value from 0 to 10, 0=low -> 10=high.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RespirationData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RespirationData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RespirationData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RespirationData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RespirationData_frame_counter_get, _moduleconnectorwrapper.RespirationData_frame_counter_set)
    __swig_setmethods__["sensor_state"] = _moduleconnectorwrapper.RespirationData_sensor_state_set
    __swig_getmethods__["sensor_state"] = _moduleconnectorwrapper.RespirationData_sensor_state_get
    if _newclass:
        sensor_state = _swig_property(_moduleconnectorwrapper.RespirationData_sensor_state_get, _moduleconnectorwrapper.RespirationData_sensor_state_set)
    __swig_setmethods__["respiration_rate"] = _moduleconnectorwrapper.RespirationData_respiration_rate_set
    __swig_getmethods__["respiration_rate"] = _moduleconnectorwrapper.RespirationData_respiration_rate_get
    if _newclass:
        respiration_rate = _swig_property(_moduleconnectorwrapper.RespirationData_respiration_rate_get, _moduleconnectorwrapper.RespirationData_respiration_rate_set)
    __swig_setmethods__["distance"] = _moduleconnectorwrapper.RespirationData_distance_set
    __swig_getmethods__["distance"] = _moduleconnectorwrapper.RespirationData_distance_get
    if _newclass:
        distance = _swig_property(_moduleconnectorwrapper.RespirationData_distance_get, _moduleconnectorwrapper.RespirationData_distance_set)
    __swig_setmethods__["movement"] = _moduleconnectorwrapper.RespirationData_movement_set
    __swig_getmethods__["movement"] = _moduleconnectorwrapper.RespirationData_movement_get
    if _newclass:
        movement = _swig_property(_moduleconnectorwrapper.RespirationData_movement_get, _moduleconnectorwrapper.RespirationData_movement_set)
    __swig_setmethods__["signal_quality"] = _moduleconnectorwrapper.RespirationData_signal_quality_set
    __swig_getmethods__["signal_quality"] = _moduleconnectorwrapper.RespirationData_signal_quality_get
    if _newclass:
        signal_quality = _swig_property(_moduleconnectorwrapper.RespirationData_signal_quality_get, _moduleconnectorwrapper.RespirationData_signal_quality_set)

    def __init__(self):
        """__init__(XeThru::RespirationData self) -> RespirationData"""
        this = _moduleconnectorwrapper.new_RespirationData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RespirationData
    __del__ = lambda self: None
RespirationData_swigregister = _moduleconnectorwrapper.RespirationData_swigregister
RespirationData_swigregister(RespirationData)

class SleepData(_object):
    """


    Represents the sleep status data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `sensor_state` : `uint32_t`  
        This represent the steady state of the sensor module.  

    * `respiration_rate` : `float`  
        Respiration rate (respirations per minute / RPM).  

        Valid when SensorState is Breathing.  

    * `distance` : `float`  
        Is the distance from the sensorto the subject (which the sensor is currently
        locked on to).  

    * `signal_quality` : `uint32_t`  
        Quality measure of the signal quality, describing the signal-to-noise ratio
        of the current respiration lock.  

        Value from 0 to 10, 0=low -> 10=high.  

    * `movement_slow` : `float`  
        First movement metric which captures the larger movements.  

        It is given as a percentage(0-100). Higher the percentage larger the
        movement.  

    * `movement_fast` : `float`  
        Second movement metric which also captures the larger movements.  

        It is represented as a percentage (0-100). Higher the percentage larger the
        movement. This metric is more responsive than the MovementSlow. It captures
        the movements faster than the former.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SleepData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SleepData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.SleepData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.SleepData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.SleepData_frame_counter_get, _moduleconnectorwrapper.SleepData_frame_counter_set)
    __swig_setmethods__["sensor_state"] = _moduleconnectorwrapper.SleepData_sensor_state_set
    __swig_getmethods__["sensor_state"] = _moduleconnectorwrapper.SleepData_sensor_state_get
    if _newclass:
        sensor_state = _swig_property(_moduleconnectorwrapper.SleepData_sensor_state_get, _moduleconnectorwrapper.SleepData_sensor_state_set)
    __swig_setmethods__["respiration_rate"] = _moduleconnectorwrapper.SleepData_respiration_rate_set
    __swig_getmethods__["respiration_rate"] = _moduleconnectorwrapper.SleepData_respiration_rate_get
    if _newclass:
        respiration_rate = _swig_property(_moduleconnectorwrapper.SleepData_respiration_rate_get, _moduleconnectorwrapper.SleepData_respiration_rate_set)
    __swig_setmethods__["distance"] = _moduleconnectorwrapper.SleepData_distance_set
    __swig_getmethods__["distance"] = _moduleconnectorwrapper.SleepData_distance_get
    if _newclass:
        distance = _swig_property(_moduleconnectorwrapper.SleepData_distance_get, _moduleconnectorwrapper.SleepData_distance_set)
    __swig_setmethods__["signal_quality"] = _moduleconnectorwrapper.SleepData_signal_quality_set
    __swig_getmethods__["signal_quality"] = _moduleconnectorwrapper.SleepData_signal_quality_get
    if _newclass:
        signal_quality = _swig_property(_moduleconnectorwrapper.SleepData_signal_quality_get, _moduleconnectorwrapper.SleepData_signal_quality_set)
    __swig_setmethods__["movement_slow"] = _moduleconnectorwrapper.SleepData_movement_slow_set
    __swig_getmethods__["movement_slow"] = _moduleconnectorwrapper.SleepData_movement_slow_get
    if _newclass:
        movement_slow = _swig_property(_moduleconnectorwrapper.SleepData_movement_slow_get, _moduleconnectorwrapper.SleepData_movement_slow_set)
    __swig_setmethods__["movement_fast"] = _moduleconnectorwrapper.SleepData_movement_fast_set
    __swig_getmethods__["movement_fast"] = _moduleconnectorwrapper.SleepData_movement_fast_get
    if _newclass:
        movement_fast = _swig_property(_moduleconnectorwrapper.SleepData_movement_fast_get, _moduleconnectorwrapper.SleepData_movement_fast_set)

    def __init__(self):
        """__init__(XeThru::SleepData self) -> SleepData"""
        this = _moduleconnectorwrapper.new_SleepData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_SleepData
    __del__ = lambda self: None
SleepData_swigregister = _moduleconnectorwrapper.SleepData_swigregister
SleepData_swigregister(SleepData)

class BasebandApData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents amplitude phase baseband data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `amplitude` : `std::vector< float >`  
        Vector of NumOfBins float values of the signal power.  

    * `phase` : `std::vector< float >`  
        Vector of NumOfBins float values of the signal phase.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BasebandApData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BasebandApData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::BasebandApData self) -> BasebandApData
        __init__(XeThru::BasebandApData self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float range_offset, float const * amplitude, float const * phase) -> BasebandApData



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_BasebandApData(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_amplitude(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_amplitude(BasebandApData self) -> FloatVector



        Returns a reference to the amplitude vector.  

        """
        return _moduleconnectorwrapper.BasebandApData_get_amplitude(self)


    def get_phase(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_phase(BasebandApData self) -> FloatVector



        Returns a reference to the phase vector.  

        """
        return _moduleconnectorwrapper.BasebandApData_get_phase(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.BasebandApData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.BasebandApData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.BasebandApData_frame_counter_get, _moduleconnectorwrapper.BasebandApData_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.BasebandApData_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.BasebandApData_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.BasebandApData_num_bins_get, _moduleconnectorwrapper.BasebandApData_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.BasebandApData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.BasebandApData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.BasebandApData_bin_length_get, _moduleconnectorwrapper.BasebandApData_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.BasebandApData_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.BasebandApData_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.BasebandApData_sample_frequency_get, _moduleconnectorwrapper.BasebandApData_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.BasebandApData_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.BasebandApData_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.BasebandApData_carrier_frequency_get, _moduleconnectorwrapper.BasebandApData_carrier_frequency_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.BasebandApData_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.BasebandApData_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.BasebandApData_range_offset_get, _moduleconnectorwrapper.BasebandApData_range_offset_set)
    __swig_setmethods__["amplitude"] = _moduleconnectorwrapper.BasebandApData_amplitude_set
    __swig_getmethods__["amplitude"] = _moduleconnectorwrapper.BasebandApData_amplitude_get
    if _newclass:
        amplitude = _swig_property(_moduleconnectorwrapper.BasebandApData_amplitude_get, _moduleconnectorwrapper.BasebandApData_amplitude_set)
    __swig_setmethods__["phase"] = _moduleconnectorwrapper.BasebandApData_phase_set
    __swig_getmethods__["phase"] = _moduleconnectorwrapper.BasebandApData_phase_get
    if _newclass:
        phase = _swig_property(_moduleconnectorwrapper.BasebandApData_phase_get, _moduleconnectorwrapper.BasebandApData_phase_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_BasebandApData
    __del__ = lambda self: None
BasebandApData_swigregister = _moduleconnectorwrapper.BasebandApData_swigregister
BasebandApData_swigregister(BasebandApData)

class BasebandIqData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents I/Q baseband data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `i_data` : `std::vector< float >`  
        Vector of NumOfBins float values of the inphase signal.  

    * `q_data` : `std::vector< float >`  
        Vector of NumOfBins float values of the quadrature phase signal.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BasebandIqData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BasebandIqData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::BasebandIqData self) -> BasebandIqData
        __init__(XeThru::BasebandIqData self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float range_offset, float const * i, float const * q) -> BasebandIqData



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_BasebandIqData(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_I(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_I(BasebandIqData self) -> FloatVector



        Returns a reference to the in phase vector.  

        """
        return _moduleconnectorwrapper.BasebandIqData_get_I(self)


    def get_Q(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_Q(BasebandIqData self) -> FloatVector



        Returns a reference to the in quadrature phase vector.  

        """
        return _moduleconnectorwrapper.BasebandIqData_get_Q(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.BasebandIqData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.BasebandIqData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.BasebandIqData_frame_counter_get, _moduleconnectorwrapper.BasebandIqData_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.BasebandIqData_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.BasebandIqData_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.BasebandIqData_num_bins_get, _moduleconnectorwrapper.BasebandIqData_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.BasebandIqData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.BasebandIqData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.BasebandIqData_bin_length_get, _moduleconnectorwrapper.BasebandIqData_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.BasebandIqData_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.BasebandIqData_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.BasebandIqData_sample_frequency_get, _moduleconnectorwrapper.BasebandIqData_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.BasebandIqData_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.BasebandIqData_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.BasebandIqData_carrier_frequency_get, _moduleconnectorwrapper.BasebandIqData_carrier_frequency_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.BasebandIqData_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.BasebandIqData_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.BasebandIqData_range_offset_get, _moduleconnectorwrapper.BasebandIqData_range_offset_set)
    __swig_setmethods__["i_data"] = _moduleconnectorwrapper.BasebandIqData_i_data_set
    __swig_getmethods__["i_data"] = _moduleconnectorwrapper.BasebandIqData_i_data_get
    if _newclass:
        i_data = _swig_property(_moduleconnectorwrapper.BasebandIqData_i_data_get, _moduleconnectorwrapper.BasebandIqData_i_data_set)
    __swig_setmethods__["q_data"] = _moduleconnectorwrapper.BasebandIqData_q_data_set
    __swig_getmethods__["q_data"] = _moduleconnectorwrapper.BasebandIqData_q_data_get
    if _newclass:
        q_data = _swig_property(_moduleconnectorwrapper.BasebandIqData_q_data_get, _moduleconnectorwrapper.BasebandIqData_q_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_BasebandIqData
    __del__ = lambda self: None
BasebandIqData_swigregister = _moduleconnectorwrapper.BasebandIqData_swigregister
BasebandIqData_swigregister(BasebandIqData)

class RadarRfData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents Radar RF data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `frames_per_second` : `float`  
        Chip frames per second in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `data` : `std::vector< uint32_t >`  
        Vector of NumOfBins float values of the signal.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadarRfData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadarRfData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::RadarRfData self) -> RadarRfData
        __init__(XeThru::RadarRfData self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float frames_per_second, float range_offset, uint32_t const * data) -> RadarRfData



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_RadarRfData(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_data(self) -> "std::vector< uint32_t,std::allocator< uint32_t > > const &":
        """
        get_data(RadarRfData self) -> uiVector



        Returns a reference to the data vector.  

        """
        return _moduleconnectorwrapper.RadarRfData_get_data(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RadarRfData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RadarRfData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RadarRfData_frame_counter_get, _moduleconnectorwrapper.RadarRfData_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.RadarRfData_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.RadarRfData_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.RadarRfData_num_bins_get, _moduleconnectorwrapper.RadarRfData_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.RadarRfData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.RadarRfData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.RadarRfData_bin_length_get, _moduleconnectorwrapper.RadarRfData_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarRfData_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarRfData_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.RadarRfData_sample_frequency_get, _moduleconnectorwrapper.RadarRfData_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarRfData_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarRfData_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.RadarRfData_carrier_frequency_get, _moduleconnectorwrapper.RadarRfData_carrier_frequency_set)
    __swig_setmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarRfData_frames_per_second_set
    __swig_getmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarRfData_frames_per_second_get
    if _newclass:
        frames_per_second = _swig_property(_moduleconnectorwrapper.RadarRfData_frames_per_second_get, _moduleconnectorwrapper.RadarRfData_frames_per_second_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.RadarRfData_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.RadarRfData_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.RadarRfData_range_offset_get, _moduleconnectorwrapper.RadarRfData_range_offset_set)
    __swig_setmethods__["data"] = _moduleconnectorwrapper.RadarRfData_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.RadarRfData_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.RadarRfData_data_get, _moduleconnectorwrapper.RadarRfData_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_RadarRfData
    __del__ = lambda self: None
RadarRfData_swigregister = _moduleconnectorwrapper.RadarRfData_swigregister
RadarRfData_swigregister(RadarRfData)

class RadarRfNormalizedData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents Radar RF Normalized data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `frames_per_second` : `float`  
        Chip frames per second in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `data` : `std::vector< float >`  
        Vector of NumOfBins float values of the signal.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadarRfNormalizedData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadarRfNormalizedData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::RadarRfNormalizedData self) -> RadarRfNormalizedData
        __init__(XeThru::RadarRfNormalizedData self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float frames_per_second, float range_offset, float const * data) -> RadarRfNormalizedData



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_RadarRfNormalizedData(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_data(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_data(RadarRfNormalizedData self) -> FloatVector



        Returns a reference to the data vector.  

        """
        return _moduleconnectorwrapper.RadarRfNormalizedData_get_data(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RadarRfNormalizedData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RadarRfNormalizedData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_frame_counter_get, _moduleconnectorwrapper.RadarRfNormalizedData_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.RadarRfNormalizedData_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.RadarRfNormalizedData_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_num_bins_get, _moduleconnectorwrapper.RadarRfNormalizedData_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.RadarRfNormalizedData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.RadarRfNormalizedData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_bin_length_get, _moduleconnectorwrapper.RadarRfNormalizedData_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarRfNormalizedData_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarRfNormalizedData_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_sample_frequency_get, _moduleconnectorwrapper.RadarRfNormalizedData_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarRfNormalizedData_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarRfNormalizedData_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_carrier_frequency_get, _moduleconnectorwrapper.RadarRfNormalizedData_carrier_frequency_set)
    __swig_setmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarRfNormalizedData_frames_per_second_set
    __swig_getmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarRfNormalizedData_frames_per_second_get
    if _newclass:
        frames_per_second = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_frames_per_second_get, _moduleconnectorwrapper.RadarRfNormalizedData_frames_per_second_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.RadarRfNormalizedData_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.RadarRfNormalizedData_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_range_offset_get, _moduleconnectorwrapper.RadarRfNormalizedData_range_offset_set)
    __swig_setmethods__["data"] = _moduleconnectorwrapper.RadarRfNormalizedData_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.RadarRfNormalizedData_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_data_get, _moduleconnectorwrapper.RadarRfNormalizedData_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_RadarRfNormalizedData
    __del__ = lambda self: None
RadarRfNormalizedData_swigregister = _moduleconnectorwrapper.RadarRfNormalizedData_swigregister
RadarRfNormalizedData_swigregister(RadarRfNormalizedData)

class RadarBasebandFloatData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents Radar Baseband Float data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `frames_per_second` : `float`  
        Chip frames per second in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `decimation_factor` : `uint32_t`  
        Decimation factor for signal.  

    * `correction_bin` : `uint32_t`  
        Bin used for phase noise correction.  

    * `correction_i` : `float`  
        Phase noise correction inphase.  

    * `correction_q` : `float`  
        Phase noise correction quadrature.  

    * `i_data` : `std::vector< float >`  
        Vector of NumOfBins float values of the inphase signal.  

    * `q_data` : `std::vector< float >`  
        Vector of NumOfBins float values of the quadrature phase signal.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadarBasebandFloatData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadarBasebandFloatData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::RadarBasebandFloatData self) -> RadarBasebandFloatData
        __init__(XeThru::RadarBasebandFloatData self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float frames_per_second, float range_offset, uint32_t decimation_factor, uint32_t correction_bin, float correction_i, float correction_q, float const * i, float const * q) -> RadarBasebandFloatData



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_RadarBasebandFloatData(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_I(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_I(RadarBasebandFloatData self) -> FloatVector



        Returns a reference to the in phase vector.  

        """
        return _moduleconnectorwrapper.RadarBasebandFloatData_get_I(self)


    def get_Q(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_Q(RadarBasebandFloatData self) -> FloatVector



        Returns a reference to the in quadrature phase vector.  

        """
        return _moduleconnectorwrapper.RadarBasebandFloatData_get_Q(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RadarBasebandFloatData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RadarBasebandFloatData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_frame_counter_get, _moduleconnectorwrapper.RadarBasebandFloatData_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.RadarBasebandFloatData_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.RadarBasebandFloatData_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_num_bins_get, _moduleconnectorwrapper.RadarBasebandFloatData_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.RadarBasebandFloatData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.RadarBasebandFloatData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_bin_length_get, _moduleconnectorwrapper.RadarBasebandFloatData_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarBasebandFloatData_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarBasebandFloatData_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_sample_frequency_get, _moduleconnectorwrapper.RadarBasebandFloatData_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarBasebandFloatData_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarBasebandFloatData_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_carrier_frequency_get, _moduleconnectorwrapper.RadarBasebandFloatData_carrier_frequency_set)
    __swig_setmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarBasebandFloatData_frames_per_second_set
    __swig_getmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarBasebandFloatData_frames_per_second_get
    if _newclass:
        frames_per_second = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_frames_per_second_get, _moduleconnectorwrapper.RadarBasebandFloatData_frames_per_second_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.RadarBasebandFloatData_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.RadarBasebandFloatData_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_range_offset_get, _moduleconnectorwrapper.RadarBasebandFloatData_range_offset_set)
    __swig_setmethods__["decimation_factor"] = _moduleconnectorwrapper.RadarBasebandFloatData_decimation_factor_set
    __swig_getmethods__["decimation_factor"] = _moduleconnectorwrapper.RadarBasebandFloatData_decimation_factor_get
    if _newclass:
        decimation_factor = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_decimation_factor_get, _moduleconnectorwrapper.RadarBasebandFloatData_decimation_factor_set)
    __swig_setmethods__["correction_bin"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_bin_set
    __swig_getmethods__["correction_bin"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_bin_get
    if _newclass:
        correction_bin = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_correction_bin_get, _moduleconnectorwrapper.RadarBasebandFloatData_correction_bin_set)
    __swig_setmethods__["correction_i"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_i_set
    __swig_getmethods__["correction_i"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_i_get
    if _newclass:
        correction_i = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_correction_i_get, _moduleconnectorwrapper.RadarBasebandFloatData_correction_i_set)
    __swig_setmethods__["correction_q"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_q_set
    __swig_getmethods__["correction_q"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_q_get
    if _newclass:
        correction_q = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_correction_q_get, _moduleconnectorwrapper.RadarBasebandFloatData_correction_q_set)
    __swig_setmethods__["i_data"] = _moduleconnectorwrapper.RadarBasebandFloatData_i_data_set
    __swig_getmethods__["i_data"] = _moduleconnectorwrapper.RadarBasebandFloatData_i_data_get
    if _newclass:
        i_data = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_i_data_get, _moduleconnectorwrapper.RadarBasebandFloatData_i_data_set)
    __swig_setmethods__["q_data"] = _moduleconnectorwrapper.RadarBasebandFloatData_q_data_set
    __swig_getmethods__["q_data"] = _moduleconnectorwrapper.RadarBasebandFloatData_q_data_get
    if _newclass:
        q_data = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_q_data_get, _moduleconnectorwrapper.RadarBasebandFloatData_q_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_RadarBasebandFloatData
    __del__ = lambda self: None
RadarBasebandFloatData_swigregister = _moduleconnectorwrapper.RadarBasebandFloatData_swigregister
RadarBasebandFloatData_swigregister(RadarBasebandFloatData)

class RadarBasebandQ15Data(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents Radar Baseband Q15 data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `frames_per_second` : `float`  
        Chip frames per second in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `decimation_factor` : `uint32_t`  
        Decimation factor for signal.  

    * `correction_bin` : `uint32_t`  
        Bin used for phase noise correction.  

    * `correction_i` : `float`  
        Phase noise correction inphase.  

    * `correction_q` : `float`  
        Phase noise correction quadrature.  

    * `scaling_factor` : `float`  
        Scaling factor for float to Q15 data.  

    * `i_data` : `std::vector< int16_t >`  
        Vector of NumOfBins float values of the inphase signal.  

    * `q_data` : `std::vector< int16_t >`  
        Vector of NumOfBins float values of the quadrature phase signal.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadarBasebandQ15Data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadarBasebandQ15Data, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::RadarBasebandQ15Data self) -> RadarBasebandQ15Data
        __init__(XeThru::RadarBasebandQ15Data self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float frames_per_second, float range_offset, uint32_t decimation_factor, uint32_t correction_bin, float correction_i, float correction_q, float scaling_factor, int16_t const * i, int16_t const * q) -> RadarBasebandQ15Data



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_RadarBasebandQ15Data(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_I(self) -> "std::vector< int16_t,std::allocator< int16_t > > const &":
        """
        get_I(RadarBasebandQ15Data self) -> sVector



        Returns a reference to the in phase vector.  

        """
        return _moduleconnectorwrapper.RadarBasebandQ15Data_get_I(self)


    def get_Q(self) -> "std::vector< int16_t,std::allocator< int16_t > > const &":
        """
        get_Q(RadarBasebandQ15Data self) -> sVector



        Returns a reference to the in quadrature phase vector.  

        """
        return _moduleconnectorwrapper.RadarBasebandQ15Data_get_Q(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RadarBasebandQ15Data_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RadarBasebandQ15Data_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_frame_counter_get, _moduleconnectorwrapper.RadarBasebandQ15Data_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.RadarBasebandQ15Data_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.RadarBasebandQ15Data_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_num_bins_get, _moduleconnectorwrapper.RadarBasebandQ15Data_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.RadarBasebandQ15Data_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.RadarBasebandQ15Data_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_bin_length_get, _moduleconnectorwrapper.RadarBasebandQ15Data_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarBasebandQ15Data_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarBasebandQ15Data_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_sample_frequency_get, _moduleconnectorwrapper.RadarBasebandQ15Data_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarBasebandQ15Data_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarBasebandQ15Data_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_carrier_frequency_get, _moduleconnectorwrapper.RadarBasebandQ15Data_carrier_frequency_set)
    __swig_setmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarBasebandQ15Data_frames_per_second_set
    __swig_getmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarBasebandQ15Data_frames_per_second_get
    if _newclass:
        frames_per_second = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_frames_per_second_get, _moduleconnectorwrapper.RadarBasebandQ15Data_frames_per_second_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.RadarBasebandQ15Data_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.RadarBasebandQ15Data_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_range_offset_get, _moduleconnectorwrapper.RadarBasebandQ15Data_range_offset_set)
    __swig_setmethods__["decimation_factor"] = _moduleconnectorwrapper.RadarBasebandQ15Data_decimation_factor_set
    __swig_getmethods__["decimation_factor"] = _moduleconnectorwrapper.RadarBasebandQ15Data_decimation_factor_get
    if _newclass:
        decimation_factor = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_decimation_factor_get, _moduleconnectorwrapper.RadarBasebandQ15Data_decimation_factor_set)
    __swig_setmethods__["correction_bin"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_bin_set
    __swig_getmethods__["correction_bin"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_bin_get
    if _newclass:
        correction_bin = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_correction_bin_get, _moduleconnectorwrapper.RadarBasebandQ15Data_correction_bin_set)
    __swig_setmethods__["correction_i"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_i_set
    __swig_getmethods__["correction_i"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_i_get
    if _newclass:
        correction_i = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_correction_i_get, _moduleconnectorwrapper.RadarBasebandQ15Data_correction_i_set)
    __swig_setmethods__["correction_q"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_q_set
    __swig_getmethods__["correction_q"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_q_get
    if _newclass:
        correction_q = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_correction_q_get, _moduleconnectorwrapper.RadarBasebandQ15Data_correction_q_set)
    __swig_setmethods__["scaling_factor"] = _moduleconnectorwrapper.RadarBasebandQ15Data_scaling_factor_set
    __swig_getmethods__["scaling_factor"] = _moduleconnectorwrapper.RadarBasebandQ15Data_scaling_factor_get
    if _newclass:
        scaling_factor = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_scaling_factor_get, _moduleconnectorwrapper.RadarBasebandQ15Data_scaling_factor_set)
    __swig_setmethods__["i_data"] = _moduleconnectorwrapper.RadarBasebandQ15Data_i_data_set
    __swig_getmethods__["i_data"] = _moduleconnectorwrapper.RadarBasebandQ15Data_i_data_get
    if _newclass:
        i_data = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_i_data_get, _moduleconnectorwrapper.RadarBasebandQ15Data_i_data_set)
    __swig_setmethods__["q_data"] = _moduleconnectorwrapper.RadarBasebandQ15Data_q_data_set
    __swig_getmethods__["q_data"] = _moduleconnectorwrapper.RadarBasebandQ15Data_q_data_get
    if _newclass:
        q_data = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_q_data_get, _moduleconnectorwrapper.RadarBasebandQ15Data_q_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_RadarBasebandQ15Data
    __del__ = lambda self: None
RadarBasebandQ15Data_swigregister = _moduleconnectorwrapper.RadarBasebandQ15Data_swigregister
RadarBasebandQ15Data_swigregister(RadarBasebandQ15Data)

class PresenceSingleData(_object):
    """


    Encapsulates and aggregates true presenece data coming from the Xethru X4M300
    module.  

    Parameters
    ----------
    * `frame_counter` :  
        The frame counter  
    * `presence_state` :  
        Presence state output. See xtid.h for values.  
    * `distance` :  
        Distance in meters from sensor to presence detected.  
    * `direction` :  
        Movement direction of detected object.  
    * `signal_quality` :  
        signal quality  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  

    * `presence_state` : `uint32_t`  

    * `distance` : `float`  

    * `direction` : `uint8_t`  

    * `signal_quality` : `uint32_t`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PresenceSingleData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PresenceSingleData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.PresenceSingleData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.PresenceSingleData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.PresenceSingleData_frame_counter_get, _moduleconnectorwrapper.PresenceSingleData_frame_counter_set)
    __swig_setmethods__["presence_state"] = _moduleconnectorwrapper.PresenceSingleData_presence_state_set
    __swig_getmethods__["presence_state"] = _moduleconnectorwrapper.PresenceSingleData_presence_state_get
    if _newclass:
        presence_state = _swig_property(_moduleconnectorwrapper.PresenceSingleData_presence_state_get, _moduleconnectorwrapper.PresenceSingleData_presence_state_set)
    __swig_setmethods__["distance"] = _moduleconnectorwrapper.PresenceSingleData_distance_set
    __swig_getmethods__["distance"] = _moduleconnectorwrapper.PresenceSingleData_distance_get
    if _newclass:
        distance = _swig_property(_moduleconnectorwrapper.PresenceSingleData_distance_get, _moduleconnectorwrapper.PresenceSingleData_distance_set)
    __swig_setmethods__["direction"] = _moduleconnectorwrapper.PresenceSingleData_direction_set
    __swig_getmethods__["direction"] = _moduleconnectorwrapper.PresenceSingleData_direction_get
    if _newclass:
        direction = _swig_property(_moduleconnectorwrapper.PresenceSingleData_direction_get, _moduleconnectorwrapper.PresenceSingleData_direction_set)
    __swig_setmethods__["signal_quality"] = _moduleconnectorwrapper.PresenceSingleData_signal_quality_set
    __swig_getmethods__["signal_quality"] = _moduleconnectorwrapper.PresenceSingleData_signal_quality_get
    if _newclass:
        signal_quality = _swig_property(_moduleconnectorwrapper.PresenceSingleData_signal_quality_get, _moduleconnectorwrapper.PresenceSingleData_signal_quality_set)

    def __init__(self):
        """__init__(XeThru::PresenceSingleData self) -> PresenceSingleData"""
        this = _moduleconnectorwrapper.new_PresenceSingleData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PresenceSingleData
    __del__ = lambda self: None
PresenceSingleData_swigregister = _moduleconnectorwrapper.PresenceSingleData_swigregister
PresenceSingleData_swigregister(PresenceSingleData)

class PresenceMovingListData(_object):
    """


    Encapsulates and aggregates presence data coming from the Xethru X4M300 module.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Parameters
    ----------
    * `frame_counter` :  
        The frame counter  
    * `presence_state` :  
        Presence state output. See xtid.h for values.  
    * `movement_slow_items` :  
        List of movement metrics split into sections of the detection zone. Longer
        integration time. First element is a global metric.  
    * `movement_fast_items` :  
        List of movement metrics split into sections of the detection zone. Shorter
        integration time. First element is a global metric.  
    * `detection_distance_items` :  
        Not implemented.  
    * `radar_cross_section_items` :  
        Not implemented.  
    * `detection_velocity_items` :  
        Not implemented.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  

    * `presence_state` : `uint32_t`  

    * `movement_slow_items` : `std::vector< float >`  

    * `movement_fast_items` : `std::vector< float >`  

    * `detection_distance_items` : `std::vector< float >`  

    * `radar_cross_section_items` : `std::vector< float >`  

    * `detection_velocity_items` : `std::vector< float >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PresenceMovingListData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PresenceMovingListData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.PresenceMovingListData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.PresenceMovingListData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_frame_counter_get, _moduleconnectorwrapper.PresenceMovingListData_frame_counter_set)
    __swig_setmethods__["presence_state"] = _moduleconnectorwrapper.PresenceMovingListData_presence_state_set
    __swig_getmethods__["presence_state"] = _moduleconnectorwrapper.PresenceMovingListData_presence_state_get
    if _newclass:
        presence_state = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_presence_state_get, _moduleconnectorwrapper.PresenceMovingListData_presence_state_set)
    __swig_setmethods__["movement_slow_items"] = _moduleconnectorwrapper.PresenceMovingListData_movement_slow_items_set
    __swig_getmethods__["movement_slow_items"] = _moduleconnectorwrapper.PresenceMovingListData_movement_slow_items_get
    if _newclass:
        movement_slow_items = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_movement_slow_items_get, _moduleconnectorwrapper.PresenceMovingListData_movement_slow_items_set)
    __swig_setmethods__["movement_fast_items"] = _moduleconnectorwrapper.PresenceMovingListData_movement_fast_items_set
    __swig_getmethods__["movement_fast_items"] = _moduleconnectorwrapper.PresenceMovingListData_movement_fast_items_get
    if _newclass:
        movement_fast_items = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_movement_fast_items_get, _moduleconnectorwrapper.PresenceMovingListData_movement_fast_items_set)
    __swig_setmethods__["detection_distance_items"] = _moduleconnectorwrapper.PresenceMovingListData_detection_distance_items_set
    __swig_getmethods__["detection_distance_items"] = _moduleconnectorwrapper.PresenceMovingListData_detection_distance_items_get
    if _newclass:
        detection_distance_items = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_detection_distance_items_get, _moduleconnectorwrapper.PresenceMovingListData_detection_distance_items_set)
    __swig_setmethods__["radar_cross_section_items"] = _moduleconnectorwrapper.PresenceMovingListData_radar_cross_section_items_set
    __swig_getmethods__["radar_cross_section_items"] = _moduleconnectorwrapper.PresenceMovingListData_radar_cross_section_items_get
    if _newclass:
        radar_cross_section_items = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_radar_cross_section_items_get, _moduleconnectorwrapper.PresenceMovingListData_radar_cross_section_items_set)
    __swig_setmethods__["detection_velocity_items"] = _moduleconnectorwrapper.PresenceMovingListData_detection_velocity_items_set
    __swig_getmethods__["detection_velocity_items"] = _moduleconnectorwrapper.PresenceMovingListData_detection_velocity_items_get
    if _newclass:
        detection_velocity_items = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_detection_velocity_items_get, _moduleconnectorwrapper.PresenceMovingListData_detection_velocity_items_set)

    def get_movement_slow_items(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_movement_slow_items(PresenceMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.PresenceMovingListData_get_movement_slow_items(self)


    def get_movement_fast_items(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_movement_fast_items(PresenceMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.PresenceMovingListData_get_movement_fast_items(self)


    def get_detection_distance_items(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_detection_distance_items(PresenceMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.PresenceMovingListData_get_detection_distance_items(self)


    def get_radar_cross_section(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_radar_cross_section(PresenceMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.PresenceMovingListData_get_radar_cross_section(self)


    def get_detection_velocity_items(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_detection_velocity_items(PresenceMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.PresenceMovingListData_get_detection_velocity_items(self)


    def __init__(self):
        """__init__(XeThru::PresenceMovingListData self) -> PresenceMovingListData"""
        this = _moduleconnectorwrapper.new_PresenceMovingListData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PresenceMovingListData
    __del__ = lambda self: None
PresenceMovingListData_swigregister = _moduleconnectorwrapper.PresenceMovingListData_swigregister
PresenceMovingListData_swigregister(PresenceMovingListData)

class RespirationMovingListData(_object):
    """


    Movement is a percentage of Doppler bins above threshold.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Parameters
    ----------
    * `counter` :  
        Frame counter.  
    * `movement_slow_items` :  
        Percentage of Doppler bins above threshold per range bin, slow integration.
        First element is a global metric.  
    * `movement_fast_items` :  
        Percentage of Doppler bins above threshold per range bin, fast integration.
        First element is a global metric.  

    Attributes
    ----------
    * `counter` : `uint32_t`  

    * `movement_slow_items` : `std::vector< float >`  

    * `movement_fast_items` : `std::vector< float >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RespirationMovingListData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RespirationMovingListData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["counter"] = _moduleconnectorwrapper.RespirationMovingListData_counter_set
    __swig_getmethods__["counter"] = _moduleconnectorwrapper.RespirationMovingListData_counter_get
    if _newclass:
        counter = _swig_property(_moduleconnectorwrapper.RespirationMovingListData_counter_get, _moduleconnectorwrapper.RespirationMovingListData_counter_set)
    __swig_setmethods__["movement_slow_items"] = _moduleconnectorwrapper.RespirationMovingListData_movement_slow_items_set
    __swig_getmethods__["movement_slow_items"] = _moduleconnectorwrapper.RespirationMovingListData_movement_slow_items_get
    if _newclass:
        movement_slow_items = _swig_property(_moduleconnectorwrapper.RespirationMovingListData_movement_slow_items_get, _moduleconnectorwrapper.RespirationMovingListData_movement_slow_items_set)
    __swig_setmethods__["movement_fast_items"] = _moduleconnectorwrapper.RespirationMovingListData_movement_fast_items_set
    __swig_getmethods__["movement_fast_items"] = _moduleconnectorwrapper.RespirationMovingListData_movement_fast_items_get
    if _newclass:
        movement_fast_items = _swig_property(_moduleconnectorwrapper.RespirationMovingListData_movement_fast_items_get, _moduleconnectorwrapper.RespirationMovingListData_movement_fast_items_set)

    def get_movement_slow_items(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_movement_slow_items(RespirationMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.RespirationMovingListData_get_movement_slow_items(self)


    def get_movement_fast_items(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_movement_fast_items(RespirationMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.RespirationMovingListData_get_movement_fast_items(self)


    def __init__(self):
        """__init__(XeThru::RespirationMovingListData self) -> RespirationMovingListData"""
        this = _moduleconnectorwrapper.new_RespirationMovingListData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RespirationMovingListData
    __del__ = lambda self: None
RespirationMovingListData_swigregister = _moduleconnectorwrapper.RespirationMovingListData_swigregister
RespirationMovingListData_swigregister(RespirationMovingListData)

class RespirationDetectionListData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Parameters
    ----------
    * `counter` :  
        Frame counter.  
    * `detection_count` :  
        Number of detections.  
    * `detection_distance_items` :  
        Distance per detection.  
    * `detection_radar_cross_section_items` :  
        RCS per detection.  
    * `detection_velocity_items` :  
        Velocity per detection.  

    Attributes
    ----------
    * `counter` : `uint32_t`  

    * `detection_count` : `uint32_t`  

    * `detection_distance_items` : `std::vector< float >`  

    * `detection_radar_cross_section_items` : `std::vector< float >`  

    * `detection_velocity_items` : `std::vector< float >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RespirationDetectionListData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RespirationDetectionListData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["counter"] = _moduleconnectorwrapper.RespirationDetectionListData_counter_set
    __swig_getmethods__["counter"] = _moduleconnectorwrapper.RespirationDetectionListData_counter_get
    if _newclass:
        counter = _swig_property(_moduleconnectorwrapper.RespirationDetectionListData_counter_get, _moduleconnectorwrapper.RespirationDetectionListData_counter_set)
    __swig_setmethods__["detection_count"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_count_set
    __swig_getmethods__["detection_count"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_count_get
    if _newclass:
        detection_count = _swig_property(_moduleconnectorwrapper.RespirationDetectionListData_detection_count_get, _moduleconnectorwrapper.RespirationDetectionListData_detection_count_set)
    __swig_setmethods__["detection_distance_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_distance_items_set
    __swig_getmethods__["detection_distance_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_distance_items_get
    if _newclass:
        detection_distance_items = _swig_property(_moduleconnectorwrapper.RespirationDetectionListData_detection_distance_items_get, _moduleconnectorwrapper.RespirationDetectionListData_detection_distance_items_set)
    __swig_setmethods__["detection_radar_cross_section_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_radar_cross_section_items_set
    __swig_getmethods__["detection_radar_cross_section_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_radar_cross_section_items_get
    if _newclass:
        detection_radar_cross_section_items = _swig_property(_moduleconnectorwrapper.RespirationDetectionListData_detection_radar_cross_section_items_get, _moduleconnectorwrapper.RespirationDetectionListData_detection_radar_cross_section_items_set)
    __swig_setmethods__["detection_velocity_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_velocity_items_set
    __swig_getmethods__["detection_velocity_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_velocity_items_get
    if _newclass:
        detection_velocity_items = _swig_property(_moduleconnectorwrapper.RespirationDetectionListData_detection_velocity_items_get, _moduleconnectorwrapper.RespirationDetectionListData_detection_velocity_items_set)

    def get_detection_distance_items(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_detection_distance_items(RespirationDetectionListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.RespirationDetectionListData_get_detection_distance_items(self)


    def get_detection_radar_cross_section_items(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_detection_radar_cross_section_items(RespirationDetectionListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.RespirationDetectionListData_get_detection_radar_cross_section_items(self)


    def get_detection_velocity_items(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_detection_velocity_items(RespirationDetectionListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.RespirationDetectionListData_get_detection_velocity_items(self)


    def __init__(self):
        """__init__(XeThru::RespirationDetectionListData self) -> RespirationDetectionListData"""
        this = _moduleconnectorwrapper.new_RespirationDetectionListData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RespirationDetectionListData
    __del__ = lambda self: None
RespirationDetectionListData_swigregister = _moduleconnectorwrapper.RespirationDetectionListData_swigregister
RespirationDetectionListData_swigregister(RespirationDetectionListData)

class RespirationNormalizedMovementListData(_object):
    """


    Movement in absolute terms, sum of power per Doppler bin over threshold
    compensated for range.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Parameters
    ----------
    * `frame_counter` :  
        Frame counter.  
    * `start` :  
        Distance to first range bin in meters.  
    * `bin_length` :  
        Length of one bin in meters.  
    * `count` :  
        Number of range bins.  
    * `normalized_movement_slow_items` :  
        Movement per range bin, slow integration. First element is first rangebin,
        NOT a global metric.  
    * `normalized_movement_fast_items` :  
        Movement per range bin, fast integration. First element is first rangebin,
        NOT a global metric.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  

    * `start` : `float`  

    * `bin_length` : `float`  

    * `count` : `uint32_t`  

    * `normalized_movement_slow_items` : `std::vector< float >`  

    * `normalized_movement_fast_items` : `std::vector< float >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RespirationNormalizedMovementListData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RespirationNormalizedMovementListData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_frame_counter_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_frame_counter_set)
    __swig_setmethods__["start"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_start_set
    __swig_getmethods__["start"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_start_get
    if _newclass:
        start = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_start_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_start_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_bin_length_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_bin_length_set)
    __swig_setmethods__["count"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_count_set
    __swig_getmethods__["count"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_count_get
    if _newclass:
        count = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_count_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_count_set)
    __swig_setmethods__["normalized_movement_slow_items"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_slow_items_set
    __swig_getmethods__["normalized_movement_slow_items"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_slow_items_get
    if _newclass:
        normalized_movement_slow_items = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_slow_items_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_slow_items_set)
    __swig_setmethods__["normalized_movement_fast_items"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_fast_items_set
    __swig_getmethods__["normalized_movement_fast_items"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_fast_items_get
    if _newclass:
        normalized_movement_fast_items = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_fast_items_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_fast_items_set)

    def __init__(self):
        """__init__(XeThru::RespirationNormalizedMovementListData self) -> RespirationNormalizedMovementListData"""
        this = _moduleconnectorwrapper.new_RespirationNormalizedMovementListData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RespirationNormalizedMovementListData
    __del__ = lambda self: None
RespirationNormalizedMovementListData_swigregister = _moduleconnectorwrapper.RespirationNormalizedMovementListData_swigregister
RespirationNormalizedMovementListData_swigregister(RespirationNormalizedMovementListData)

class VitalSignsData(_object):
    """


    Various vital signs.  

    Parameters
    ----------
    * `frame_counter` :  
        Frame counter.  
    * `sensor_state` :  
        See XTS_VAL_RESP_STATE_* in xtid.h for meaning.  
    * `respiration_rate` :  
        Respirations per minute  
    * `respiration_distance` :  
        Distance to breather.  
    * `respiration_confidence` :  
        Confidence. Not yet used.  
    * `heart_rate` :  
        Beats per minute. Not yet used.  
    * `heart_distance` :  
        Distance to target with pulse. Not yet used.  
    * `heart_confidence` :  
        Confidence. Not yet used.  
    * `normalized_movement_slow` :  
        Sum of movement within a fixed range from the target, slow integration.  
    * `normalized_movement_fast` :  
        Sum of movement within a fixed range from the target, fast integration.  
    * `normalized_movement_start` :  
        Start of the range to sum.  
    * `normalized_movement_end` :  
        End of the range to sum.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  

    * `sensor_state` : `uint32_t`  

    * `respiration_rate` : `float`  

    * `respiration_distance` : `float`  

    * `respiration_confidence` : `float`  

    * `heart_rate` : `float`  

    * `heart_distance` : `float`  

    * `heart_confidence` : `float`  

    * `normalized_movement_slow` : `float`  

    * `normalized_movement_fast` : `float`  

    * `normalized_movement_start` : `float`  

    * `normalized_movement_end` : `float`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VitalSignsData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VitalSignsData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.VitalSignsData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.VitalSignsData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.VitalSignsData_frame_counter_get, _moduleconnectorwrapper.VitalSignsData_frame_counter_set)
    __swig_setmethods__["sensor_state"] = _moduleconnectorwrapper.VitalSignsData_sensor_state_set
    __swig_getmethods__["sensor_state"] = _moduleconnectorwrapper.VitalSignsData_sensor_state_get
    if _newclass:
        sensor_state = _swig_property(_moduleconnectorwrapper.VitalSignsData_sensor_state_get, _moduleconnectorwrapper.VitalSignsData_sensor_state_set)
    __swig_setmethods__["respiration_rate"] = _moduleconnectorwrapper.VitalSignsData_respiration_rate_set
    __swig_getmethods__["respiration_rate"] = _moduleconnectorwrapper.VitalSignsData_respiration_rate_get
    if _newclass:
        respiration_rate = _swig_property(_moduleconnectorwrapper.VitalSignsData_respiration_rate_get, _moduleconnectorwrapper.VitalSignsData_respiration_rate_set)
    __swig_setmethods__["respiration_distance"] = _moduleconnectorwrapper.VitalSignsData_respiration_distance_set
    __swig_getmethods__["respiration_distance"] = _moduleconnectorwrapper.VitalSignsData_respiration_distance_get
    if _newclass:
        respiration_distance = _swig_property(_moduleconnectorwrapper.VitalSignsData_respiration_distance_get, _moduleconnectorwrapper.VitalSignsData_respiration_distance_set)
    __swig_setmethods__["respiration_confidence"] = _moduleconnectorwrapper.VitalSignsData_respiration_confidence_set
    __swig_getmethods__["respiration_confidence"] = _moduleconnectorwrapper.VitalSignsData_respiration_confidence_get
    if _newclass:
        respiration_confidence = _swig_property(_moduleconnectorwrapper.VitalSignsData_respiration_confidence_get, _moduleconnectorwrapper.VitalSignsData_respiration_confidence_set)
    __swig_setmethods__["heart_rate"] = _moduleconnectorwrapper.VitalSignsData_heart_rate_set
    __swig_getmethods__["heart_rate"] = _moduleconnectorwrapper.VitalSignsData_heart_rate_get
    if _newclass:
        heart_rate = _swig_property(_moduleconnectorwrapper.VitalSignsData_heart_rate_get, _moduleconnectorwrapper.VitalSignsData_heart_rate_set)
    __swig_setmethods__["heart_distance"] = _moduleconnectorwrapper.VitalSignsData_heart_distance_set
    __swig_getmethods__["heart_distance"] = _moduleconnectorwrapper.VitalSignsData_heart_distance_get
    if _newclass:
        heart_distance = _swig_property(_moduleconnectorwrapper.VitalSignsData_heart_distance_get, _moduleconnectorwrapper.VitalSignsData_heart_distance_set)
    __swig_setmethods__["heart_confidence"] = _moduleconnectorwrapper.VitalSignsData_heart_confidence_set
    __swig_getmethods__["heart_confidence"] = _moduleconnectorwrapper.VitalSignsData_heart_confidence_get
    if _newclass:
        heart_confidence = _swig_property(_moduleconnectorwrapper.VitalSignsData_heart_confidence_get, _moduleconnectorwrapper.VitalSignsData_heart_confidence_set)
    __swig_setmethods__["normalized_movement_slow"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_slow_set
    __swig_getmethods__["normalized_movement_slow"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_slow_get
    if _newclass:
        normalized_movement_slow = _swig_property(_moduleconnectorwrapper.VitalSignsData_normalized_movement_slow_get, _moduleconnectorwrapper.VitalSignsData_normalized_movement_slow_set)
    __swig_setmethods__["normalized_movement_fast"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_fast_set
    __swig_getmethods__["normalized_movement_fast"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_fast_get
    if _newclass:
        normalized_movement_fast = _swig_property(_moduleconnectorwrapper.VitalSignsData_normalized_movement_fast_get, _moduleconnectorwrapper.VitalSignsData_normalized_movement_fast_set)
    __swig_setmethods__["normalized_movement_start"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_start_set
    __swig_getmethods__["normalized_movement_start"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_start_get
    if _newclass:
        normalized_movement_start = _swig_property(_moduleconnectorwrapper.VitalSignsData_normalized_movement_start_get, _moduleconnectorwrapper.VitalSignsData_normalized_movement_start_set)
    __swig_setmethods__["normalized_movement_end"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_end_set
    __swig_getmethods__["normalized_movement_end"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_end_get
    if _newclass:
        normalized_movement_end = _swig_property(_moduleconnectorwrapper.VitalSignsData_normalized_movement_end_get, _moduleconnectorwrapper.VitalSignsData_normalized_movement_end_set)

    def __init__(self):
        """__init__(XeThru::VitalSignsData self) -> VitalSignsData"""
        this = _moduleconnectorwrapper.new_VitalSignsData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_VitalSignsData
    __del__ = lambda self: None
VitalSignsData_swigregister = _moduleconnectorwrapper.VitalSignsData_swigregister
VitalSignsData_swigregister(VitalSignsData)

class SleepStageData(_object):
    """


    Attributes
    ----------
    * `frame_counter` : `uint32_t`  

    * `sleepstage` : `uint32_t`  

    * `confidence` : `uint32_t`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SleepStageData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SleepStageData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.SleepStageData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.SleepStageData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.SleepStageData_frame_counter_get, _moduleconnectorwrapper.SleepStageData_frame_counter_set)
    __swig_setmethods__["sleepstage"] = _moduleconnectorwrapper.SleepStageData_sleepstage_set
    __swig_getmethods__["sleepstage"] = _moduleconnectorwrapper.SleepStageData_sleepstage_get
    if _newclass:
        sleepstage = _swig_property(_moduleconnectorwrapper.SleepStageData_sleepstage_get, _moduleconnectorwrapper.SleepStageData_sleepstage_set)
    __swig_setmethods__["confidence"] = _moduleconnectorwrapper.SleepStageData_confidence_set
    __swig_getmethods__["confidence"] = _moduleconnectorwrapper.SleepStageData_confidence_get
    if _newclass:
        confidence = _swig_property(_moduleconnectorwrapper.SleepStageData_confidence_get, _moduleconnectorwrapper.SleepStageData_confidence_set)

    def __init__(self):
        """__init__(XeThru::SleepStageData self) -> SleepStageData"""
        this = _moduleconnectorwrapper.new_SleepStageData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_SleepStageData
    __del__ = lambda self: None
SleepStageData_swigregister = _moduleconnectorwrapper.SleepStageData_swigregister
SleepStageData_swigregister(SleepStageData)

class Files(_object):
    """


    Attributes
    ----------
    * `file_type_items` : `std::vector< int32_t >`  

    * `file_identifier_items` : `std::vector< int32_t >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Files, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Files, name)
    __repr__ = _swig_repr
    __swig_setmethods__["file_type_items"] = _moduleconnectorwrapper.Files_file_type_items_set
    __swig_getmethods__["file_type_items"] = _moduleconnectorwrapper.Files_file_type_items_get
    if _newclass:
        file_type_items = _swig_property(_moduleconnectorwrapper.Files_file_type_items_get, _moduleconnectorwrapper.Files_file_type_items_set)
    __swig_setmethods__["file_identifier_items"] = _moduleconnectorwrapper.Files_file_identifier_items_set
    __swig_getmethods__["file_identifier_items"] = _moduleconnectorwrapper.Files_file_identifier_items_get
    if _newclass:
        file_identifier_items = _swig_property(_moduleconnectorwrapper.Files_file_identifier_items_get, _moduleconnectorwrapper.Files_file_identifier_items_set)

    def get_file_type_items(self) -> "std::vector< int32_t,std::allocator< int32_t > >":
        """
        get_file_type_items(Files self) -> iVector



        """
        return _moduleconnectorwrapper.Files_get_file_type_items(self)


    def get_file_identifier_items(self) -> "std::vector< int32_t,std::allocator< int32_t > >":
        """
        get_file_identifier_items(Files self) -> iVector



        """
        return _moduleconnectorwrapper.Files_get_file_identifier_items(self)


    def __init__(self):
        """__init__(XeThru::Files self) -> Files"""
        this = _moduleconnectorwrapper.new_Files()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_Files
    __del__ = lambda self: None
Files_swigregister = _moduleconnectorwrapper.Files_swigregister
Files_swigregister(Files)

class PulseDopplerFloatData(_object):
    """


    Represents one half or one range bin of pulse-Doppler in float format.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        Frame counter generated from chip data rate.  

    * `matrix_counter` : `uint32_t`  
        Incremental matrix counter.  

    * `range_idx` : `uint32_t`  
        Range bin index of current Doppler vector.  

    * `range_bins` : `uint32_t`  
        Number of total range bins in the pulse-Doppler output matrix.  

    * `frequency_count` : `uint32_t`  
        Number of points in frequency axis.  

    * `pulsedoppler_instance` : `uint32_t`  
        Selected pulse-Doppler type from [0..N-1] where N is number of PDs.  

    * `fps` : `float`  
        Output chip framerate (frames per second)  

    * `fps_decimated` : `float`  
        Input FPS of this pulse-Doppler instance.  

    * `frequency_start` : `float`  
        Frequency of first value.  

    * `frequency_step` : `float`  
        Difference between each frequency bin.  

    * `range` : `float`  
        Absolute range of current frequency array.  

    * `data` : `std::vector< float >`  
        Power of pulse-Doppler bins.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PulseDopplerFloatData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PulseDopplerFloatData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::PulseDopplerFloatData self) -> PulseDopplerFloatData
        __init__(XeThru::PulseDopplerFloatData self, uint32_t frame_counter, uint32_t matrix_counter, uint32_t range_idx, uint32_t range_bins, uint32_t frequency_count, uint32_t pulsedoppler_instance, float fps, float fps_decimated, float frequency_start, float frequency_step, float range, float const * data) -> PulseDopplerFloatData



        """
        this = _moduleconnectorwrapper.new_PulseDopplerFloatData(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_data(self) -> "std::vector< float,std::allocator< float > > const &":
        """
        get_data(PulseDopplerFloatData self) -> FloatVector



        Returns a reference to the data.  

        """
        return _moduleconnectorwrapper.PulseDopplerFloatData_get_data(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.PulseDopplerFloatData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.PulseDopplerFloatData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_frame_counter_get, _moduleconnectorwrapper.PulseDopplerFloatData_frame_counter_set)
    __swig_setmethods__["matrix_counter"] = _moduleconnectorwrapper.PulseDopplerFloatData_matrix_counter_set
    __swig_getmethods__["matrix_counter"] = _moduleconnectorwrapper.PulseDopplerFloatData_matrix_counter_get
    if _newclass:
        matrix_counter = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_matrix_counter_get, _moduleconnectorwrapper.PulseDopplerFloatData_matrix_counter_set)
    __swig_setmethods__["range_idx"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_idx_set
    __swig_getmethods__["range_idx"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_idx_get
    if _newclass:
        range_idx = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_range_idx_get, _moduleconnectorwrapper.PulseDopplerFloatData_range_idx_set)
    __swig_setmethods__["range_bins"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_bins_set
    __swig_getmethods__["range_bins"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_bins_get
    if _newclass:
        range_bins = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_range_bins_get, _moduleconnectorwrapper.PulseDopplerFloatData_range_bins_set)
    __swig_setmethods__["frequency_count"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_count_set
    __swig_getmethods__["frequency_count"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_count_get
    if _newclass:
        frequency_count = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_frequency_count_get, _moduleconnectorwrapper.PulseDopplerFloatData_frequency_count_set)
    __swig_setmethods__["pulsedoppler_instance"] = _moduleconnectorwrapper.PulseDopplerFloatData_pulsedoppler_instance_set
    __swig_getmethods__["pulsedoppler_instance"] = _moduleconnectorwrapper.PulseDopplerFloatData_pulsedoppler_instance_get
    if _newclass:
        pulsedoppler_instance = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_pulsedoppler_instance_get, _moduleconnectorwrapper.PulseDopplerFloatData_pulsedoppler_instance_set)
    __swig_setmethods__["fps"] = _moduleconnectorwrapper.PulseDopplerFloatData_fps_set
    __swig_getmethods__["fps"] = _moduleconnectorwrapper.PulseDopplerFloatData_fps_get
    if _newclass:
        fps = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_fps_get, _moduleconnectorwrapper.PulseDopplerFloatData_fps_set)
    __swig_setmethods__["fps_decimated"] = _moduleconnectorwrapper.PulseDopplerFloatData_fps_decimated_set
    __swig_getmethods__["fps_decimated"] = _moduleconnectorwrapper.PulseDopplerFloatData_fps_decimated_get
    if _newclass:
        fps_decimated = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_fps_decimated_get, _moduleconnectorwrapper.PulseDopplerFloatData_fps_decimated_set)
    __swig_setmethods__["frequency_start"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_start_set
    __swig_getmethods__["frequency_start"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_start_get
    if _newclass:
        frequency_start = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_frequency_start_get, _moduleconnectorwrapper.PulseDopplerFloatData_frequency_start_set)
    __swig_setmethods__["frequency_step"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_step_set
    __swig_getmethods__["frequency_step"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_step_get
    if _newclass:
        frequency_step = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_frequency_step_get, _moduleconnectorwrapper.PulseDopplerFloatData_frequency_step_set)
    __swig_setmethods__["range"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_set
    __swig_getmethods__["range"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_get
    if _newclass:
        range = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_range_get, _moduleconnectorwrapper.PulseDopplerFloatData_range_set)
    __swig_setmethods__["data"] = _moduleconnectorwrapper.PulseDopplerFloatData_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.PulseDopplerFloatData_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_data_get, _moduleconnectorwrapper.PulseDopplerFloatData_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_PulseDopplerFloatData
    __del__ = lambda self: None
PulseDopplerFloatData_swigregister = _moduleconnectorwrapper.PulseDopplerFloatData_swigregister
PulseDopplerFloatData_swigregister(PulseDopplerFloatData)

class PulseDopplerByteData(_object):
    """


    Represents one half or one range bin of pulse-Doppler in byte format.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        Frame counter generated from chip data rate.  

    * `matrix_counter` : `uint32_t`  
        Incremental matrix counter.  

    * `range_idx` : `uint32_t`  
        Range bin index of current Doppler vector.  

    * `range_bins` : `uint32_t`  
        Number of total range bins in the pulse-Doppler output matrix.  

    * `frequency_count` : `uint32_t`  
        Number of points in frequency axis.  

    * `pulsedoppler_instance` : `uint32_t`  
        Selected pulse-Doppler type from [0..N-1] where N is number of PDs.  

    * `byte_step_start` : `float`  
        Start of dB-compression range.  

    * `byte_step_size` : `float`  
        Size of one step in dB.  

    * `fps` : `float`  
        Output chip framerate (frames per second)  

    * `fps_decimated` : `float`  
        Input FPS of this pulse-Doppler instance.  

    * `frequency_start` : `float`  
        Frequency of first value.  

    * `frequency_step` : `float`  
        Difference between each frequency bin.  

    * `range` : `float`  
        Absolute range of current frequency array.  

    * `data` : `Bytes`  
        Power of pulse-Doppler bins.  

        \[ float = 10^{(byte * byte\_step\_size + byte\_step\_start)/10} \]  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PulseDopplerByteData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PulseDopplerByteData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::PulseDopplerByteData self) -> PulseDopplerByteData
        __init__(XeThru::PulseDopplerByteData self, uint32_t frame_counter, uint32_t matrix_counter, uint32_t range_idx, uint32_t range_bins, uint32_t frequency_count, uint32_t pulsedoppler_instance, float byte_step_start, float byte_step_size, float fps, float fps_decimated, float frequency_start, float frequency_step, float range, unsigned char const * data) -> PulseDopplerByteData



        """
        this = _moduleconnectorwrapper.new_PulseDopplerByteData(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_data(self) -> "Bytes const &":
        """
        get_data(PulseDopplerByteData self) -> ucVector



        Returns a reference to the data.  

        """
        return _moduleconnectorwrapper.PulseDopplerByteData_get_data(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.PulseDopplerByteData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.PulseDopplerByteData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_frame_counter_get, _moduleconnectorwrapper.PulseDopplerByteData_frame_counter_set)
    __swig_setmethods__["matrix_counter"] = _moduleconnectorwrapper.PulseDopplerByteData_matrix_counter_set
    __swig_getmethods__["matrix_counter"] = _moduleconnectorwrapper.PulseDopplerByteData_matrix_counter_get
    if _newclass:
        matrix_counter = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_matrix_counter_get, _moduleconnectorwrapper.PulseDopplerByteData_matrix_counter_set)
    __swig_setmethods__["range_idx"] = _moduleconnectorwrapper.PulseDopplerByteData_range_idx_set
    __swig_getmethods__["range_idx"] = _moduleconnectorwrapper.PulseDopplerByteData_range_idx_get
    if _newclass:
        range_idx = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_range_idx_get, _moduleconnectorwrapper.PulseDopplerByteData_range_idx_set)
    __swig_setmethods__["range_bins"] = _moduleconnectorwrapper.PulseDopplerByteData_range_bins_set
    __swig_getmethods__["range_bins"] = _moduleconnectorwrapper.PulseDopplerByteData_range_bins_get
    if _newclass:
        range_bins = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_range_bins_get, _moduleconnectorwrapper.PulseDopplerByteData_range_bins_set)
    __swig_setmethods__["frequency_count"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_count_set
    __swig_getmethods__["frequency_count"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_count_get
    if _newclass:
        frequency_count = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_frequency_count_get, _moduleconnectorwrapper.PulseDopplerByteData_frequency_count_set)
    __swig_setmethods__["pulsedoppler_instance"] = _moduleconnectorwrapper.PulseDopplerByteData_pulsedoppler_instance_set
    __swig_getmethods__["pulsedoppler_instance"] = _moduleconnectorwrapper.PulseDopplerByteData_pulsedoppler_instance_get
    if _newclass:
        pulsedoppler_instance = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_pulsedoppler_instance_get, _moduleconnectorwrapper.PulseDopplerByteData_pulsedoppler_instance_set)
    __swig_setmethods__["byte_step_start"] = _moduleconnectorwrapper.PulseDopplerByteData_byte_step_start_set
    __swig_getmethods__["byte_step_start"] = _moduleconnectorwrapper.PulseDopplerByteData_byte_step_start_get
    if _newclass:
        byte_step_start = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_byte_step_start_get, _moduleconnectorwrapper.PulseDopplerByteData_byte_step_start_set)
    __swig_setmethods__["byte_step_size"] = _moduleconnectorwrapper.PulseDopplerByteData_byte_step_size_set
    __swig_getmethods__["byte_step_size"] = _moduleconnectorwrapper.PulseDopplerByteData_byte_step_size_get
    if _newclass:
        byte_step_size = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_byte_step_size_get, _moduleconnectorwrapper.PulseDopplerByteData_byte_step_size_set)
    __swig_setmethods__["fps"] = _moduleconnectorwrapper.PulseDopplerByteData_fps_set
    __swig_getmethods__["fps"] = _moduleconnectorwrapper.PulseDopplerByteData_fps_get
    if _newclass:
        fps = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_fps_get, _moduleconnectorwrapper.PulseDopplerByteData_fps_set)
    __swig_setmethods__["fps_decimated"] = _moduleconnectorwrapper.PulseDopplerByteData_fps_decimated_set
    __swig_getmethods__["fps_decimated"] = _moduleconnectorwrapper.PulseDopplerByteData_fps_decimated_get
    if _newclass:
        fps_decimated = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_fps_decimated_get, _moduleconnectorwrapper.PulseDopplerByteData_fps_decimated_set)
    __swig_setmethods__["frequency_start"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_start_set
    __swig_getmethods__["frequency_start"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_start_get
    if _newclass:
        frequency_start = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_frequency_start_get, _moduleconnectorwrapper.PulseDopplerByteData_frequency_start_set)
    __swig_setmethods__["frequency_step"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_step_set
    __swig_getmethods__["frequency_step"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_step_get
    if _newclass:
        frequency_step = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_frequency_step_get, _moduleconnectorwrapper.PulseDopplerByteData_frequency_step_set)
    __swig_setmethods__["range"] = _moduleconnectorwrapper.PulseDopplerByteData_range_set
    __swig_getmethods__["range"] = _moduleconnectorwrapper.PulseDopplerByteData_range_get
    if _newclass:
        range = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_range_get, _moduleconnectorwrapper.PulseDopplerByteData_range_set)
    __swig_setmethods__["data"] = _moduleconnectorwrapper.PulseDopplerByteData_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.PulseDopplerByteData_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_data_get, _moduleconnectorwrapper.PulseDopplerByteData_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_PulseDopplerByteData
    __del__ = lambda self: None
PulseDopplerByteData_swigregister = _moduleconnectorwrapper.PulseDopplerByteData_swigregister
PulseDopplerByteData_swigregister(PulseDopplerByteData)

class DataRecord(_object):
    """


    Encapsulates data and information about one data record on disk.  

    One record is a collection of fields as specified by the Xethru File Formats doc
    for the given data type.  

    note: Data and information is valid only if is_valid is true.  

    Parameters
    ----------
    * `data` :  
        contains bytes as specified by Xethru File Formats doc if is_user_header is
        false. Otherwise contains custom user header as supplied by the user (see
        *RecordingOptions::set_user_header*).  
    * `data_type` :  
        Specifies the data type for the record (see DataType).  
    * `epoch` :  
        Specifies the date/time the record was written to disk as number of
        milliseconds since 1970.01.01.  
    * `is_valid` :  
        Specifies whether the fields in this struct is valid.  
    * `is_user_header` :  
        Specifies whether the data contains custom user header.  

    Attributes
    ----------
    * `data` : `Bytes`  

    * `data_type` : `uint32_t`  

    * `epoch` : `int64_t`  

    * `is_valid` : `bool`  

    * `is_user_header` : `bool`  

    * `meta_version` : `uint32_t`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataRecord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataRecord, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(XeThru::DataRecord self) -> DataRecord



        """
        this = _moduleconnectorwrapper.new_DataRecord()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_data(self) -> "Bytes const &":
        """
        get_data(DataRecord self) -> ucVector



        Const reference accessor to data.  

        In particular useful from Python to avoid unecessary overhead when read-only
        access to data is needed.  

        Returns
        -------
        a const reference to the data.  

        """
        return _moduleconnectorwrapper.DataRecord_get_data(self)


    def is_csv_header(self) -> "bool":
        """
        is_csv_header(DataRecord self) -> bool



        """
        return _moduleconnectorwrapper.DataRecord_is_csv_header(self)


    def to_binary_packet(self, ok: 'bool *'=None) -> "Bytes":
        """
        to_binary_packet(DataRecord self, bool * ok=None) -> ucVector
        to_binary_packet(DataRecord self) -> ucVector



        """
        return _moduleconnectorwrapper.DataRecord_to_binary_packet(self, ok)


    def to_sleep_data(self, ok: 'bool *'=None) -> "XeThru::SleepData":
        """
        to_sleep_data(DataRecord self, bool * ok=None) -> SleepData
        to_sleep_data(DataRecord self) -> SleepData



        """
        return _moduleconnectorwrapper.DataRecord_to_sleep_data(self, ok)


    def to_vitalsigns_data(self, ok: 'bool *'=None) -> "XeThru::VitalSignsData":
        """
        to_vitalsigns_data(DataRecord self, bool * ok=None) -> VitalSignsData
        to_vitalsigns_data(DataRecord self) -> VitalSignsData



        """
        return _moduleconnectorwrapper.DataRecord_to_vitalsigns_data(self, ok)

    __swig_setmethods__["data"] = _moduleconnectorwrapper.DataRecord_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.DataRecord_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.DataRecord_data_get, _moduleconnectorwrapper.DataRecord_data_set)
    __swig_setmethods__["data_type"] = _moduleconnectorwrapper.DataRecord_data_type_set
    __swig_getmethods__["data_type"] = _moduleconnectorwrapper.DataRecord_data_type_get
    if _newclass:
        data_type = _swig_property(_moduleconnectorwrapper.DataRecord_data_type_get, _moduleconnectorwrapper.DataRecord_data_type_set)
    __swig_setmethods__["epoch"] = _moduleconnectorwrapper.DataRecord_epoch_set
    __swig_getmethods__["epoch"] = _moduleconnectorwrapper.DataRecord_epoch_get
    if _newclass:
        epoch = _swig_property(_moduleconnectorwrapper.DataRecord_epoch_get, _moduleconnectorwrapper.DataRecord_epoch_set)
    __swig_setmethods__["is_valid"] = _moduleconnectorwrapper.DataRecord_is_valid_set
    __swig_getmethods__["is_valid"] = _moduleconnectorwrapper.DataRecord_is_valid_get
    if _newclass:
        is_valid = _swig_property(_moduleconnectorwrapper.DataRecord_is_valid_get, _moduleconnectorwrapper.DataRecord_is_valid_set)
    __swig_setmethods__["is_user_header"] = _moduleconnectorwrapper.DataRecord_is_user_header_set
    __swig_getmethods__["is_user_header"] = _moduleconnectorwrapper.DataRecord_is_user_header_get
    if _newclass:
        is_user_header = _swig_property(_moduleconnectorwrapper.DataRecord_is_user_header_get, _moduleconnectorwrapper.DataRecord_is_user_header_set)
    __swig_setmethods__["meta_version"] = _moduleconnectorwrapper.DataRecord_meta_version_set
    __swig_getmethods__["meta_version"] = _moduleconnectorwrapper.DataRecord_meta_version_get
    if _newclass:
        meta_version = _swig_property(_moduleconnectorwrapper.DataRecord_meta_version_get, _moduleconnectorwrapper.DataRecord_meta_version_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_DataRecord
    __del__ = lambda self: None
DataRecord_swigregister = _moduleconnectorwrapper.DataRecord_swigregister
DataRecord_swigregister(DataRecord)

class PreferredSplitSize(_object):
    """


    The PreferredSplitSize class allows specifying a split size.  

    The PreferredSplitSize class contains functions to define a preferred split size
    for files and directories specified in either duration (seconds) or as number of
    bytes. Specifying both is not supported; the last specified type will rule.  

    note: As the class name indicates, the size is only a *preferred* size. There is
        no guarantee that the actual size will match 100%.  

    See also: DataRecorder, RecordingOptions  

    C++ includes: PreferredSplitSize.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PreferredSplitSize, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PreferredSplitSize, name)
    __repr__ = _swig_repr
    DurationType = _moduleconnectorwrapper.PreferredSplitSize_DurationType
    ByteCountType = _moduleconnectorwrapper.PreferredSplitSize_ByteCountType
    FixedDailyHour = _moduleconnectorwrapper.PreferredSplitSize_FixedDailyHour
    InvalidType = _moduleconnectorwrapper.PreferredSplitSize_InvalidType

    def __init__(self, *args):
        """
        __init__(XeThru::PreferredSplitSize self) -> PreferredSplitSize
        __init__(XeThru::PreferredSplitSize self, PreferredSplitSize other) -> PreferredSplitSize
        __init__(XeThru::PreferredSplitSize self, PreferredSplitSize other) -> PreferredSplitSize



        Move constructor.  

        """
        this = _moduleconnectorwrapper.new_PreferredSplitSize(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PreferredSplitSize
    __del__ = lambda self: None

    def get_duration(self) -> "int":
        """
        get_duration(PreferredSplitSize self) -> int



        Returns
        -------
        the preferred split size in seconds if set, otherwise -1.  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_get_duration(self)


    def set_duration(self, seconds: 'int') -> "void":
        """
        set_duration(PreferredSplitSize self, int seconds)



        Sets the preferred split size specified in seconds.  

        Parameters
        ----------
        * `seconds` :  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_set_duration(self, seconds)


    def get_byte_count(self) -> "int64_t":
        """
        get_byte_count(PreferredSplitSize self) -> int64_t



        Returns
        -------
        the preferred file size as number of bytes if set, otherwise -1.  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_get_byte_count(self)


    def set_byte_count(self, count: 'int64_t') -> "void":
        """
        set_byte_count(PreferredSplitSize self, int64_t count)



        Sets the preferred split size specified as number of bytes.  

        Parameters
        ----------
        * `count` :  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_set_byte_count(self, count)


    def get_fixed_daily_hour(self) -> "int":
        """
        get_fixed_daily_hour(PreferredSplitSize self) -> int



        Returns
        -------
        the fixed daily hour if set (0-23), otherwise returns -1.  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_get_fixed_daily_hour(self)


    def set_fixed_daily_hour(self, hour: 'int') -> "void":
        """
        set_fixed_daily_hour(PreferredSplitSize self, int hour)



        Sets the preferred split size to a fixed daily hour.  

        Range is 24 hour clock (0-23). For example, if splitting every day at 2pm is
        desired, the parameter to this function would be 14. By default, no fixed daily
        hour is set.  

        Parameters
        ----------
        * `hour` :  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_set_fixed_daily_hour(self, hour)


    def get_type(self) -> "XeThru::PreferredSplitSize::SizeType":
        """
        get_type(PreferredSplitSize self) -> XeThru::PreferredSplitSize::SizeType



        The value reflects the last specified type, e.g.  

        if calling set_duration(15 * 60) this function returns DurationType.  

        Returns
        -------
        the type of the preferred size.  

        See also: SizeType  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_get_type(self)

PreferredSplitSize_swigregister = _moduleconnectorwrapper.PreferredSplitSize_swigregister
PreferredSplitSize_swigregister(PreferredSplitSize)

class RecordingOptions(_object):
    """


    The RecordingOptions class allows specifying options for recording.  

    The RecordingOptions class contains more advance options for recording. It can
    be used to specify things like splitting of files and directories.  

    See also: DataRecorder  

    C++ includes: RecordingOptions.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RecordingOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RecordingOptions, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::RecordingOptions self) -> RecordingOptions
        __init__(XeThru::RecordingOptions self, RecordingOptions other) -> RecordingOptions
        __init__(XeThru::RecordingOptions self, RecordingOptions other) -> RecordingOptions



        Move constructor.  

        """
        this = _moduleconnectorwrapper.new_RecordingOptions(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RecordingOptions
    __del__ = lambda self: None

    def set_session_id(self, id: 'std::string const &') -> "void":
        """
        set_session_id(RecordingOptions self, std::string const & id)



        Sets the session id as specified, overriding the default constructed value which
        is an universally unique identifier (UUID).  

        Parameters
        ----------
        * `id` :  
            Specifies the new id  

        See also: get_session_id  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_session_id(self, id)


    def get_session_id(self) -> "std::string":
        """
        get_session_id(RecordingOptions self) -> std::string



        By default, this function returns an universally unique identifier (UUID) if no
        custom id is set.  

        Returns
        -------
        the session id  

        See also: set_session_id  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_session_id(self)


    def set_file_split_size(self, size: 'PreferredSplitSize') -> "void":
        """
        set_file_split_size(RecordingOptions self, PreferredSplitSize size)



        Sets the preferred file split size as specified.  

        Parameters
        ----------
        * `size` :  
            Specifies the preferred split size  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_file_split_size(self, size)


    def get_file_split_size(self) -> "XeThru::PreferredSplitSize":
        """
        get_file_split_size(RecordingOptions self) -> PreferredSplitSize



        By default, this function returns a default constructed value (no file split
        size) if no custom size is set.  

        Returns
        -------
        the preferred file split size  

        See also: PreferredSplitSize  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_file_split_size(self)


    def set_directory_split_size(self, size: 'PreferredSplitSize') -> "void":
        """
        set_directory_split_size(RecordingOptions self, PreferredSplitSize size)



        Sets the preferred directory split size as specified.  

        Parameters
        ----------
        * `size` :  
            Specifies the preferred split size  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_directory_split_size(self, size)


    def get_directory_split_size(self) -> "XeThru::PreferredSplitSize":
        """
        get_directory_split_size(RecordingOptions self) -> PreferredSplitSize



        By default, this function returns a default constructed value (no directory
        split size) if no custom size is set.  

        Returns
        -------
        the preferred directory split size  

        See also: PreferredSplitSize  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_directory_split_size(self)


    def set_data_rate_limit(self, limit: 'int') -> "void":
        """
        set_data_rate_limit(RecordingOptions self, int limit)



        Sets the data rate (ms) the recorder will read data from the module.  

        A value of 1000 ms means data is read every second. Data in between is
        discarded. By default, this parameter is -1 (no data rate limit).  

        Parameters
        ----------
        * `limit` :  
            Specifies the data rate limit  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_data_rate_limit(self, limit)


    def get_data_rate_limit(self) -> "int":
        """
        get_data_rate_limit(RecordingOptions self) -> int



        Returns
        -------
        the data rate (ms) the recorder will read data from the module if set, otherwise
        returns -1 (no data rate limit). A value of 1000 ms means data is read every
        second. Data in between is discarded.  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_data_rate_limit(self)


    def set_user_header(self, header: 'ucVector') -> "void":
        """
        set_user_header(RecordingOptions self, ucVector header)



        Sets a custom header applied to the beginning of the recorded file.  

        By default, this parameter is Bytes() (no custom header).  

        Parameters
        ----------
        * `header` :  
            Specifies the header  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_user_header(self, header)


    def get_user_header(self) -> "Bytes":
        """
        get_user_header(RecordingOptions self) -> ucVector



        Returns
        -------
        the custom user header. By default, this parameter is Bytes() (no custom
        header).  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_user_header(self)


    def set_flush_on_write(self, do_flush: 'bool') -> "void":
        """
        set_flush_on_write(RecordingOptions self, bool do_flush)



        Specify whether to flush on every write.  

        Note that this will impact the performance and should only be used for debugging
        purposes. The default is false.  

        Parameters
        ----------
        * `do_flush` :  
            If true, recording files are flushed after every write.  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_flush_on_write(self, do_flush)


    def get_flush_on_write(self) -> "bool":
        """
        get_flush_on_write(RecordingOptions self) -> bool



        Returns
        -------
        Whether flushing for every write to file is enabled.  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_flush_on_write(self)

RecordingOptions_swigregister = _moduleconnectorwrapper.RecordingOptions_swigregister
RecordingOptions_swigregister(RecordingOptions)

class PythonModuleConnector(_object):
    """


    This class is responsible for establishing contact with the XeThru module.  

    Use one of the get_XXX methods to access the module-specific functionality.  

    C++ includes: PythonModuleConnector.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonModuleConnector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonModuleConnector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::PythonModuleConnector self, int log_level) -> PythonModuleConnector
        __init__(XeThru::PythonModuleConnector self, std::string const & device_name, int log_level) -> PythonModuleConnector
        __init__(XeThru::PythonModuleConnector self, PyDataPlayer player, int log_level) -> PythonModuleConnector
        __init__(XeThru::PythonModuleConnector self, in_addr_t ip, in_port_t port, int log_level) -> PythonModuleConnector



        Constructor.  

        The constructor will open the address and port given using TCP/IP.  

        XXX: The open/close mechanisms will give undefined behaviour if started this
        way.  

        Parameters
        ----------
        * `ip` :  
            The IP to connect to  
        * `port` :  
            The TCP port to connect to  
        * `log_level` :  
            The log level to use during operation  

        """
        this = _moduleconnectorwrapper.new_PythonModuleConnector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PythonModuleConnector
    __del__ = lambda self: None

    def git_sha(self) -> "std::string":
        """
        git_sha(PythonModuleConnector self) -> std::string



        Provides the git sha of the ModuleConnector repository.  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_git_sha(self)


    def open(self, device: 'std::string const') -> "void":
        """
        open(PythonModuleConnector self, std::string const device)



        Opens a new connection to a module via some serial device.  

        Parameters
        ----------
        * `device` :  
            Name of the device file for example /dev/ttyACM0 or COM4  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_open(self, device)


    def close(self) -> "void":
        """
        close(PythonModuleConnector self)



        Close an open connection to the module.  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_close(self)


    def set_log_level(self, new_log_level: 'int') -> "void":
        """
        set_log_level(PythonModuleConnector self, int new_log_level)



        Set log level during ModuleConnector operation.  

        Parameters
        ----------
        * `new_log_level` :  
            The new log level to use  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_set_log_level(self, new_log_level)


    def set_default_timeout(self, new_default_timeout: 'unsigned int') -> "void":
        """
        set_default_timeout(PythonModuleConnector self, unsigned int new_default_timeout)



        Set default timeout for commands sent to the module.  

        Parameters
        ----------
        * `new_default_timeout` :  
            New timeout to use  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_set_default_timeout(self, new_default_timeout)


    def get_data_recorder(self) -> "XeThru::PyDataRecorder &":
        """
        get_data_recorder(PythonModuleConnector self) -> PyDataRecorder



        Returns a reference to the PyDataRecorder application interface.  

        Returns
        -------
        The reference to the PyDataRecorder interface  

        See also: pymoduleconnector.moduleconnectorwrapper.PyDataRecorder  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_data_recorder(self)


    def get_transport(self) -> "XeThru::Transport &":
        """
        get_transport(PythonModuleConnector self) -> Transport



        Not supported.  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_transport(self)


    def get_x2m200(self) -> "XeThru::PyX2M200 &":
        """
        get_x2m200(PythonModuleConnector self) -> PyX2M200



        Returns a reference to the X2M200 module application interface.  

        Returns
        -------
        The reference to the X2M200 interface.  

        See also: pymoduleconnector.moduleconnectorwrapper.PyX2M200  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_x2m200(self)


    def get_x2(self) -> "XeThru::X2 &":
        """
        get_x2(PythonModuleConnector self) -> X2



        Not supported.  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_x2(self)


    def get_xep(self) -> "XeThru::PyXEP &":
        """
        get_xep(PythonModuleConnector self) -> PyXEP



        Returns a reference to the low level XEP interface.  

        Returns
        -------
        The reference to the XEP interface.  

        See also: pymoduleconnector.moduleconnectorwrapper.PyXEP  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_xep(self)


    def get_x4m300(self) -> "XeThru::PyX4M300 &":
        """
        get_x4m300(PythonModuleConnector self) -> PyX4M300



        Returns a reference to the X4M300 module application interface.  

        Returns
        -------
        The reference to the X4M300 interface.  

        See also: pymoduleconnector.moduleconnectorwrapper.PyX4M300  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_x4m300(self)


    def get_x4m200(self) -> "XeThru::PyX4M200 &":
        """
        get_x4m200(PythonModuleConnector self) -> PyX4M200



        Returns a reference to the X4M200 module application interface.  

        Returns
        -------
        The reference to the X4M200 interface.  

        See also: pymoduleconnector.moduleconnectorwrapper.PyX4M200  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_x4m200(self)


    def get_x4m210(self) -> "XeThru::PyX4M210 &":
        """
        get_x4m210(PythonModuleConnector self) -> PyX4M210



        Returns a reference to the X4M210 module application interface.  

        Returns
        -------
        The reference to the X4M210 interface.  

        See also: pymoduleconnector.moduleconnectorwrapper.PyX4M210  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_x4m210(self)


    def get_not_supported(self) -> "XeThru::NotSupported &":
        """
        get_not_supported(PythonModuleConnector self) -> NotSupported



        Not supported.  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_not_supported(self)

PythonModuleConnector_swigregister = _moduleconnectorwrapper.PythonModuleConnector_swigregister
PythonModuleConnector_swigregister(PythonModuleConnector)

class Bootloader(_object):
    """Proxy of C++ XeThru::Bootloader class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Bootloader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Bootloader, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::Bootloader self, std::string const & device_name, bool log_to_stdout, bool log_to_file, unsigned int log_level) -> Bootloader
        __init__(XeThru::Bootloader self, std::string const & device_name, unsigned int log_level) -> Bootloader
        __init__(XeThru::Bootloader self, std::string const & device_name, unsigned int log_level, XeThru::AbstractLoggerIo * logger_io) -> Bootloader
        __init__(XeThru::Bootloader self, std::string const & device_name, Logger * logger) -> Bootloader
        __init__(XeThru::Bootloader self, in_addr_t ip, in_port_t port, int log_level, XeThru::AbstractLoggerIo * logger_io) -> Bootloader
        __init__(XeThru::Bootloader self, in_addr_t ip, in_port_t port) -> Bootloader
        __init__(XeThru::Bootloader self, in_addr_t ip, in_port_t port, int log_level) -> Bootloader
        """
        this = _moduleconnectorwrapper.new_Bootloader(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_Bootloader
    __del__ = lambda self: None

    def write_page(self, page_address: 'unsigned int', page_data: 'ucVector') -> "int":
        """write_page(Bootloader self, unsigned int page_address, ucVector page_data) -> int"""
        return _moduleconnectorwrapper.Bootloader_write_page(self, page_address, page_data)


    def start_application(self, *args) -> "int":
        """
        start_application(Bootloader self) -> int
        start_application(Bootloader self, unsigned int timeout) -> int
        """
        return _moduleconnectorwrapper.Bootloader_start_application(self, *args)


    def get_bootloader_info(self) -> "std::string":
        """get_bootloader_info(Bootloader self) -> std::string"""
        return _moduleconnectorwrapper.Bootloader_get_bootloader_info(self)

Bootloader_swigregister = _moduleconnectorwrapper.Bootloader_swigregister
Bootloader_swigregister(Bootloader)

class NotSupported(_object):
    """Proxy of C++ XeThru::NotSupported class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotSupported, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NotSupported, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface: 'LockedRadarInterfacePtr &'):
        """__init__(XeThru::NotSupported self, LockedRadarInterfacePtr & radar_interface) -> NotSupported"""
        this = _moduleconnectorwrapper.new_NotSupported(radar_interface)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_NotSupported
    __del__ = lambda self: None

    def get_x4_io_pin_value(self, pin: 'unsigned char') -> "Byte":
        """get_x4_io_pin_value(NotSupported self, unsigned char pin) -> Byte"""
        return _moduleconnectorwrapper.NotSupported_get_x4_io_pin_value(self, pin)


    def set_x4_io_pin_value(self, pin: 'unsigned char', value: 'unsigned char') -> "int":
        """set_x4_io_pin_value(NotSupported self, unsigned char pin, unsigned char value) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_io_pin_value(self, pin, value)


    def set_x4_io_pin_mode(self, pin: 'unsigned char const', mode: 'unsigned char const') -> "int":
        """set_x4_io_pin_mode(NotSupported self, unsigned char const pin, unsigned char const mode) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_io_pin_mode(self, pin, mode)


    def set_x4_io_pin_dir(self, pin: 'unsigned char const', direction: 'unsigned char const') -> "int":
        """set_x4_io_pin_dir(NotSupported self, unsigned char const pin, unsigned char const direction) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_io_pin_dir(self, pin, direction)


    def set_x4_io_pin_enable(self, pin: 'unsigned char const') -> "int":
        """set_x4_io_pin_enable(NotSupported self, unsigned char const pin) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_io_pin_enable(self, pin)


    def set_x4_io_pin_disable(self, pin: 'unsigned char const') -> "int":
        """set_x4_io_pin_disable(NotSupported self, unsigned char const pin) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_io_pin_disable(self, pin)


    def read_x4_spi(self, address: 'unsigned char const') -> "unsigned char":
        """read_x4_spi(NotSupported self, unsigned char const address) -> unsigned char"""
        return _moduleconnectorwrapper.NotSupported_read_x4_spi(self, address)


    def write_x4_spi(self, address: 'unsigned char', value: 'unsigned char const') -> "int":
        """write_x4_spi(NotSupported self, unsigned char address, unsigned char const value) -> int"""
        return _moduleconnectorwrapper.NotSupported_write_x4_spi(self, address, value)


    def set_x4_fps(self, fps: 'uint32_t const') -> "int":
        """set_x4_fps(NotSupported self, uint32_t const fps) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_fps(self, fps)


    def subscribe_to_x4_desim(self, name: 'std::string const &') -> "int":
        """subscribe_to_x4_desim(NotSupported self, std::string const & name) -> int"""
        return _moduleconnectorwrapper.NotSupported_subscribe_to_x4_desim(self, name)


    def get_x4_decim_frame(self, name: 'std::string const &', frame_counter: 'uint32_t *', frame_data: 'double *', max_length: 'unsigned int') -> "int":
        """get_x4_decim_frame(NotSupported self, std::string const & name, uint32_t * frame_counter, double * frame_data, unsigned int max_length) -> int"""
        return _moduleconnectorwrapper.NotSupported_get_x4_decim_frame(self, name, frame_counter, frame_data, max_length)


    def subscribe_to_data_float(self, *args) -> "int":
        """
        subscribe_to_data_float(NotSupported self, std::string const & name) -> int
        subscribe_to_data_float(NotSupported self, std::string const & name, std::function< bool (Bytes) > callback) -> int
        """
        return _moduleconnectorwrapper.NotSupported_subscribe_to_data_float(self, *args)


    def peek_message_data_float(self, name: 'std::string const &') -> "int":
        """peek_message_data_float(NotSupported self, std::string const & name) -> int"""
        return _moduleconnectorwrapper.NotSupported_peek_message_data_float(self, name)


    def read_message_data_float(self, data_float: 'DataFloat') -> "int":
        """read_message_data_float(NotSupported self, DataFloat data_float) -> int"""
        return _moduleconnectorwrapper.NotSupported_read_message_data_float(self, data_float)


    def peek_message_pulsedoppler_float(self) -> "int":
        """peek_message_pulsedoppler_float(NotSupported self) -> int"""
        return _moduleconnectorwrapper.NotSupported_peek_message_pulsedoppler_float(self)


    def read_message_pulsedoppler_float(self) -> "Bytes":
        """read_message_pulsedoppler_float(NotSupported self) -> ucVector"""
        return _moduleconnectorwrapper.NotSupported_read_message_pulsedoppler_float(self)


    def peek_message_noisemap_float(self) -> "int":
        """peek_message_noisemap_float(NotSupported self) -> int"""
        return _moduleconnectorwrapper.NotSupported_peek_message_noisemap_float(self)


    def read_message_noisemap_float(self) -> "Bytes":
        """read_message_noisemap_float(NotSupported self) -> ucVector"""
        return _moduleconnectorwrapper.NotSupported_read_message_noisemap_float(self)


    def peek_message_pulsedoppler_byte(self) -> "int":
        """peek_message_pulsedoppler_byte(NotSupported self) -> int"""
        return _moduleconnectorwrapper.NotSupported_peek_message_pulsedoppler_byte(self)


    def read_message_pulsedoppler_byte(self) -> "Bytes":
        """read_message_pulsedoppler_byte(NotSupported self) -> ucVector"""
        return _moduleconnectorwrapper.NotSupported_read_message_pulsedoppler_byte(self)


    def peek_message_noisemap_byte(self) -> "int":
        """peek_message_noisemap_byte(NotSupported self) -> int"""
        return _moduleconnectorwrapper.NotSupported_peek_message_noisemap_byte(self)


    def read_message_noisemap_byte(self) -> "Bytes":
        """read_message_noisemap_byte(NotSupported self) -> ucVector"""
        return _moduleconnectorwrapper.NotSupported_read_message_noisemap_byte(self)


    def get_application_user_zone(self, start: 'float *', end: 'float *') -> "int":
        """get_application_user_zone(NotSupported self, float * start, float * end) -> int"""
        return _moduleconnectorwrapper.NotSupported_get_application_user_zone(self, start, end)


    def set_application_user_zone(self, start: 'float', end: 'float') -> "int":
        """set_application_user_zone(NotSupported self, float start, float end) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_application_user_zone(self, start, end)


    def get_number_of_packets(self, name: 'std::string const &') -> "unsigned int":
        """get_number_of_packets(NotSupported self, std::string const & name) -> unsigned int"""
        return _moduleconnectorwrapper.NotSupported_get_number_of_packets(self, name)


    def get_packet(self, name: 'std::string const &') -> "Bytes":
        """get_packet(NotSupported self, std::string const & name) -> ucVector"""
        return _moduleconnectorwrapper.NotSupported_get_packet(self, name)


    def clear(self, name: 'std::string const &') -> "void":
        """clear(NotSupported self, std::string const & name)"""
        return _moduleconnectorwrapper.NotSupported_clear(self, name)


    def set_parameter_file(self, filename: 'std::string const &', data: 'std::string const &') -> "void":
        """set_parameter_file(NotSupported self, std::string const & filename, std::string const & data)"""
        return _moduleconnectorwrapper.NotSupported_set_parameter_file(self, filename, data)


    def get_parameter_file(self, filename: 'std::string const &') -> "std::string":
        """get_parameter_file(NotSupported self, std::string const & filename) -> std::string"""
        return _moduleconnectorwrapper.NotSupported_get_parameter_file(self, filename)


    def load_profile(self, profile_id: 'uint32_t const') -> "void":
        """load_profile(NotSupported self, uint32_t const profile_id)"""
        return _moduleconnectorwrapper.NotSupported_load_profile(self, profile_id)


    def subscribe_to_trace(self, name: 'std::string const &') -> "int":
        """subscribe_to_trace(NotSupported self, std::string const & name) -> int"""
        return _moduleconnectorwrapper.NotSupported_subscribe_to_trace(self, name)


    def get_trace(self, name: 'std::string const &') -> "std::string":
        """get_trace(NotSupported self, std::string const & name) -> std::string"""
        return _moduleconnectorwrapper.NotSupported_get_trace(self, name)


    def subscribe_to_data_byte(self, *args) -> "int":
        """
        subscribe_to_data_byte(NotSupported self, std::string const & name) -> int
        subscribe_to_data_byte(NotSupported self, std::string const & name, std::function< bool (Bytes) > callback) -> int
        """
        return _moduleconnectorwrapper.NotSupported_subscribe_to_data_byte(self, *args)

NotSupported_swigregister = _moduleconnectorwrapper.NotSupported_swigregister
NotSupported_swigregister(NotSupported)

class Transport(_object):
    """Proxy of C++ XeThru::Transport class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Transport, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Transport, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface: 'LockedRadarInterfacePtr &'):
        """__init__(XeThru::Transport self, LockedRadarInterfacePtr & radar_interface) -> Transport"""
        this = _moduleconnectorwrapper.new_Transport(radar_interface)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_Transport
    __del__ = lambda self: None

    def send_command(self, command: 'ucVector') -> "int":
        """send_command(Transport self, ucVector command) -> int"""
        return _moduleconnectorwrapper.Transport_send_command(self, command)


    def send_command_single(self, command: 'ucVector', comparator: 'ucVector') -> "Bytes":
        """send_command_single(Transport self, ucVector command, ucVector comparator) -> ucVector"""
        return _moduleconnectorwrapper.Transport_send_command_single(self, command, comparator)


    def send_command_multi(self, command: 'ucVector', comparator: 'vVector') -> "Bytes":
        """send_command_multi(Transport self, ucVector command, vVector comparator) -> ucVector"""
        return _moduleconnectorwrapper.Transport_send_command_multi(self, command, comparator)


    def unsubscribe(self, name: 'std::string const &') -> "void":
        """unsubscribe(Transport self, std::string const & name)"""
        return _moduleconnectorwrapper.Transport_unsubscribe(self, name)


    def get_packet(self, name: 'std::string const &') -> "Bytes":
        """get_packet(Transport self, std::string const & name) -> ucVector"""
        return _moduleconnectorwrapper.Transport_get_packet(self, name)


    def get_number_of_packets(self, name: 'std::string const &') -> "unsigned int":
        """get_number_of_packets(Transport self, std::string const & name) -> unsigned int"""
        return _moduleconnectorwrapper.Transport_get_number_of_packets(self, name)


    def clear(self, name: 'std::string const &') -> "void":
        """clear(Transport self, std::string const & name)"""
        return _moduleconnectorwrapper.Transport_clear(self, name)


    def subscribe(self, *args) -> "int":
        """
        subscribe(Transport self, std::string const & name, ucVector comparator) -> int
        subscribe(Transport self, std::string const & name, ucVector comparator, std::function< bool (Bytes) > callback) -> int
        subscribe(Transport self, std::string const & name, ucVector cmp, PyObject * callback) -> int
        """
        return _moduleconnectorwrapper.Transport_subscribe(self, *args)

Transport_swigregister = _moduleconnectorwrapper.Transport_swigregister
Transport_swigregister(Transport)

class X2(_object):
    """Proxy of C++ XeThru::X2 class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, X2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, X2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _moduleconnectorwrapper.delete_X2
    __del__ = lambda self: None

    def set_debug_level(self, level: 'unsigned char') -> "void":
        """set_debug_level(X2 self, unsigned char level)"""
        return _moduleconnectorwrapper.X2_set_debug_level(self, level)


    def ping(self) -> "unsigned int":
        """ping(X2 self) -> unsigned int"""
        return _moduleconnectorwrapper.X2_ping(self)


    def get_system_info(self, info_code: 'unsigned char') -> "std::string":
        """get_system_info(X2 self, unsigned char info_code) -> std::string"""
        return _moduleconnectorwrapper.X2_get_system_info(self, info_code)


    def set_X2_float(self, id: 'uint32_t', value: 'float') -> "int":
        """set_X2_float(X2 self, uint32_t id, float value) -> int"""
        return _moduleconnectorwrapper.X2_set_X2_float(self, id, value)


    def get_x2_float(self, id: 'uint32_t') -> "float":
        """get_x2_float(X2 self, uint32_t id) -> float"""
        return _moduleconnectorwrapper.X2_get_x2_float(self, id)


    def set_X2_int(self, id: 'uint32_t', value: 'uint32_t') -> "int":
        """set_X2_int(X2 self, uint32_t id, uint32_t value) -> int"""
        return _moduleconnectorwrapper.X2_set_X2_int(self, id, value)


    def get_x2_int(self, id: 'uint32_t') -> "uint32_t":
        """get_x2_int(X2 self, uint32_t id) -> uint32_t"""
        return _moduleconnectorwrapper.X2_get_x2_int(self, id)


    def set_X2_register(self, id: 'uint32_t', value: 'uint32_t') -> "int":
        """set_X2_register(X2 self, uint32_t id, uint32_t value) -> int"""
        return _moduleconnectorwrapper.X2_set_X2_register(self, id, value)


    def get_x2_register(self, register_id: 'uint32_t') -> "uint32_t":
        """get_x2_register(X2 self, uint32_t register_id) -> uint32_t"""
        return _moduleconnectorwrapper.X2_get_x2_register(self, register_id)


    def run_timing_measurement(self) -> "int":
        """run_timing_measurement(X2 self) -> int"""
        return _moduleconnectorwrapper.X2_run_timing_measurement(self)


    def set_fps(self, fps: 'unsigned int') -> "int":
        """set_fps(X2 self, unsigned int fps) -> int"""
        return _moduleconnectorwrapper.X2_set_fps(self, fps)


    def capture_single_normalized_frame(self) -> "XeThru::RawNormalizedData":
        """capture_single_normalized_frame(X2 self) -> RawNormalizedData"""
        return _moduleconnectorwrapper.X2_capture_single_normalized_frame(self)


    def set_sensor_mode(self, mode: 'unsigned char') -> "void":
        """set_sensor_mode(X2 self, unsigned char mode)"""
        return _moduleconnectorwrapper.X2_set_sensor_mode(self, mode)


    def set_sensor_mode_and_submode(self, mode: 'unsigned char const', submode: 'unsigned char const') -> "void":
        """set_sensor_mode_and_submode(X2 self, unsigned char const mode, unsigned char const submode)"""
        return _moduleconnectorwrapper.X2_set_sensor_mode_and_submode(self, mode, submode)


    def subscribe_to_raw_normalized(self, *args) -> "int":
        """
        subscribe_to_raw_normalized(X2 self, std::string const & name) -> int
        subscribe_to_raw_normalized(X2 self, std::string const & name, std::function< bool (Bytes) > callback) -> int
        """
        return _moduleconnectorwrapper.X2_subscribe_to_raw_normalized(self, *args)


    def get_raw_normalized_frame(self, name: 'std::string const &') -> "XeThru::RawNormalizedData":
        """get_raw_normalized_frame(X2 self, std::string const & name) -> RawNormalizedData"""
        return _moduleconnectorwrapper.X2_get_raw_normalized_frame(self, name)


    def unsubscribe(self, name: 'std::string const &') -> "void":
        """unsubscribe(X2 self, std::string const & name)"""
        return _moduleconnectorwrapper.X2_unsubscribe(self, name)


    def get_number_of_packets(self, name: 'std::string const &') -> "unsigned int":
        """get_number_of_packets(X2 self, std::string const & name) -> unsigned int"""
        return _moduleconnectorwrapper.X2_get_number_of_packets(self, name)


    def clear(self, name: 'std::string const &') -> "void":
        """clear(X2 self, std::string const & name)"""
        return _moduleconnectorwrapper.X2_clear(self, name)


    def system_run_test(self, test_code: 'unsigned char') -> "int":
        """system_run_test(X2 self, unsigned char test_code) -> int"""
        return _moduleconnectorwrapper.X2_system_run_test(self, test_code)

X2_swigregister = _moduleconnectorwrapper.X2_swigregister
X2_swigregister(X2)

class PyX2M200(_object):
    """


    Interface to the Xethru X2M200 Application module.  

    C++ includes: PyX2M200.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyX2M200, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyX2M200, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface: 'LockedRadarInterfacePtr &'):
        """
        __init__(XeThru::PyX2M200 self, LockedRadarInterfacePtr & radar_interface) -> PyX2M200



        Constructor.  

        Initialized by PythonModuleConnector::get_x2m200  

        Parameters
        ----------
        * `radar_interface` :  
            a reference to the internal radar interface  

        """
        this = _moduleconnectorwrapper.new_PyX2M200(radar_interface)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyX2M200
    __del__ = lambda self: None

    def set_debug_level(self, level: 'unsigned char') -> "void":
        """
        set_debug_level(PyX2M200 self, unsigned char level)



        Set debug level on the Xethru module.  

        Parameters
        ----------
        * `level` :  
            New debug level. Legal range [0-9].  

        """
        return _moduleconnectorwrapper.PyX2M200_set_debug_level(self, level)


    def set_log_level(self, level: 'unsigned int') -> "void":
        """
        set_log_level(PyX2M200 self, unsigned int level)



        Set log level of ModuleConnector.  

        Parameters
        ----------
        * `level` :  
            New debug level. Legal range [0-9].  

        Returns
        -------
        status (0==OK)  

        """
        return _moduleconnectorwrapper.PyX2M200_set_log_level(self, level)


    def ping(self) -> "unsigned int":
        """
        ping(PyX2M200 self) -> unsigned int



        Send a ping message to the module.  

        This command is typically used to verify connectivity to the module.  

        Returns
        -------
        The response.  

        """
        return _moduleconnectorwrapper.PyX2M200_ping(self)


    def get_item_number(self) -> "std::string":
        """
        get_item_number(PyX2M200 self) -> std::string



        Get the Novelda PCBA Item Number, including revision.  

        Returns
        -------
        PCBA item number and revision.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_item_number(self)


    def get_order_code(self) -> "std::string":
        """
        get_order_code(PyX2M200 self) -> std::string



        Get Novelda PCBA Order Code.  

        Returns
        -------
        PCBA order code.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_order_code(self)


    def get_firmware_id(self) -> "std::string":
        """
        get_firmware_id(PyX2M200 self) -> std::string



        Get the installed Firmware ID.  

        Returns
        -------
        Firmware ID.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_firmware_id(self)


    def get_firmware_version(self) -> "std::string":
        """
        get_firmware_version(PyX2M200 self) -> std::string



        Get the installed Firmware version.  

        Returns
        -------
        Firmware version.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_firmware_version(self)


    def get_serial_number(self) -> "std::string":
        """
        get_serial_number(PyX2M200 self) -> std::string



        Get the module serial number.  

        The serial number is unique for each module.  

        Returns
        -------
        Unique module serial number.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_serial_number(self)


    def get_build_info(self) -> "std::string":
        """
        get_build_info(PyX2M200 self) -> std::string



        Get information of the SW build installed on the device.  

        Returns
        -------
        Build info description.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_build_info(self)


    def get_app_id_list(self) -> "std::string":
        """
        get_app_id_list(PyX2M200 self) -> std::string



        Get a list of supported profiles.  

        Returns
        -------
        A list of supported profiles as a string.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_app_id_list(self)


    def reset(self) -> "void":
        """
        reset(PyX2M200 self)



        Reset the module.  

        This method sends a reset command to the Xethru module. The module will try to
        reset and come back up again.  

        During this call the ModuleConnector will try multiple times to reconnect with
        the rebooted module.  

        """
        return _moduleconnectorwrapper.PyX2M200_reset(self)


    def start_bootloader(self) -> "void":
        """
        start_bootloader(PyX2M200 self)



        Start the bootloader for FW upgrades.  

        All the Xethru modules have a bootloader. This method instructs the Xethru
        module to reboot into bootloader mode.  

        """
        return _moduleconnectorwrapper.PyX2M200_start_bootloader(self)


    def set_sensor_mode_run(self) -> "void":
        """
        set_sensor_mode_run(PyX2M200 self)



        Set the sensor in run mode.  

        In run mode the sensor will send a stream of data back to the host. The data in
        the data stream depends on the current configuration.  

        """
        return _moduleconnectorwrapper.PyX2M200_set_sensor_mode_run(self)


    def set_sensor_mode_idle(self) -> "void":
        """
        set_sensor_mode_idle(PyX2M200 self)



        Set the sensor in idle mode.  

        The sensor will stop sending data. The sensor can be put back in run mode with
        the set_sensor_mode_run().  

        """
        return _moduleconnectorwrapper.PyX2M200_set_sensor_mode_idle(self)


    def load_sleep_profile(self) -> "void":
        """
        load_sleep_profile(PyX2M200 self)



        Load the sleep profile.  

        A profile is a preset configuration that makes the module behave in a certain
        way. The module will not start sending data until a set_sensor_mode_run command
        is executed.  

        """
        return _moduleconnectorwrapper.PyX2M200_load_sleep_profile(self)


    def load_respiration_profile(self) -> "void":
        """
        load_respiration_profile(PyX2M200 self)



        Load the respiration profile.  

        A profile is a preset configuration that makes the module behave in a certain
        way. The module will not start sending data until a set_sensor_mode_run command
        is executed.  

        """
        return _moduleconnectorwrapper.PyX2M200_load_respiration_profile(self)


    def enable_baseband_ap(self) -> "void":
        """
        enable_baseband_ap(PyX2M200 self)



        Enable amplitude/phase baseband output.  

        For all supported profiles it is possible to turn on Amplitude Phase baseband
        output.  

        """
        return _moduleconnectorwrapper.PyX2M200_enable_baseband_ap(self)


    def disable_baseband_ap(self) -> "void":
        """
        disable_baseband_ap(PyX2M200 self)



        Disables amplitude/phase baseband output.  

        """
        return _moduleconnectorwrapper.PyX2M200_disable_baseband_ap(self)


    def enable_baseband_iq(self) -> "void":
        """
        enable_baseband_iq(PyX2M200 self)



        Enable I/Q baseband output.  

        For all supported profiles it is possible to turn on IQ baseband output.  

        """
        return _moduleconnectorwrapper.PyX2M200_enable_baseband_iq(self)


    def disable_baseband_iq(self) -> "void":
        """
        disable_baseband_iq(PyX2M200 self)



        Disables I/Q baseband output.  

        """
        return _moduleconnectorwrapper.PyX2M200_disable_baseband_iq(self)


    def set_detection_zone(self, start: 'float', end: 'float') -> "void":
        """
        set_detection_zone(PyX2M200 self, float start, float end)



        Set the desired detection zone.  

        The sensor will detect movements within this area.  

        Parameters
        ----------
        * `start` :  
            Start of detection zone in meters from the radar  
        * `end` :  
            End of detection zone in meters from the radar  

        """
        return _moduleconnectorwrapper.PyX2M200_set_detection_zone(self, start, end)


    def set_sensitivity(self, new_sensitivity: 'uint32_t') -> "void":
        """
        set_sensitivity(PyX2M200 self, uint32_t new_sensitivity)



        Set module sensitivity.  

        Parameters
        ----------
        * `new_sensitivity` :  
            Sensitivity level from 0 (low) to 9 (high)  

        """
        return _moduleconnectorwrapper.PyX2M200_set_sensitivity(self, new_sensitivity)


    def set_led_control(self, mode: 'uint8_t', intensity: 'uint8_t') -> "void":
        """
        set_led_control(PyX2M200 self, uint8_t mode, uint8_t intensity)



        Configures the module LED mode.  

        The setting survives a power cycle.  

        Parameters
        ----------
        * `mode` :  
            0: Off, 1: Simple, 2: Full (default)  
        * `intensity` :  
            intensity of the led  

        """
        return _moduleconnectorwrapper.PyX2M200_set_led_control(self, mode, intensity)


    def subscribe_to_resp_status(self, name: 'std::string const &') -> "int":
        """
        subscribe_to_resp_status(PyX2M200 self, std::string const & name) -> int



        Adds a subscription for respiration data packets.  

        Creates a queue/buffer for incoming respiration packet stream. The queue must be
        given a name.  

        Parameters
        ----------
        * `name` :  
            Name of the buffer  

        """
        return _moduleconnectorwrapper.PyX2M200_subscribe_to_resp_status(self, name)


    def subscribe_to_sleep_status(self, name: 'std::string const &') -> "int":
        """
        subscribe_to_sleep_status(PyX2M200 self, std::string const & name) -> int



        Adds a subscription for sleep status data packets.  

        Creates a queue/buffer for incoming sleep packet stream. The queue must be given
        a name.  

        Parameters
        ----------
        * `name` :  
            Name of the queue/buffer  

        """
        return _moduleconnectorwrapper.PyX2M200_subscribe_to_sleep_status(self, name)


    def subscribe_to_baseband_ap(self, name: 'std::string const &') -> "int":
        """
        subscribe_to_baseband_ap(PyX2M200 self, std::string const & name) -> int



        Adds a subscription for amplitude phase baseband data packets.  

        Creates a queue/buffer for incoming amplitude phase baseband packet stream. The
        queue must be given a name.  

        Parameters
        ----------
        * `name` :  
            Name of the queue/buffer  

        """
        return _moduleconnectorwrapper.PyX2M200_subscribe_to_baseband_ap(self, name)


    def subscribe_to_baseband_iq(self, name: 'std::string const &') -> "int":
        """
        subscribe_to_baseband_iq(PyX2M200 self, std::string const & name) -> int



        Adds a subscription for IQ baseband data packets.  

        Creates a queue/buffer for incoming IQ baseband packet stream. The queue must be
        given a name.  

        Parameters
        ----------
        * `name` :  
            Name of the buffer/queue  

        """
        return _moduleconnectorwrapper.PyX2M200_subscribe_to_baseband_iq(self, name)


    def unsubscribe(self, name: 'std::string const &') -> "void":
        """
        unsubscribe(PyX2M200 self, std::string const & name)



        Turns off a named subscription.  

        Parameters
        ----------
        * `name` :  
            Name of the subscription to disable  

        """
        return _moduleconnectorwrapper.PyX2M200_unsubscribe(self, name)


    def disable_resp_output(self) -> "void":
        """
        disable_resp_output(PyX2M200 self)



        Turn off respiration status output from the Xethru X2M200 module.  

        """
        return _moduleconnectorwrapper.PyX2M200_disable_resp_output(self)


    def enable_resp_output(self) -> "void":
        """
        enable_resp_output(PyX2M200 self)



        Turn on respiration status output from the Xethru X2M200 module.  

        """
        return _moduleconnectorwrapper.PyX2M200_enable_resp_output(self)


    def get_number_of_packets(self, name: 'std::string const &') -> "unsigned int":
        """
        get_number_of_packets(PyX2M200 self, std::string const & name) -> unsigned int



        Get number of packets in a named subscription queue/buffer.  

        Parameters
        ----------
        * `name` :  
            Name of the subscription  

        """
        return _moduleconnectorwrapper.PyX2M200_get_number_of_packets(self, name)


    def get_packet(self, name: 'std::string const &') -> "Bytes":
        """
        get_packet(PyX2M200 self, std::string const & name) -> ucVector



        Get one packets of data.  

        Parameters
        ----------
        * `name` :  
            name of subscription given when during the subscribe.  

        Returns
        -------
        packet: the packet data as a vector of bytes.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_packet(self, name)


    def get_respiration_data(self, name: 'std::string const') -> "XeThru::RespirationData":
        """
        get_respiration_data(PyX2M200 self, std::string const name) -> RespirationData



        Get one respiration data message from subscription queue.  

        Parameters
        ----------
        * `name` :  
            Name of subscription  

        Returns
        -------
        A data object holding the resulting respiration data.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_respiration_data(self, name)


    def get_sleep_data(self, name: 'std::string const') -> "XeThru::SleepData":
        """
        get_sleep_data(PyX2M200 self, std::string const name) -> SleepData



        Get one sleep data message from subscription queue.  

        Parameters
        ----------
        * `name` :  
            Name of subscription  

        Returns
        -------
        A data object holding the resulting sleep data.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_sleep_data(self, name)


    def get_baseband_ap_data(self, name: 'std::string const') -> "XeThru::BasebandApData":
        """
        get_baseband_ap_data(PyX2M200 self, std::string const name) -> BasebandApData



        Get one baseband data message from subscription queue.  

        Parameters
        ----------
        * `name` :  
            Name of subscription  

        Returns
        -------
        A data object holding the resulting amplitude/phase baseband data.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_baseband_ap_data(self, name)


    def get_baseband_iq_data(self, name: 'std::string const') -> "XeThru::BasebandIqData":
        """
        get_baseband_iq_data(PyX2M200 self, std::string const name) -> BasebandIqData



        Get one baseband data message from subscription queue.  

        Parameters
        ----------
        * `name` :  
            Name of subscription  

        Returns
        -------
        A data object holding the resulting I/Q baseband data.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_baseband_iq_data(self, name)


    def clear(self, name: 'std::string const &') -> "void":
        """
        clear(PyX2M200 self, std::string const & name)



        Empty the buffer of the named data stream subscription.  

        Parameters
        ----------
        * `name` :  
            Name of subscription  

        """
        return _moduleconnectorwrapper.PyX2M200_clear(self, name)

PyX2M200_swigregister = _moduleconnectorwrapper.PyX2M200_swigregister
PyX2M200_swigregister(PyX2M200)

class PyXEP(_object):
    """


    C++ includes: PyXEP.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyXEP, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyXEP, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface: 'LockedRadarInterfacePtr &'):
        """
        __init__(XeThru::PyXEP self, LockedRadarInterfacePtr & radar_interface) -> PyXEP



        Constructor.  

        Initialized by PythonModuleConnector::get_xep  

        Parameters
        ----------
        * `radar_interface` :  
            a reference to the internal radar interface  

        """
        this = _moduleconnectorwrapper.new_PyXEP(radar_interface)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyXEP
    __del__ = lambda self: None

    def set_baudrate(self, baudrate: 'uint32_t') -> "void":
        """
        set_baudrate(PyXEP self, uint32_t baudrate)



        Sets the baudrate to use for serial communication during ModuleConnector
        operation.  

        Parameters
        ----------
        * `baudrate` :  
            enum representing the baudrate, defined in xtid.h  

        """
        return _moduleconnectorwrapper.PyXEP_set_baudrate(self, baudrate)


    def module_reset(self) -> "void":
        """
        module_reset(PyXEP self)



        Resets the module.  

        """
        return _moduleconnectorwrapper.PyXEP_module_reset(self)


    def get_system_info(self, info_code: 'uint8_t') -> "std::string":
        """
        get_system_info(PyXEP self, uint8_t info_code) -> std::string



        Parameters
        ----------
        * `info_code` :  
            Specifies the info code.  

        Returns
        -------
        a string containing system information given by infocode: XTS_SSIC_FIRMWAREID =
        0x02 -> Returns the installed Firmware ID, "XEP" XTS_SSIC_VERSION = 0x03 ->
        Returns the installed Firmware Version. As viewed from the "highest" level of
        the software. XTS_SSIC_BUILD = 0x04 -> Returns information of the SW Build
        installed on the device XTS_SSIC_VERSIONLIST = 0x07 -> Returns ID and version of
        all components. Calls all components and compound a string. E.g.
        "XEP:2.3.4.5;X4C51:1.0.0.0"  

        """
        return _moduleconnectorwrapper.PyXEP_get_system_info(self, info_code)


    def ping(self) -> "uint32_t":
        """
        ping(PyXEP self) -> uint32_t



        Send ping to module in order to validate that connection both ways is OK.  

        Returns
        -------
        the pong value  

        """
        return _moduleconnectorwrapper.PyXEP_ping(self)


    def set_normalization(self, normalization: 'uint8_t') -> "void":
        """
        set_normalization(PyXEP self, uint8_t normalization)



        """
        return _moduleconnectorwrapper.PyXEP_set_normalization(self, normalization)


    def get_normalization(self) -> "uint8_t":
        """
        get_normalization(PyXEP self) -> uint8_t



        """
        return _moduleconnectorwrapper.PyXEP_get_normalization(self)


    def set_phase_noise_correction(self, enable: 'uint8_t', correction_distance: 'float') -> "void":
        """
        set_phase_noise_correction(PyXEP self, uint8_t enable, float correction_distance)



        """
        return _moduleconnectorwrapper.PyXEP_set_phase_noise_correction(self, enable, correction_distance)


    def get_phase_noise_correction(self) -> "float":
        """
        get_phase_noise_correction(PyXEP self) -> float



        """
        return _moduleconnectorwrapper.PyXEP_get_phase_noise_correction(self)


    def set_decimation_factor(self, decimation_factor: 'uint32_t') -> "void":
        """
        set_decimation_factor(PyXEP self, uint32_t decimation_factor)



        """
        return _moduleconnectorwrapper.PyXEP_set_decimation_factor(self, decimation_factor)


    def get_decimation_factor(self) -> "uint32_t":
        """
        get_decimation_factor(PyXEP self) -> uint32_t



        """
        return _moduleconnectorwrapper.PyXEP_get_decimation_factor(self)


    def set_number_format(self, number_format: 'uint8_t') -> "void":
        """
        set_number_format(PyXEP self, uint8_t number_format)



        """
        return _moduleconnectorwrapper.PyXEP_set_number_format(self, number_format)


    def get_number_format(self) -> "uint8_t":
        """
        get_number_format(PyXEP self) -> uint8_t



        """
        return _moduleconnectorwrapper.PyXEP_get_number_format(self)


    def set_legacy_output(self, legacy_output: 'uint8_t') -> "void":
        """
        set_legacy_output(PyXEP self, uint8_t legacy_output)



        """
        return _moduleconnectorwrapper.PyXEP_set_legacy_output(self, legacy_output)


    def get_legacy_output(self) -> "uint8_t":
        """
        get_legacy_output(PyXEP self) -> uint8_t



        """
        return _moduleconnectorwrapper.PyXEP_get_legacy_output(self)


    def x4driver_set_fps(self, fps: 'float') -> "void":
        """
        x4driver_set_fps(PyXEP self, float fps)



        Sets frame rate for frame streaming.  

        Parameters
        ----------
        * `fps` :  
            Specifies the fps  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_fps(self, fps)


    def x4driver_get_fps(self) -> "float":
        """
        x4driver_get_fps(PyXEP self) -> float



        Returns
        -------
        the configured FPS  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_fps(self)


    def x4driver_set_enable(self, value: 'uint8_t') -> "void":
        """
        x4driver_set_enable(PyXEP self, uint8_t value)



        Set enable for X4 enable pin.  

        Parameters
        ----------
        * `value` :  
            Specifies the value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_enable(self, value)


    def x4driver_init(self) -> "void":
        """
        x4driver_init(PyXEP self)



        Ensures that enable is set, 8051 SRAM is programmed, ldos are enabled, and that
        the external oscillator has been enabled.  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_init(self)


    def x4driver_set_iterations(self, iterations: 'uint32_t') -> "void":
        """
        x4driver_set_iterations(PyXEP self, uint32_t iterations)



        Sets Iterations.  

        Parameters
        ----------
        * `iterations` :  
            specifies the iterations value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_iterations(self, iterations)


    def x4driver_get_iterations(self) -> "uint32_t":
        """
        x4driver_get_iterations(PyXEP self) -> uint32_t



        Gets Iterations.  

        Returns
        -------
        Iterations value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_iterations(self)


    def x4driver_set_pulses_per_step(self, pps: 'uint32_t') -> "void":
        """
        x4driver_set_pulses_per_step(PyXEP self, uint32_t pps)



        Sets pulses per step.  

        Parameters
        ----------
        * `pps` :  
            Specifies the pulses per step value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_pulses_per_step(self, pps)


    def x4driver_get_pulses_per_step(self) -> "uint32_t":
        """
        x4driver_get_pulses_per_step(PyXEP self) -> uint32_t



        Gets pulses per step.  

        Returns
        -------
        Pulses per step value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_pulses_per_step(self)


    def x4driver_set_dac_min(self, dac_min: 'uint32_t') -> "void":
        """
        x4driver_set_dac_min(PyXEP self, uint32_t dac_min)



        Sets dac min.  

        Parameters
        ----------
        * `dac_min` :  
            Specifies the dac min value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_dac_min(self, dac_min)


    def x4driver_get_dac_min(self) -> "uint32_t":
        """
        x4driver_get_dac_min(PyXEP self) -> uint32_t



        Gets dac min.  

        Returns
        -------
        Dac min value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_dac_min(self)


    def x4driver_set_dac_max(self, dac_max: 'uint32_t') -> "void":
        """
        x4driver_set_dac_max(PyXEP self, uint32_t dac_max)



        Sets dac max.  

        Parameters
        ----------
        * `dac_max` :  
            Specifies the dac max value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_dac_max(self, dac_max)


    def x4driver_get_dac_max(self) -> "uint32_t":
        """
        x4driver_get_dac_max(PyXEP self) -> uint32_t



        Gets dac max.  

        Returns
        -------
        Dac max value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_dac_max(self)


    def x4driver_set_tx_power(self, tx_power: 'uint8_t') -> "void":
        """
        x4driver_set_tx_power(PyXEP self, uint8_t tx_power)



        Set the radar transmitter power.  

        0 = transmitter off. See datasheet for valid values.  

        Parameters
        ----------
        * `tx_power` :  
            Specifies the transmitter power  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_tx_power(self, tx_power)


    def x4driver_get_tx_power(self) -> "uint8_t":
        """
        x4driver_get_tx_power(PyXEP self) -> uint8_t



        Get the radar transmitter power.  

        0 = transmitter off. See datasheet for valid values.  

        Returns
        -------
        tx_power Specifies the transmitter power  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_tx_power(self)


    def x4driver_set_downconversion(self, enable: 'uint8_t') -> "void":
        """
        x4driver_set_downconversion(PyXEP self, uint8_t enable)



        Sets downconversion.  

        Parameters
        ----------
        * `enable` :  
            Specifies downconversion, 0=no downconversion, i.e. rf data.
            1=downconversion.  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_downconversion(self, enable)


    def x4driver_get_downconversion(self) -> "uint8_t":
        """
        x4driver_get_downconversion(PyXEP self) -> uint8_t



        Gets downconversion.  

        Returns
        -------
        Downconversion, 0=no downconversion, i.e. rf data. 1=downconversion.  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_downconversion(self)


    def x4driver_get_frame_bin_count(self) -> "uint32_t":
        """
        x4driver_get_frame_bin_count(PyXEP self) -> uint32_t



        Gets frame bin count.  

        Returns
        -------
        frame bin count  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_frame_bin_count(self)


    def x4driver_set_frame_area(self, start: 'float', end: 'float') -> "void":
        """
        x4driver_set_frame_area(PyXEP self, float start, float end)



        Set frame area zone Assume air as transmitter medium.  

        Start and end in meter.  

        Parameters
        ----------
        * `start` :  
            Specifies the start  
        * `end` :  
            Specifies the end  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_frame_area(self, start, end)


    def x4driver_get_frame_area(self) -> "XeThru::FrameArea":
        """
        x4driver_get_frame_area(PyXEP self) -> FrameArea



        Get frame area zone.  

        Returns
        -------
        FrameArea  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_frame_area(self)


    def x4driver_set_frame_area_offset(self, offset: 'float') -> "void":
        """
        x4driver_set_frame_area_offset(PyXEP self, float offset)



        Offset to adjust frame area reference depending on module product.  

        Parameters
        ----------
        * `offset` :  
            Specifies the offset  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_frame_area_offset(self, offset)


    def x4driver_get_frame_area_offset(self) -> "float":
        """
        x4driver_get_frame_area_offset(PyXEP self) -> float



        Offset to adjust frame area reference depending on module product.  

        Returns
        -------
        the frame area offset  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_frame_area_offset(self)


    def x4driver_set_tx_center_frequency(self, tx_frequency: 'uint8_t') -> "void":
        """
        x4driver_set_tx_center_frequency(PyXEP self, uint8_t tx_frequency)



        Set radar TX center frequency.  

        Parameters
        ----------
        * `tx_frequency` :  
            Specifies the frequency  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_tx_center_frequency(self, tx_frequency)


    def x4driver_get_tx_center_frequency(self) -> "uint8_t":
        """
        x4driver_get_tx_center_frequency(PyXEP self) -> uint8_t



        Get radar TX center frequency.  

        Returns
        -------
        Center frequency  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_tx_center_frequency(self)


    def x4driver_set_spi_register(self, address: 'uint8_t', value: 'uint8_t') -> "void":
        """
        x4driver_set_spi_register(PyXEP self, uint8_t address, uint8_t value)



        Set spi register on radar chip.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `value` :  
            Specifies the value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_spi_register(self, address, value)


    def x4driver_get_spi_register(self, address: 'uint8_t') -> "uint8_t":
        """
        x4driver_get_spi_register(PyXEP self, uint8_t address) -> uint8_t



        Parameters
        ----------
        * `address` :  
            Specifies the address  

        Returns
        -------
        the SPI register at the specified address  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_spi_register(self, address)


    def x4driver_write_to_spi_register(self, address: 'uint8_t', values: 'ucVector') -> "void":
        """
        x4driver_write_to_spi_register(PyXEP self, uint8_t address, ucVector values)



        Write to a spi register on radar chip.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `values` :  
            Specifies the values  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_write_to_spi_register(self, address, values)


    def x4driver_read_from_spi_register(self, address: 'uint8_t', length: 'uint32_t const') -> "Bytes":
        """
        x4driver_read_from_spi_register(PyXEP self, uint8_t address, uint32_t const length) -> ucVector



        Read from a spi register.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `length` :  
            Specifies how many bytes to read  

        Returns
        -------
        data from the SPI register at the specified address  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_read_from_spi_register(self, address, length)


    def x4driver_write_to_i2c_register(self, address: 'uint8_t', values: 'ucVector') -> "void":
        """
        x4driver_write_to_i2c_register(PyXEP self, uint8_t address, ucVector values)



        Write to a i2c register on radar chip.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `values` :  
            Specifies the values  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_write_to_i2c_register(self, address, values)


    def x4driver_read_from_i2c_register(self, length: 'uint32_t const') -> "Bytes":
        """
        x4driver_read_from_i2c_register(PyXEP self, uint32_t const length) -> ucVector



        Read from a i2c register.  

        Parameters
        ----------
        * `length` :  
            Specifies how many bytes to read  

        Returns
        -------
        data from the SPI register at the specified address  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_read_from_i2c_register(self, length)


    def x4driver_set_pif_register(self, address: 'uint8_t', value: 'uint8_t') -> "void":
        """
        x4driver_set_pif_register(PyXEP self, uint8_t address, uint8_t value)



        Sets PIF register value.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `value` :  
            Specifies the value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_pif_register(self, address, value)


    def x4driver_get_pif_register(self, address: 'uint8_t') -> "uint8_t":
        """
        x4driver_get_pif_register(PyXEP self, uint8_t address) -> uint8_t



        Parameters
        ----------
        * `address` :  
            Specifies the address  

        Returns
        -------
        the PIF register at the specified address  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_pif_register(self, address)


    def x4driver_set_xif_register(self, address: 'uint8_t', value: 'uint8_t') -> "void":
        """
        x4driver_set_xif_register(PyXEP self, uint8_t address, uint8_t value)



        Sets XIF register value.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `value` :  
            Specifies the value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_xif_register(self, address, value)


    def x4driver_get_xif_register(self, address: 'uint8_t') -> "uint8_t":
        """
        x4driver_get_xif_register(PyXEP self, uint8_t address) -> uint8_t



        Parameters
        ----------
        * `address` :  
            Specifies the address  

        Returns
        -------
        the XIF register value at the specified address  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_xif_register(self, address)


    def x4driver_set_prf_div(self, prf_div: 'uint8_t') -> "void":
        """
        x4driver_set_prf_div(PyXEP self, uint8_t prf_div)



        Sets Pulse Repetition Frequency(PRF) divider.  

        Parameters
        ----------
        * `prf_div` :  
            Specifies the PRF  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_prf_div(self, prf_div)


    def x4driver_get_prf_div(self) -> "uint8_t":
        """
        x4driver_get_prf_div(PyXEP self) -> uint8_t



        Gets Pulse Repetition Frequency(PRF) divider.  

        Returns
        -------
        register: register value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_prf_div(self)


    def set_iopin_control(self, pin_id: 'uint32_t', pin_setup: 'uint32_t', pin_feature: 'uint32_t') -> "void":
        """
        set_iopin_control(PyXEP self, uint32_t pin_id, uint32_t pin_setup, uint32_t pin_feature)



        Enable or disable GPIO feature.  

        pin_id = 0 : all pins pin_id != 0 : designated pin pin_feature = 0 : disabled -
        pin tri-stated / input (TBD) pin_feature = 1 : default pin_feature > 1 :
        designated feature Pin setup: 0 = input 1 = output Pin feature: 0 = Disable all
        iopin features (not available, will return error) 1 = Configure according to
        datasheet default (not available, will return error) 2 = Passive - Set and get
        iopin level from host  

        """
        return _moduleconnectorwrapper.PyXEP_set_iopin_control(self, pin_id, pin_setup, pin_feature)


    def set_iopin_value(self, pin_id: 'uint32_t', pin_value: 'uint32_t') -> "void":
        """
        set_iopin_value(PyXEP self, uint32_t pin_id, uint32_t pin_value)



        If IO pin control is used to set pin_id as output, the pin level or value will
        be set to pin_value.  

        """
        return _moduleconnectorwrapper.PyXEP_set_iopin_value(self, pin_id, pin_value)


    def get_iopin_value(self, pin_id: 'uint32_t') -> "uint32_t":
        """
        get_iopin_value(PyXEP self, uint32_t pin_id) -> uint32_t



        Read IO pin level or value.  

        Returns
        -------
        value: io pin value  

        """
        return _moduleconnectorwrapper.PyXEP_get_iopin_value(self, pin_id)


    def peek_message_data_float(self) -> "int":
        """
        peek_message_data_float(PyXEP self) -> int



        Returns number of data float packets in internal queue.  

        Returns
        -------
        Returns number of data float packets in internal queue  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_data_float(self)


    def read_message_data_float(self) -> "XeThru::DataFloat":
        """
        read_message_data_float(PyXEP self) -> DataFloat



        Reads a single data float message from internal queue.  

        Returns
        -------
        the data float message  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_data_float(self)


    def peek_message_radar_rf(self) -> "int":
        """
        peek_message_radar_rf(PyXEP self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_radar_rf(self)


    def read_message_radar_rf(self) -> "XeThru::RadarRfData":
        """
        read_message_radar_rf(PyXEP self) -> RadarRfData



        Read a single RadarRfData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        RadarRfData:  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_radar_rf(self)


    def peek_message_radar_rf_normalized(self) -> "int":
        """
        peek_message_radar_rf_normalized(PyXEP self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_radar_rf_normalized(self)


    def read_message_radar_rf_normalized(self) -> "XeThru::RadarRfNormalizedData":
        """
        read_message_radar_rf_normalized(PyXEP self) -> RadarRfNormalizedData



        Read a single RadarRfNormalizedData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        RadarRfNormalizedData:  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_radar_rf_normalized(self)


    def peek_message_radar_baseband_float(self) -> "int":
        """
        peek_message_radar_baseband_float(PyXEP self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_radar_baseband_float(self)


    def read_message_radar_baseband_float(self) -> "XeThru::RadarBasebandFloatData":
        """
        read_message_radar_baseband_float(PyXEP self) -> RadarBasebandFloatData



        Read a single RadarBasebandFloatData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        RadarBasebandFloatData:  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_radar_baseband_float(self)


    def peek_message_radar_baseband_q15(self) -> "int":
        """
        peek_message_radar_baseband_q15(PyXEP self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_radar_baseband_q15(self)


    def read_message_radar_baseband_q15(self) -> "XeThru::RadarBasebandQ15Data":
        """
        read_message_radar_baseband_q15(PyXEP self) -> RadarBasebandQ15Data



        Read a single RadarBasebandQ15Data item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        RadarBasebandQ15Data:  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_radar_baseband_q15(self)


    def peek_message_data_string(self) -> "int":
        """
        peek_message_data_string(PyXEP self) -> int



        Returns number of data string packets in internal queue.  

        Returns
        -------
        the number of data string packets in internal queue.  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_data_string(self)


    def read_message_data_string(self, content_id: 'uint32_t *', info: 'uint32_t *', data: 'std::string *') -> "int":
        """
        read_message_data_string(PyXEP self, uint32_t * content_id, uint32_t * info, std::string * data) -> int



        Reads a single data string message from internal queue.  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_data_string(self, content_id, info, data)


    def peek_message_data_byte(self) -> "int":
        """
        peek_message_data_byte(PyXEP self) -> int



        Returns number of data byte packets in internal queue.  

        Returns
        -------
        the number of data byte packets in internal queue.  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_data_byte(self)


    def read_message_data_byte(self, content_id: 'uint32_t *', info: 'uint32_t *', data: 'ucVector') -> "int":
        """
        read_message_data_byte(PyXEP self, uint32_t * content_id, uint32_t * info, ucVector data) -> int



        Reads a single data byte message from internal queue.  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_data_byte(self, content_id, info, data)


    def peek_message_system(self) -> "int":
        """
        peek_message_system(PyXEP self) -> int



        Sets max number of messages to store in internal data float queue.  

        Returns
        -------
        the number of system packets in internal queue  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_system(self)


    def read_message_system(self) -> "uint32_t":
        """
        read_message_system(PyXEP self) -> uint32_t



        Reads a single data system message from internal queue.  

        Returns
        -------
        system package  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_system(self)


    def search_for_file_by_type(self, type: 'uint32_t') -> "std::vector< int32_t,std::allocator< int32_t > >":
        """
        search_for_file_by_type(PyXEP self, uint32_t type) -> iVector



        Searches for and returns a list of identifiers for all files of the specified
        type.  

        Parameters
        ----------
        * `type` :  
            The type of file.  

        Returns
        -------
        vector of file identifiers are copied here as result.  

        """
        return _moduleconnectorwrapper.PyXEP_search_for_file_by_type(self, type)


    def find_all_files(self) -> "XeThru::Files":
        """
        find_all_files(PyXEP self) -> Files



        Finds all files and stores the type and identifier of each file in the given
        buffers.  

        Returns
        -------
        The result from the search. A map of file (type identifiers)  

        """
        return _moduleconnectorwrapper.PyXEP_find_all_files(self)


    def create_file(self, file_type: 'uint32_t', identifier: 'uint32_t', length: 'uint32_t') -> "void":
        """
        create_file(PyXEP self, uint32_t file_type, uint32_t identifier, uint32_t length)



        Creates and opens a new file with given type, identifiers and length.  

        Parameters
        ----------
        * `file_type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  
        * `length` :  
            length of the file to create  

        """
        return _moduleconnectorwrapper.PyXEP_create_file(self, file_type, identifier, length)


    def open_file(self, file_type: 'uint32_t', identifier: 'uint32_t') -> "void":
        """
        open_file(PyXEP self, uint32_t file_type, uint32_t identifier)



        Opens a file with given type and identifiers.  

        Parameters
        ----------
        * `file_type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  
        * `length` :  
            length of the file to create  

        """
        return _moduleconnectorwrapper.PyXEP_open_file(self, file_type, identifier)


    def set_file_data(self, type: 'uint32_t', identifier: 'uint32_t', offset: 'uint32_t', data: 'ucVector') -> "void":
        """
        set_file_data(PyXEP self, uint32_t type, uint32_t identifier, uint32_t offset, ucVector data)



        Writes data at offset to the file.  

        Parameters
        ----------
        * `type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  
        * `offset` :  
            Offset where to write the data to.  
        * `data` :  
            The data to write.  

        """
        return _moduleconnectorwrapper.PyXEP_set_file_data(self, type, identifier, offset, data)


    def close_file(self, type: 'uint32_t', identifier: 'uint32_t', commit: 'bool') -> "void":
        """
        close_file(PyXEP self, uint32_t type, uint32_t identifier, bool commit)



        Close the file.  

        Parameters
        ----------
        * `type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  
        * `commit` :  
            wether to commit changes to the file to close  

        """
        return _moduleconnectorwrapper.PyXEP_close_file(self, type, identifier, commit)


    def get_file_length(self, type: 'uint32_t', identifier: 'uint32_t') -> "uint32_t":
        """
        get_file_length(PyXEP self, uint32_t type, uint32_t identifier) -> uint32_t



        Gets the length of a file.  

        Parameters
        ----------
        * `type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  

        Returns
        -------
        The length of the file.  

        """
        return _moduleconnectorwrapper.PyXEP_get_file_length(self, type, identifier)


    def delete_file(self, type: 'uint32_t', identifier: 'uint32_t') -> "void":
        """
        delete_file(PyXEP self, uint32_t type, uint32_t identifier)



        Deletes a file.  

        Parameters
        ----------
        * `type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  

        """
        return _moduleconnectorwrapper.PyXEP_delete_file(self, type, identifier)


    def format_filesystem(self, key: 'uint32_t') -> "void":
        """
        format_filesystem(PyXEP self, uint32_t key)



        """
        return _moduleconnectorwrapper.PyXEP_format_filesystem(self, key)


    def get_file_data(self, type: 'uint32_t', identifier: 'uint32_t', offset: 'uint32_t', length: 'uint32_t') -> "Bytes":
        """
        get_file_data(PyXEP self, uint32_t type, uint32_t identifier, uint32_t offset, uint32_t length) -> ucVector



        Reads length number of bytes of the file from the offset.  

        Parameters
        ----------
        * `type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  
        * `offset` :  
            The offset to read from.  
        * `length` :  
            Number of bytes to read.  

        Returns
        -------
        The result as a vector of bytes.  

        """
        return _moduleconnectorwrapper.PyXEP_get_file_data(self, type, identifier, offset, length)


    def set_file(self, type: 'uint32_t', identifier: 'uint32_t', data: 'ucVector') -> "void":
        """
        set_file(PyXEP self, uint32_t type, uint32_t identifier, ucVector data)



        """
        return _moduleconnectorwrapper.PyXEP_set_file(self, type, identifier, data)


    def get_file(self, type: 'uint32_t', identifier: 'uint32_t') -> "Bytes":
        """
        get_file(PyXEP self, uint32_t type, uint32_t identifier) -> ucVector



        """
        return _moduleconnectorwrapper.PyXEP_get_file(self, type, identifier)

PyXEP_swigregister = _moduleconnectorwrapper.PyXEP_swigregister
PyXEP_swigregister(PyXEP)

class PyX4M200(_object):
    """


    C++ includes: PyX4M200.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyX4M200, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyX4M200, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface: 'LockedRadarInterfacePtr &'):
        """
        __init__(XeThru::PyX4M200 self, LockedRadarInterfacePtr & radar_interface) -> PyX4M200



        """
        this = _moduleconnectorwrapper.new_PyX4M200(radar_interface)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyX4M200
    __del__ = lambda self: None

    def set_baudrate(self, baudrate: 'uint32_t') -> "void":
        """
        set_baudrate(PyX4M200 self, uint32_t baudrate)



        Set baudrate for serial communication during ModuleConnector operation.  

        Parameters
        ----------
        * `baudrate` :  
            enum representing the baudrate e.g
            moduleconnectorwrapper.XTID_BAUDRATE_115200.  

        """
        return _moduleconnectorwrapper.PyX4M200_set_baudrate(self, baudrate)


    def set_debug_level(self, level: 'unsigned char') -> "void":
        """
        set_debug_level(PyX4M200 self, unsigned char level)



        Sets debug level in the Xethru module.  

        Parameters
        ----------
        * `level` :  
            New debug level. Legal range [0-9].  

        """
        return _moduleconnectorwrapper.PyX4M200_set_debug_level(self, level)


    def ping(self) -> "uint32_t":
        """
        ping(PyX4M200 self) -> uint32_t



        Make sure there is a connection to FW on the Xethru X4M200 module.  

        Returns
        -------
        pong: 0xaaeeaeea means system ready and 0xaeeaeeaa means system not ready  

        """
        return _moduleconnectorwrapper.PyX4M200_ping(self)


    def get_system_info(self, info_code: 'uint8_t const') -> "std::string":
        """
        get_system_info(PyX4M200 self, uint8_t const info_code) -> std::string



        Returns a string containing system information given by infocode:  

        XTID_SSIC_ITEMNUMBER = 0x00 -> Returns the internal Novelda PCBA Item Number,
        including revision. This is programmed in Flash during manufacturing
        XTID_SSIC_ORDERCODE = 0x01 -> Returns the PCBA / PCBA stack order code.
        XTID_SSIC_FIRMWAREID = 0x02 -> Returns the installed Firmware ID. As viewed from
        the "highest" level of the software, "X4M300". XTID_SSIC_VERSION = 0x03 ->
        Returns the installed Firmware Version. As viewed from the "highest" level of
        the software. XTID_SSIC_BUILD = 0x04 -> Returns information of the SW Build
        installed on the device XTID_SSIC_SERIALNUMBER = 0x06 -> Returns the PCBA serial
        number XTID_SSIC_VERSIONLIST = 0x07 -> Returns ID and version of all components.
        Calls all components and compound a string. E.g.
        "X4M300:1.0.0.3;XEP:2.3.4.5;X4C51:1.0.0.0;DSP:1.1.1.1"  

        """
        return _moduleconnectorwrapper.PyX4M200_get_system_info(self, info_code)


    def module_reset(self) -> "void":
        """
        module_reset(PyX4M200 self)



        Resets and restart the module.  

        The client must perform a close and then an open on the ModuleConnector to
        reeastablish connection.  

        """
        return _moduleconnectorwrapper.PyX4M200_module_reset(self)


    def reset(self) -> "void":
        """
        reset(PyX4M200 self)



        Resets and restart the module.  

        This method automatically reestablishes.  

        """
        return _moduleconnectorwrapper.PyX4M200_reset(self)


    def reset_to_factory_preset(self) -> "void":
        """
        reset_to_factory_preset(PyX4M200 self)



        Resets all parameters in the module to factory presets.  

        """
        return _moduleconnectorwrapper.PyX4M200_reset_to_factory_preset(self)


    def start_bootloader(self) -> "void":
        """
        start_bootloader(PyX4M200 self)



        Enters the bootloader for FW upgrades.  

        """
        return _moduleconnectorwrapper.PyX4M200_start_bootloader(self)


    def inject_frame(self, frame_counter: 'uint32_t', frame_length: 'uint32_t', frame: 'FloatVector') -> "void":
        """
        inject_frame(PyX4M200 self, uint32_t frame_counter, uint32_t frame_length, FloatVector frame)



        Injects a radar frame.  

        Parameters
        ----------
        * `frame_counter` :  
            Frame counter of frame.  
        * `frame_length` :  
            Number of bins in the frame.  
        * `frame` :  
            The frame data to inject.  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyX4M200_inject_frame(self, frame_counter, frame_length, frame)


    def prepare_inject_frame(self, num_frames: 'uint32_t', num_bins: 'uint32_t', mode: 'uint32_t') -> "void":
        """
        prepare_inject_frame(PyX4M200 self, uint32_t num_frames, uint32_t num_bins, uint32_t mode)



        Prepare for injection of radar frame(s).  

        Parameters
        ----------
        * `num_frame` :  
            Number of frame to inject  
        * `num_bins` :  
            Number of bins in each frame.  
        * `mode` :  
            The frame injection mode: LOOP, SEQUENTIAL, SINGLE  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyX4M200_prepare_inject_frame(self, num_frames, num_bins, mode)


    def system_run_test(self, testcode: 'uint8_t const', data: 'ucVector') -> "void":
        """
        system_run_test(PyX4M200 self, uint8_t const testcode, ucVector data)



        Runs the different manufacturing tests identified by testcode.  

        Can return any number of results depending on test_mode. Host must know how to
        parse test results.  

        Parameters
        ----------
        * `testcode` :  
        * `data` :  
            data buffer containing the result from a test run.  

        """
        return _moduleconnectorwrapper.PyX4M200_system_run_test(self, testcode, data)


    def load_profile(self, profileid: 'uint32_t const') -> "void":
        """
        load_profile(PyX4M200 self, uint32_t const profileid)



        Loads the presence profile.  

        If another profile is loaded, the other profile is unloaded before the new
        profile is loaded. The profile does not start, the module remains idle.  

        Parameters
        ----------
        * `profileid` :  
            the id of the profile to load profileid = XTS_ID_APP_RESPIRATION_2 : sleep
            profile  

        """
        return _moduleconnectorwrapper.PyX4M200_load_profile(self, profileid)


    def set_sensor_mode(self, mode: 'uint8_t const', param: 'uint8_t const') -> "void":
        """
        set_sensor_mode(PyX4M200 self, uint8_t const mode, uint8_t const param)



        Control the execution mode of the sensor.  

        Parameters
        ----------
        * `mode` :  

             XTID_SM_RUN : Start profile execution  
             XTID_SM_IDLE : Halts profile execution. Can be resumed by setting mode to
            Run.  
             XTID_SM_STOP : Stops profile execution. Must do load_profile to continue.  
             XTID_SM_MANUAL : Routes X4 radar data directly to host rather than to
            profile execution. Can then interact directly with XEP / X4Driver. Will
            disrupt profile performance.  
        * `param` :  
            Not used, ignored, can be 0.  

        """
        return _moduleconnectorwrapper.PyX4M200_set_sensor_mode(self, mode, param)


    def get_sensor_mode(self) -> "uint8_t":
        """
        get_sensor_mode(PyX4M200 self) -> uint8_t



        """
        return _moduleconnectorwrapper.PyX4M200_get_sensor_mode(self)


    def set_sensitivity(self, sensitivity: 'uint32_t const') -> "void":
        """
        set_sensitivity(PyX4M200 self, uint32_t const sensitivity)



        Sets the overall sensitivity.  

        Parameters
        ----------
        * `sensitivity` :  
            : 0 to 9, 0 = low, 9 = high  

        """
        return _moduleconnectorwrapper.PyX4M200_set_sensitivity(self, sensitivity)


    def get_sensitivity(self) -> "uint32_t":
        """
        get_sensitivity(PyX4M200 self) -> uint32_t



        Gets the overall sensitivity.  

        Returns
        -------
        sensitivity : 0 to 9, 0 = low, 9 = high  

        """
        return _moduleconnectorwrapper.PyX4M200_get_sensitivity(self)


    def set_tx_center_frequency(self, frequency_band: 'uint32_t const') -> "void":
        """
        set_tx_center_frequency(PyX4M200 self, uint32_t const frequency_band)



        Sets TX center frequency.  

        Parameters
        ----------
        * `frequency_band` :  
            : 3 for low band, 4 for high band  

        """
        return _moduleconnectorwrapper.PyX4M200_set_tx_center_frequency(self, frequency_band)


    def get_tx_center_frequency(self) -> "uint32_t":
        """
        get_tx_center_frequency(PyX4M200 self) -> uint32_t



        Gets TX center frequency.  

        Returns
        -------
        frequency_band : 3 for low band, 4 for high band  

        """
        return _moduleconnectorwrapper.PyX4M200_get_tx_center_frequency(self)


    def set_detection_zone(self, start: 'float const', end: 'float const') -> "void":
        """
        set_detection_zone(PyX4M200 self, float const start, float const end)



        Sets the current detection zone.  

        Rules: See datasheet. The actual detection zone is determined by radar settings.
        Use the get_detection_zone command to get the actual values  

        Parameters
        ----------
        * `start` :  
        * `end` :  

        """
        return _moduleconnectorwrapper.PyX4M200_set_detection_zone(self, start, end)


    def get_detection_zone(self) -> "XeThru::DetectionZone":
        """
        get_detection_zone(PyX4M200 self) -> DetectionZone



        Returns the actual range window.  

        Returns
        -------
        DetectionZone  

        """
        return _moduleconnectorwrapper.PyX4M200_get_detection_zone(self)


    def get_detection_zone_limits(self) -> "XeThru::DetectionZoneLimits":
        """
        get_detection_zone_limits(PyX4M200 self) -> DetectionZoneLimits



        Returns the potential settings of detection zone from the module.  

        Returns
        -------
        DetectionZoneLimits:  

        """
        return _moduleconnectorwrapper.PyX4M200_get_detection_zone_limits(self)


    def set_led_control(self, mode: 'uint8_t const', intensity: 'uint8_t') -> "void":
        """
        set_led_control(PyX4M200 self, uint8_t const mode, uint8_t intensity)



        This command configures the LED mode.  



        Parameters
        ----------
        * `mode` :  
            (modes are defined in xtid.h)  
             mode = XTID_LED_MODE_OFF : OFF  
             mode = XTID_LED_MODE_SIMPLE : simple  
             mode = XTID_LED_MODE_FULL : full (default)  
        * `intensity` :  
            0 to 100, 0=low, 100=high, not implemented yet  

        """
        return _moduleconnectorwrapper.PyX4M200_set_led_control(self, mode, intensity)


    def get_led_control(self) -> "uint32_t":
        """
        get_led_control(PyX4M200 self) -> uint32_t



        Gets LED mode mode = XTID_LED_MODE_OFF : OFF  
         mode = XTID_LED_MODE_SIMPLE : simple  
         mode = XTID_LED_MODE_FULL : full (default)  
         *.  

        Returns
        -------
        mode  

        """
        return _moduleconnectorwrapper.PyX4M200_get_led_control(self)


    def set_output_control(self, output_feature: 'uint32_t', output_control: 'uint32_t') -> "void":
        """
        set_output_control(PyX4M200 self, uint32_t output_feature, uint32_t output_control)



        Control module profile output.  

        Enable and disable data messages. Several calls can be made, one for each
        available output message the profile provides.  

        Only one of XTS_ID_BASEBAND_IQ and XTS_ID_BASEBAND_AMPLITUDE_PHASE can be
        enabled at a time. Enabling one disables the other. Disabling one, even if it is
        already disabled, disables the other.  

        Only one of XTS_ID_PULSEDOPPLER_FLOAT and XTS_ID_PULSEDOPPLER_BYTE can be
        enabled for each of XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE and
        XTID_OUTPUT_CONTROL_PD_FAST_ENABLE. Same with XTS_ID_NOISEMAP_FLOAT and
        XTS_ID_NOISEMAP_BYTE. Turning on a float output automatically disables the byte
        output, and vice versa.  

        Parameters
        ----------
        * `output_feature` :  
            see values in xtid.h.  
             Possible features are:  
             XTS_ID_RESPIRATION_MOVINGLIST,  
             XTS_ID_RESPIRATION_DETECTIONLIST,  
             XTS_ID_RESP_STATUS,  
             XTS_ID_RESP_STATUS_EXT,  
             XTS_ID_BASEBAND_IQ,  
             XTS_ID_BASEBAND_AMPLITUDE_PHASE,  
             XTS_ID_PULSEDOPPLER_FLOAT,  
             XTS_ID_PULSEDOPPLER_BYTE,  
             XTS_ID_NOISEMAP_FLOAT and  
             XTS_ID_NOISEMAP_BYTE  
        * `output_control` :  
            see values in xtid.h.  
             Typical values:  
             XTID_OUTPUT_CONTROL_DISABLE = disable,  
             XTID_OUTPUT_CONTROL_ENABLE = enable.  
             For pulse-Doppler and noisemap byte/float:  
             XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE  
             XTID_OUTPUT_CONTROL_PD_FAST_ENABLE  

        """
        return _moduleconnectorwrapper.PyX4M200_set_output_control(self, output_feature, output_control)


    def set_debug_output_control(self, output_feature: 'uint32_t', output_control: 'uint32_t') -> "void":
        """
        set_debug_output_control(PyX4M200 self, uint32_t output_feature, uint32_t output_control)



        """
        return _moduleconnectorwrapper.PyX4M200_set_debug_output_control(self, output_feature, output_control)


    def get_output_control(self, output_feature: 'uint32_t const') -> "uint32_t":
        """
        get_output_control(PyX4M200 self, uint32_t const output_feature) -> uint32_t



        """
        return _moduleconnectorwrapper.PyX4M200_get_output_control(self, output_feature)


    def get_debug_output_control(self, output_feature: 'uint32_t const') -> "uint32_t":
        """
        get_debug_output_control(PyX4M200 self, uint32_t const output_feature) -> uint32_t



        """
        return _moduleconnectorwrapper.PyX4M200_get_debug_output_control(self, output_feature)


    def peek_message_baseband_ap(self) -> "int":
        """
        peek_message_baseband_ap(PyX4M200 self) -> int



        Return number of BasebandApData messages available in queue.  

        Returns
        -------
        size: number of messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_baseband_ap(self)


    def read_message_baseband_ap(self) -> "XeThru::BasebandApData":
        """
        read_message_baseband_ap(PyX4M200 self) -> BasebandApData



        Read a single BasebandApData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        BasebandApData:  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_baseband_ap(self)


    def peek_message_baseband_iq(self) -> "int":
        """
        peek_message_baseband_iq(PyX4M200 self) -> int



        Return number of BasebandIqData messages available in queue.  

        Returns
        -------
        size: number of messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_baseband_iq(self)


    def read_message_baseband_iq(self) -> "XeThru::BasebandIqData":
        """
        read_message_baseband_iq(PyX4M200 self) -> BasebandIqData



        Read a single BasebandIqData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        baseband_qi:  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_baseband_iq(self)


    def peek_message_respiration_legacy(self) -> "int":
        """
        peek_message_respiration_legacy(PyX4M200 self) -> int



        Return number of legacy respiration packets available in the queue.  

        Returns
        -------
        size: number of messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_respiration_legacy(self)


    def read_message_respiration_legacy(self) -> "XeThru::RespirationData":
        """
        read_message_respiration_legacy(PyX4M200 self) -> RespirationData



        Read a single RespirationData item from the queue.  

        Blocks if queue is empty.  

        return respiration_data: pointer to returned RespirationData item  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_respiration_legacy(self)


    def peek_message_respiration_sleep(self) -> "int":
        """
        peek_message_respiration_sleep(PyX4M200 self) -> int



        Return number of respiration sleep packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_respiration_sleep(self)


    def read_message_respiration_sleep(self) -> "XeThru::SleepData":
        """
        read_message_respiration_sleep(PyX4M200 self) -> SleepData



        Get one sleep data message from subscription queue.  

        Returns
        -------
        sleep_data: A data object holding the resulting respiration data.  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_respiration_sleep(self)


    def peek_message_respiration_movinglist(self) -> "int":
        """
        peek_message_respiration_movinglist(PyX4M200 self) -> int



        Return number of respiration moving list packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_respiration_movinglist(self)


    def read_message_respiration_movinglist(self) -> "XeThru::RespirationMovingListData":
        """
        read_message_respiration_movinglist(PyX4M200 self) -> RespirationMovingListData



        Get one respiration moving list data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting respiration moving list data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_respiration_movinglist(self)


    def peek_message_respiration_detectionlist(self) -> "int":
        """
        peek_message_respiration_detectionlist(PyX4M200 self) -> int



        Return number of respiration detection list packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_respiration_detectionlist(self)


    def read_message_respiration_detectionlist(self) -> "XeThru::RespirationDetectionListData":
        """
        read_message_respiration_detectionlist(PyX4M200 self) -> RespirationDetectionListData



        Get one respiration detection list data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting respiration detection list data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_respiration_detectionlist(self)


    def peek_message_respiration_normalizedmovementlist(self) -> "int":
        """
        peek_message_respiration_normalizedmovementlist(PyX4M200 self) -> int



        Return number of respiration normalized movement list packets available in the
        queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_respiration_normalizedmovementlist(self)


    def read_message_respiration_normalizedmovementlist(self) -> "XeThru::RespirationNormalizedMovementListData":
        """
        read_message_respiration_normalizedmovementlist(PyX4M200 self) -> RespirationNormalizedMovementListData



        Get one respiration normalized movement list data message from subscription
        queue.  

        Returns
        -------
        : A data object holding the resulting respiration normalized movement list data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_respiration_normalizedmovementlist(self)


    def peek_message_vital_signs(self) -> "int":
        """
        peek_message_vital_signs(PyX4M200 self) -> int



        Return number of vital signs packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_vital_signs(self)


    def read_message_vital_signs(self) -> "XeThru::VitalSignsData":
        """
        read_message_vital_signs(PyX4M200 self) -> VitalSignsData



        Get one vital signs data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting vital signs data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_vital_signs(self)


    def peek_message_pulsedoppler_float(self) -> "int":
        """
        peek_message_pulsedoppler_float(PyX4M200 self) -> int



        Return number of pulse-Doppler float packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_pulsedoppler_float(self)


    def read_message_pulsedoppler_float(self) -> "XeThru::PulseDopplerFloatData":
        """
        read_message_pulsedoppler_float(PyX4M200 self) -> PulseDopplerFloatData



        Get one pulse-Doppler float data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting pulse-Doppler float data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_pulsedoppler_float(self)


    def peek_message_pulsedoppler_byte(self) -> "int":
        """
        peek_message_pulsedoppler_byte(PyX4M200 self) -> int



        Return number of pulse-Doppler byte packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_pulsedoppler_byte(self)


    def read_message_pulsedoppler_byte(self) -> "XeThru::PulseDopplerByteData":
        """
        read_message_pulsedoppler_byte(PyX4M200 self) -> PulseDopplerByteData



        Get one pulse-Doppler byte data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting pulse-Doppler byte data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_pulsedoppler_byte(self)


    def peek_message_noisemap_float(self) -> "int":
        """
        peek_message_noisemap_float(PyX4M200 self) -> int



        Return number of noisemap float packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_noisemap_float(self)


    def read_message_noisemap_float(self) -> "XeThru::PulseDopplerFloatData":
        """
        read_message_noisemap_float(PyX4M200 self) -> PulseDopplerFloatData



        Get one noisemap float data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting noisemap float data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_noisemap_float(self)


    def peek_message_noisemap_byte(self) -> "int":
        """
        peek_message_noisemap_byte(PyX4M200 self) -> int



        Return number of noisemap byte packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_noisemap_byte(self)


    def read_message_noisemap_byte(self) -> "XeThru::PulseDopplerByteData":
        """
        read_message_noisemap_byte(PyX4M200 self) -> PulseDopplerByteData



        Get one noisemap byte data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting noisemap byte data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_noisemap_byte(self)


    def load_noisemap(self) -> "void":
        """
        load_noisemap(PyX4M200 self)



        Send command to module to load a previously stored noisemap.  

        Not yet functional as of FW 1.3  

        """
        return _moduleconnectorwrapper.PyX4M200_load_noisemap(self)


    def store_noisemap(self) -> "void":
        """
        store_noisemap(PyX4M200 self)



        Send command to module to store the current noisemap to module flash.  

        Fails if a store already is active, for example during the first initialize with
        XTID_NOISEMAP_CONTROL_INIT_ON_RESET disabled.  

        """
        return _moduleconnectorwrapper.PyX4M200_store_noisemap(self)


    def delete_noisemap(self) -> "void":
        """
        delete_noisemap(PyX4M200 self)



        Send command to module to delete stored noisemap from module flash.  

        Fails in case of flash access issues.  

        """
        return _moduleconnectorwrapper.PyX4M200_delete_noisemap(self)


    def set_noisemap_control(self, noisemap_control: 'uint32_t') -> "void":
        """
        set_noisemap_control(PyX4M200 self, uint32_t noisemap_control)



        Configure the use of noisemap.  

        Parameters
        ----------
        * `noisemap_control` :  
            A bitfield of the various features.  

            *   Use Stored Noise Map
                -   On - XTID_NOISEMAP_CONTROL_USE_STORED
                    -   If a valid Stored Noise Map exists this will be used at reset or
                        when the Profile is started.  
                    -   If no valid Stored Noise Map exists and Use Default Noise Map is
                        off, a new Noise Map will be created during Initialization
                        state. The newly created Noise Map will be stored in the sensor
                        when Initialization is done. A noise map created with a
                        different Detection Zone is not valid.  
                    -   If no valid Stored Noise Map exists and Use Default Noise Map is
                        on, the Default Noise Map will be used at reset or when the
                        Profile is started.  
                -   Off - XTID_NOISEMAP_CONTROL_INIT_ON_RESET
                    -   If Use Default Noise Map is off, a new Noise Map will always be
                        created at reset or when the Profile is started. Sensor will be
                        in Initialization state during Noise Map creation. A previously
                        Stored Noise Map in the sensor will be ignored, but not
                        overwritten, when the Profile starts.  
                    -   If Use Default Noise Map is on, the Default Noise Map will be
                        used at reset or when the Profile is started.  
            *   Use Default Noise Map
                -   On - XTID_NOISEMAP_CONTROL_USE_DEFAULT / DISABLE
                    -   If Use Store Noise Map is on and a valid Stored Noise Map
                        exists, Default Noise Map will not be used.  
                    -   If Use Stored Noise Map is on and no valid Stored Noise Map
                        exists, the Default Noise Map will be used at reset or when the
                        Profile is started.  
                    -   If Use Stored Noise Map is off, the Default Noise Map will be
                        used at reset or when the Profile is started.  
                -   Off - XTID_NOISEMAP_CONTROL_ENABLE
                    -   The Default Noise Map will not be used.  
            *   Adaptive Noise Map
                -   On - XTID_NOISEMAP_CONTROL_ADAPTIVE
                    -   Enables Noise Map adaptation. Noise Map will still not adapt in
                        certain conditions as described in Firmware Algorithms section
                        below.  
                -   Off - XTID_NOISEMAP_CONTROL_NONADAPTIVE
                    -   Disables Noise Map adaptation (not implemented).  

        """
        return _moduleconnectorwrapper.PyX4M200_set_noisemap_control(self, noisemap_control)


    def get_noisemap_control(self) -> "uint32_t":
        """
        get_noisemap_control(PyX4M200 self) -> uint32_t



        Get current noisemap configuration.  

        Returns
        -------
        noisemap_control : A bitfield of the various features.  

        """
        return _moduleconnectorwrapper.PyX4M200_get_noisemap_control(self)


    def set_periodic_noisemap_store(self, interval_minutes: 'uint32_t', reserved: 'uint32_t') -> "void":
        """
        set_periodic_noisemap_store(PyX4M200 self, uint32_t interval_minutes, uint32_t reserved)



        Set interval for periodoc storing of noisemap.  

        Parameters
        ----------
        * `interval_minutes` :  
            Interval for storing moisemap  
        * `reserved` :  
            Reserved for future use, must be set to 0.  

        """
        return _moduleconnectorwrapper.PyX4M200_set_periodic_noisemap_store(self, interval_minutes, reserved)


    def get_periodic_noisemap_store(self) -> "XeThru::PeriodicNoisemapStore":
        """
        get_periodic_noisemap_store(PyX4M200 self) -> PeriodicNoisemapStore



        Get interval for periodoc storing of noisemap.  

        Parameters
        ----------
        * `interval_minutes` :  
            Interval for storing moisemap  
        * `reserved` :  
            Reserved for future use, must be set to 0.  

        """
        return _moduleconnectorwrapper.PyX4M200_get_periodic_noisemap_store(self)


    def get_parameter_file(self, filename: 'std::string const &') -> "std::string":
        """
        get_parameter_file(PyX4M200 self, std::string const & filename) -> std::string



        Read the complete parameter file from the module.  

        Returns
        -------
        a string containing the complete paramter file data  

        """
        return _moduleconnectorwrapper.PyX4M200_get_parameter_file(self, filename)


    def get_profileid(self) -> "uint32_t":
        """
        get_profileid(PyX4M200 self) -> uint32_t



        Get the id of the currently loaded profile.  

        Returns
        -------
        profileid: the id of the loaded profile or 0 in case of no loaded profile.  

        """
        return _moduleconnectorwrapper.PyX4M200_get_profileid(self)


    def set_parameter_file(self, filename: 'std::string const &', data: 'std::string const &') -> "void":
        """
        set_parameter_file(PyX4M200 self, std::string const & filename, std::string const & data)



        Set a named parameter file on target.  

        Parameters
        ----------
        * `filename` :  
            The name to call the parameter file.  
        * `data` :  
            The content of the parameter-file.  

        """
        return _moduleconnectorwrapper.PyX4M200_set_parameter_file(self, filename, data)


    def set_iopin_control(self, pin_id: 'uint32_t', pin_setup: 'uint32_t', pin_feature: 'uint32_t') -> "void":
        """
        set_iopin_control(PyX4M200 self, uint32_t pin_id, uint32_t pin_setup, uint32_t pin_feature)



        Configures GPIO pin.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the IO pin to configure. pin_id = 0 means all IO pins.  
        * `pin_setup` :  
            Specifies the direction and drive of the IO pin. bit 0: input = 0, output =
            1 bit 1: open-drain = 0, push-pull = 1 bit 2: active-high = 0, active-low =
            1 bit 3: no pull-up = 0, pull-up = 1  
        * `pin_feature` :  
            Specifies the configuration of the IO pin. 0 = Disable all iopin features. 1
            = Configure according to datasheet default. This overrides pin_setup. 2 =
            Passive, set and get iopin level from host. 4 = Movement, see X4M200
            datasheet for details. 5 = Breathing, see X4M200 datasheet for details.  

        See also: get_iopin_value  

        """
        return _moduleconnectorwrapper.PyX4M200_set_iopin_control(self, pin_id, pin_setup, pin_feature)


    def get_iopin_control(self, pin_id: 'uint32_t') -> "XeThru::IoPinControl":
        """
        get_iopin_control(PyX4M200 self, uint32_t pin_id) -> IoPinControl



        Gets the GPIO pin configuration.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the io pin to get.  

        Returns
        -------
        : A data object holding the pin configuration  

        See also: set_iopin_contron  

        """
        return _moduleconnectorwrapper.PyX4M200_get_iopin_control(self, pin_id)


    def set_iopin_value(self, pin_id: 'uint32_t', pin_value: 'uint32_t') -> "void":
        """
        set_iopin_value(PyX4M200 self, uint32_t pin_id, uint32_t pin_value)



        Sets GPIO pin value.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the pin.  
        * `pin_value` :  
            Specifies the value.  

        note: Pin must be configured as output pin.  

        See also: set_iopin_control  

        """
        return _moduleconnectorwrapper.PyX4M200_set_iopin_value(self, pin_id, pin_value)


    def get_iopin_value(self, pin_id: 'uint32_t') -> "uint32_t":
        """
        get_iopin_value(PyX4M200 self, uint32_t pin_id) -> uint32_t



        Gets GPIO pin value.  

        See also: set_iopin_value  

        """
        return _moduleconnectorwrapper.PyX4M200_get_iopin_value(self, pin_id)

PyX4M200_swigregister = _moduleconnectorwrapper.PyX4M200_swigregister
PyX4M200_swigregister(PyX4M200)

class PyX4M210(_object):
    """Proxy of C++ XeThru::PyX4M210 class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyX4M210, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyX4M210, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface: 'LockedRadarInterfacePtr &'):
        """__init__(XeThru::PyX4M210 self, LockedRadarInterfacePtr & radar_interface) -> PyX4M210"""
        this = _moduleconnectorwrapper.new_PyX4M210(radar_interface)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyX4M210
    __del__ = lambda self: None

    def set_baudrate(self, baudrate: 'uint32_t') -> "void":
        """set_baudrate(PyX4M210 self, uint32_t baudrate)"""
        return _moduleconnectorwrapper.PyX4M210_set_baudrate(self, baudrate)


    def set_debug_level(self, level: 'unsigned char') -> "void":
        """set_debug_level(PyX4M210 self, unsigned char level)"""
        return _moduleconnectorwrapper.PyX4M210_set_debug_level(self, level)


    def ping(self) -> "uint32_t":
        """ping(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_ping(self)


    def get_system_info(self, info_code: 'uint8_t const') -> "std::string":
        """get_system_info(PyX4M210 self, uint8_t const info_code) -> std::string"""
        return _moduleconnectorwrapper.PyX4M210_get_system_info(self, info_code)


    def module_reset(self) -> "void":
        """module_reset(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_module_reset(self)


    def reset(self) -> "void":
        """reset(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_reset(self)


    def reset_to_factory_preset(self) -> "void":
        """reset_to_factory_preset(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_reset_to_factory_preset(self)


    def start_bootloader(self) -> "void":
        """start_bootloader(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_start_bootloader(self)


    def inject_frame(self, frame_counter: 'uint32_t', frame_length: 'uint32_t', frame: 'FloatVector') -> "void":
        """inject_frame(PyX4M210 self, uint32_t frame_counter, uint32_t frame_length, FloatVector frame)"""
        return _moduleconnectorwrapper.PyX4M210_inject_frame(self, frame_counter, frame_length, frame)


    def prepare_inject_frame(self, num_frames: 'uint32_t', num_bins: 'uint32_t', mode: 'uint32_t') -> "void":
        """prepare_inject_frame(PyX4M210 self, uint32_t num_frames, uint32_t num_bins, uint32_t mode)"""
        return _moduleconnectorwrapper.PyX4M210_prepare_inject_frame(self, num_frames, num_bins, mode)


    def system_run_test(self, testcode: 'uint8_t const', data: 'ucVector') -> "void":
        """system_run_test(PyX4M210 self, uint8_t const testcode, ucVector data)"""
        return _moduleconnectorwrapper.PyX4M210_system_run_test(self, testcode, data)


    def load_profile(self, profileid: 'uint32_t const') -> "void":
        """load_profile(PyX4M210 self, uint32_t const profileid)"""
        return _moduleconnectorwrapper.PyX4M210_load_profile(self, profileid)


    def set_sensor_mode(self, mode: 'uint8_t const', param: 'uint8_t const') -> "void":
        """set_sensor_mode(PyX4M210 self, uint8_t const mode, uint8_t const param)"""
        return _moduleconnectorwrapper.PyX4M210_set_sensor_mode(self, mode, param)


    def get_sensor_mode(self) -> "uint8_t":
        """get_sensor_mode(PyX4M210 self) -> uint8_t"""
        return _moduleconnectorwrapper.PyX4M210_get_sensor_mode(self)


    def set_sensitivity(self, sensitivity: 'uint32_t const') -> "void":
        """set_sensitivity(PyX4M210 self, uint32_t const sensitivity)"""
        return _moduleconnectorwrapper.PyX4M210_set_sensitivity(self, sensitivity)


    def get_sensitivity(self) -> "uint32_t":
        """get_sensitivity(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_sensitivity(self)


    def set_tx_center_frequency(self, frequency_band: 'uint32_t const') -> "void":
        """set_tx_center_frequency(PyX4M210 self, uint32_t const frequency_band)"""
        return _moduleconnectorwrapper.PyX4M210_set_tx_center_frequency(self, frequency_band)


    def get_tx_center_frequency(self) -> "uint32_t":
        """get_tx_center_frequency(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_tx_center_frequency(self)


    def set_detection_zone(self, start: 'float const', end: 'float const') -> "void":
        """set_detection_zone(PyX4M210 self, float const start, float const end)"""
        return _moduleconnectorwrapper.PyX4M210_set_detection_zone(self, start, end)


    def get_detection_zone(self) -> "XeThru::DetectionZone":
        """get_detection_zone(PyX4M210 self) -> DetectionZone"""
        return _moduleconnectorwrapper.PyX4M210_get_detection_zone(self)


    def get_detection_zone_limits(self) -> "XeThru::DetectionZoneLimits":
        """get_detection_zone_limits(PyX4M210 self) -> DetectionZoneLimits"""
        return _moduleconnectorwrapper.PyX4M210_get_detection_zone_limits(self)


    def set_led_control(self, mode: 'uint8_t const', intensity: 'uint8_t') -> "void":
        """set_led_control(PyX4M210 self, uint8_t const mode, uint8_t intensity)"""
        return _moduleconnectorwrapper.PyX4M210_set_led_control(self, mode, intensity)


    def get_led_control(self) -> "uint32_t":
        """get_led_control(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_led_control(self)


    def set_output_control(self, output_feature: 'uint32_t', output_control: 'uint32_t') -> "void":
        """set_output_control(PyX4M210 self, uint32_t output_feature, uint32_t output_control)"""
        return _moduleconnectorwrapper.PyX4M210_set_output_control(self, output_feature, output_control)


    def set_debug_output_control(self, output_feature: 'uint32_t', output_control: 'uint32_t') -> "void":
        """set_debug_output_control(PyX4M210 self, uint32_t output_feature, uint32_t output_control)"""
        return _moduleconnectorwrapper.PyX4M210_set_debug_output_control(self, output_feature, output_control)


    def get_output_control(self, output_feature: 'uint32_t const') -> "uint32_t":
        """get_output_control(PyX4M210 self, uint32_t const output_feature) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_output_control(self, output_feature)


    def get_debug_output_control(self, output_feature: 'uint32_t const') -> "uint32_t":
        """get_debug_output_control(PyX4M210 self, uint32_t const output_feature) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_debug_output_control(self, output_feature)


    def peek_message_baseband_ap(self) -> "int":
        """peek_message_baseband_ap(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_baseband_ap(self)


    def read_message_baseband_ap(self) -> "XeThru::BasebandApData":
        """read_message_baseband_ap(PyX4M210 self) -> BasebandApData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_baseband_ap(self)


    def peek_message_baseband_iq(self) -> "int":
        """peek_message_baseband_iq(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_baseband_iq(self)


    def read_message_baseband_iq(self) -> "XeThru::BasebandIqData":
        """read_message_baseband_iq(PyX4M210 self) -> BasebandIqData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_baseband_iq(self)


    def peek_message_respiration_legacy(self) -> "int":
        """peek_message_respiration_legacy(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_respiration_legacy(self)


    def read_message_respiration_legacy(self) -> "XeThru::RespirationData":
        """read_message_respiration_legacy(PyX4M210 self) -> RespirationData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_respiration_legacy(self)


    def peek_message_respiration_sleep(self) -> "int":
        """peek_message_respiration_sleep(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_respiration_sleep(self)


    def read_message_respiration_sleep(self) -> "XeThru::SleepData":
        """read_message_respiration_sleep(PyX4M210 self) -> SleepData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_respiration_sleep(self)


    def peek_message_respiration_movinglist(self) -> "int":
        """peek_message_respiration_movinglist(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_respiration_movinglist(self)


    def read_message_respiration_movinglist(self) -> "XeThru::RespirationMovingListData":
        """read_message_respiration_movinglist(PyX4M210 self) -> RespirationMovingListData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_respiration_movinglist(self)


    def peek_message_respiration_detectionlist(self) -> "int":
        """peek_message_respiration_detectionlist(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_respiration_detectionlist(self)


    def read_message_respiration_detectionlist(self) -> "XeThru::RespirationDetectionListData":
        """read_message_respiration_detectionlist(PyX4M210 self) -> RespirationDetectionListData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_respiration_detectionlist(self)


    def peek_message_respiration_normalizedmovementlist(self) -> "int":
        """peek_message_respiration_normalizedmovementlist(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_respiration_normalizedmovementlist(self)


    def read_message_respiration_normalizedmovementlist(self) -> "XeThru::RespirationNormalizedMovementListData":
        """read_message_respiration_normalizedmovementlist(PyX4M210 self) -> RespirationNormalizedMovementListData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_respiration_normalizedmovementlist(self)


    def peek_message_vital_signs(self) -> "int":
        """peek_message_vital_signs(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_vital_signs(self)


    def read_message_vital_signs(self) -> "XeThru::VitalSignsData":
        """read_message_vital_signs(PyX4M210 self) -> VitalSignsData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_vital_signs(self)


    def peek_message_pulsedoppler_float(self) -> "int":
        """peek_message_pulsedoppler_float(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_pulsedoppler_float(self)


    def read_message_pulsedoppler_float(self) -> "XeThru::PulseDopplerFloatData":
        """read_message_pulsedoppler_float(PyX4M210 self) -> PulseDopplerFloatData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_pulsedoppler_float(self)


    def peek_message_pulsedoppler_byte(self) -> "int":
        """peek_message_pulsedoppler_byte(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_pulsedoppler_byte(self)


    def read_message_pulsedoppler_byte(self) -> "XeThru::PulseDopplerByteData":
        """read_message_pulsedoppler_byte(PyX4M210 self) -> PulseDopplerByteData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_pulsedoppler_byte(self)


    def peek_message_noisemap_float(self) -> "int":
        """peek_message_noisemap_float(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_noisemap_float(self)


    def read_message_noisemap_float(self) -> "XeThru::PulseDopplerFloatData":
        """read_message_noisemap_float(PyX4M210 self) -> PulseDopplerFloatData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_noisemap_float(self)


    def peek_message_noisemap_byte(self) -> "int":
        """peek_message_noisemap_byte(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_noisemap_byte(self)


    def read_message_noisemap_byte(self) -> "XeThru::PulseDopplerByteData":
        """read_message_noisemap_byte(PyX4M210 self) -> PulseDopplerByteData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_noisemap_byte(self)


    def load_noisemap(self) -> "void":
        """load_noisemap(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_load_noisemap(self)


    def store_noisemap(self) -> "void":
        """store_noisemap(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_store_noisemap(self)


    def delete_noisemap(self) -> "void":
        """delete_noisemap(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_delete_noisemap(self)


    def set_noisemap_control(self, noisemap_control: 'uint32_t') -> "void":
        """set_noisemap_control(PyX4M210 self, uint32_t noisemap_control)"""
        return _moduleconnectorwrapper.PyX4M210_set_noisemap_control(self, noisemap_control)


    def get_noisemap_control(self) -> "uint32_t":
        """get_noisemap_control(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_noisemap_control(self)


    def set_periodic_noisemap_store(self, interval_minutes: 'uint32_t', reserved: 'uint32_t') -> "void":
        """set_periodic_noisemap_store(PyX4M210 self, uint32_t interval_minutes, uint32_t reserved)"""
        return _moduleconnectorwrapper.PyX4M210_set_periodic_noisemap_store(self, interval_minutes, reserved)


    def get_periodic_noisemap_store(self) -> "XeThru::PeriodicNoisemapStore":
        """get_periodic_noisemap_store(PyX4M210 self) -> PeriodicNoisemapStore"""
        return _moduleconnectorwrapper.PyX4M210_get_periodic_noisemap_store(self)


    def get_parameter_file(self, filename: 'std::string const &') -> "std::string":
        """get_parameter_file(PyX4M210 self, std::string const & filename) -> std::string"""
        return _moduleconnectorwrapper.PyX4M210_get_parameter_file(self, filename)


    def get_profileid(self) -> "uint32_t":
        """get_profileid(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_profileid(self)


    def set_parameter_file(self, filename: 'std::string const &', data: 'std::string const &') -> "void":
        """set_parameter_file(PyX4M210 self, std::string const & filename, std::string const & data)"""
        return _moduleconnectorwrapper.PyX4M210_set_parameter_file(self, filename, data)


    def set_iopin_control(self, pin_id: 'uint32_t', pin_setup: 'uint32_t', pin_feature: 'uint32_t') -> "void":
        """set_iopin_control(PyX4M210 self, uint32_t pin_id, uint32_t pin_setup, uint32_t pin_feature)"""
        return _moduleconnectorwrapper.PyX4M210_set_iopin_control(self, pin_id, pin_setup, pin_feature)


    def get_iopin_control(self, pin_id: 'uint32_t') -> "XeThru::IoPinControl":
        """get_iopin_control(PyX4M210 self, uint32_t pin_id) -> IoPinControl"""
        return _moduleconnectorwrapper.PyX4M210_get_iopin_control(self, pin_id)


    def set_iopin_value(self, pin_id: 'uint32_t', pin_value: 'uint32_t') -> "void":
        """set_iopin_value(PyX4M210 self, uint32_t pin_id, uint32_t pin_value)"""
        return _moduleconnectorwrapper.PyX4M210_set_iopin_value(self, pin_id, pin_value)


    def get_iopin_value(self, pin_id: 'uint32_t') -> "uint32_t":
        """get_iopin_value(PyX4M210 self, uint32_t pin_id) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_iopin_value(self, pin_id)

PyX4M210_swigregister = _moduleconnectorwrapper.PyX4M210_swigregister
PyX4M210_swigregister(PyX4M210)

class PyX4M300(_object):
    """


    C++ includes: PyX4M300.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyX4M300, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyX4M300, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface: 'LockedRadarInterfacePtr &'):
        """
        __init__(XeThru::PyX4M300 self, LockedRadarInterfacePtr & radar_interface) -> PyX4M300



        """
        this = _moduleconnectorwrapper.new_PyX4M300(radar_interface)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyX4M300
    __del__ = lambda self: None

    def set_baudrate(self, baudrate: 'uint32_t') -> "void":
        """
        set_baudrate(PyX4M300 self, uint32_t baudrate)



        Set baudrate for serial communication during ModuleConnector operation.  

        Parameters
        ----------
        * `baudrate` :  
            enum representing the baudrate e.g
            moduleconnectorwrapper.XTID_BAUDRATE_115200.  

        """
        return _moduleconnectorwrapper.PyX4M300_set_baudrate(self, baudrate)


    def set_debug_level(self, level: 'unsigned char') -> "void":
        """
        set_debug_level(PyX4M300 self, unsigned char level)



        Sets debug level in the Xethru module.  

        Parameters
        ----------
        * `level` :  
            New debug level. Legal range [0-9].  

        """
        return _moduleconnectorwrapper.PyX4M300_set_debug_level(self, level)


    def ping(self) -> "uint32_t":
        """
        ping(PyX4M300 self) -> uint32_t



        Make sure there is a connection to FW on the Xethru X4M200 module.  

        Returns
        -------
        pong: 0xaaeeaeea means system ready and 0xaeeaeeaa means system not ready  

        """
        return _moduleconnectorwrapper.PyX4M300_ping(self)


    def get_system_info(self, info_code: 'uint8_t const') -> "std::string":
        """
        get_system_info(PyX4M300 self, uint8_t const info_code) -> std::string



        Returns a string containing system information given by infocode:  

        XTID_SSIC_ITEMNUMBER = 0x00 -> Returns the internal Novelda PCBA Item Number,
        including revision. This is programmed in Flash during manufacturing
        XTID_SSIC_ORDERCODE = 0x01 -> Returns the PCBA / PCBA stack order code.
        XTID_SSIC_FIRMWAREID = 0x02 -> Returns the installed Firmware ID. As viewed from
        the "highest" level of the software, "X4M300". XTID_SSIC_VERSION = 0x03 ->
        Returns the installed Firmware Version. As viewed from the "highest" level of
        the software. XTID_SSIC_BUILD = 0x04 -> Returns information of the SW Build
        installed on the device XTID_SSIC_SERIALNUMBER = 0x06 -> Returns the PCBA serial
        number XTID_SSIC_VERSIONLIST = 0x07 -> Returns ID and version of all components.
        Calls all components and compound a string. E.g.
        "X4M300:1.0.0.3;XEP:2.3.4.5;X4C51:1.0.0.0;DSP:1.1.1.1"  

        """
        return _moduleconnectorwrapper.PyX4M300_get_system_info(self, info_code)


    def module_reset(self) -> "void":
        """
        module_reset(PyX4M300 self)



        Resets and restart the module.  

        The client must perform a close and then an open on the ModuleConnector to
        reeastablish connection.  

        """
        return _moduleconnectorwrapper.PyX4M300_module_reset(self)


    def reset(self) -> "int":
        """
        reset(PyX4M300 self) -> int



        Resets and restart the module.  

        This method automatically reestablishes.  

        """
        return _moduleconnectorwrapper.PyX4M300_reset(self)


    def reset_to_factory_preset(self) -> "void":
        """
        reset_to_factory_preset(PyX4M300 self)



        Resets all parameters in the module to factory presets.  

        """
        return _moduleconnectorwrapper.PyX4M300_reset_to_factory_preset(self)


    def start_bootloader(self) -> "void":
        """
        start_bootloader(PyX4M300 self)



        Enters the bootloader for FW upgrades.  

        """
        return _moduleconnectorwrapper.PyX4M300_start_bootloader(self)


    def inject_frame(self, frame_counter: 'uint32_t', frame_length: 'uint32_t', frame: 'FloatVector') -> "void":
        """
        inject_frame(PyX4M300 self, uint32_t frame_counter, uint32_t frame_length, FloatVector frame)



        Injects a radar frame.  

        Parameters
        ----------
        * `frame_counter` :  
            Frame counter of frame.  
        * `frame_length` :  
            Number of bins in the frame.  
        * `frame` :  
            The frame data to inject.  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyX4M300_inject_frame(self, frame_counter, frame_length, frame)


    def prepare_inject_frame(self, num_frames: 'uint32_t', num_bins: 'uint32_t', mode: 'uint32_t') -> "void":
        """
        prepare_inject_frame(PyX4M300 self, uint32_t num_frames, uint32_t num_bins, uint32_t mode)



        Prepare for injection of radar frame(s).  

        Parameters
        ----------
        * `num_frame` :  
            Number of frame to inject  
        * `num_bins` :  
            Number of bins in each frame.  
        * `mode` :  
            The frame injection mode: LOOP, SEQUENTIAL, SINGLE  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyX4M300_prepare_inject_frame(self, num_frames, num_bins, mode)


    def system_run_test(self, testcode: 'uint8_t const', data: 'ucVector') -> "int":
        """
        system_run_test(PyX4M300 self, uint8_t const testcode, ucVector data) -> int



        Runs the different manufacturing tests identified by testcode.  

        Can return any number of results depending on test_mode. Host must know how to
        parse test results.  

        Parameters
        ----------
        * `testcode` :  
        * `data` :  
            data buffer containing the result from a test run.  

        """
        return _moduleconnectorwrapper.PyX4M300_system_run_test(self, testcode, data)


    def load_profile(self, profileid: 'uint32_t const') -> "void":
        """
        load_profile(PyX4M300 self, uint32_t const profileid)



        Loads the presence profile.  

        If another profile is loaded, the other profile is unloaded before the new
        profile is loaded. The profile does not start, the module remains idle.  

        Parameters
        ----------
        * `profileid` :  
            the id of the profile to load profileid = XTS_ID_APP_PRESENCE_2 : presence
            profile  

        """
        return _moduleconnectorwrapper.PyX4M300_load_profile(self, profileid)


    def set_sensor_mode(self, mode: 'uint8_t const', param: 'uint8_t const') -> "void":
        """
        set_sensor_mode(PyX4M300 self, uint8_t const mode, uint8_t const param)



        Control the execution mode of the sensor.  

        Parameters
        ----------
        * `mode` :  

             XTID_SM_RUN : Start profile execution  
             XTID_SM_IDLE : Halts profile execution. Can be resumed by setting mode to
            Run.  
             XTID_SM_STOP : Stops profile execution. Must do load_profile to continue.  
             XTID_SM_MANUAL : Routes X4 radar data directly to host rather than to
            profile execution. Can then interact directly with XEP / X4Driver. Will
            disrupt profile performance.  
        * `param` :  
            Not used, ignored, can be 0.  

        """
        return _moduleconnectorwrapper.PyX4M300_set_sensor_mode(self, mode, param)


    def get_sensor_mode(self) -> "uint8_t":
        """
        get_sensor_mode(PyX4M300 self) -> uint8_t



        """
        return _moduleconnectorwrapper.PyX4M300_get_sensor_mode(self)


    def set_sensitivity(self, sensitivity: 'uint32_t const') -> "void":
        """
        set_sensitivity(PyX4M300 self, uint32_t const sensitivity)



        Sets the overall sensitivity.  

        Parameters
        ----------
        * `sensitivity` :  
            : 0 to 9, 0 = low, 9 = high  

        """
        return _moduleconnectorwrapper.PyX4M300_set_sensitivity(self, sensitivity)


    def get_sensitivity(self) -> "uint32_t":
        """
        get_sensitivity(PyX4M300 self) -> uint32_t



        Gets the overall sensitivity.  

        Returns
        -------
        sensitivity : 0 to 9, 0 = low, 9 = high  

        """
        return _moduleconnectorwrapper.PyX4M300_get_sensitivity(self)


    def set_tx_center_frequency(self, frequency_band: 'uint32_t const') -> "void":
        """
        set_tx_center_frequency(PyX4M300 self, uint32_t const frequency_band)



        Sets TX center frequency.  

        Parameters
        ----------
        * `frequency_band` :  
            : 3 for low band, 4 for high band  

        """
        return _moduleconnectorwrapper.PyX4M300_set_tx_center_frequency(self, frequency_band)


    def get_tx_center_frequency(self) -> "uint32_t":
        """
        get_tx_center_frequency(PyX4M300 self) -> uint32_t



        Gets TX center frequency.  

        Returns
        -------
        frequency_band : 3 for low band, 4 for high band  

        """
        return _moduleconnectorwrapper.PyX4M300_get_tx_center_frequency(self)


    def set_detection_zone(self, start: 'float const', end: 'float const') -> "void":
        """
        set_detection_zone(PyX4M300 self, float const start, float const end)



        Sets the current detection zone.  

        Rules: See datasheet. The actual detection zone is determined by radar settings.
        Use the get_detection_zone command to get the actual values  

        Parameters
        ----------
        * `start` :  
        * `end` :  

        """
        return _moduleconnectorwrapper.PyX4M300_set_detection_zone(self, start, end)


    def get_detection_zone(self) -> "XeThru::DetectionZone":
        """
        get_detection_zone(PyX4M300 self) -> DetectionZone



        Returns the actual range window.  

        Returns
        -------
        DetectionZone:  

        """
        return _moduleconnectorwrapper.PyX4M300_get_detection_zone(self)


    def get_detection_zone_limits(self) -> "XeThru::DetectionZoneLimits":
        """
        get_detection_zone_limits(PyX4M300 self) -> DetectionZoneLimits



        Returns the potential settings of detection zone from the module.  

        Returns
        -------
        DetectionZoneLimits:  

        """
        return _moduleconnectorwrapper.PyX4M300_get_detection_zone_limits(self)


    def set_led_control(self, mode: 'uint8_t const', intensity: 'uint8_t') -> "void":
        """
        set_led_control(PyX4M300 self, uint8_t const mode, uint8_t intensity)



        This command configures the LED mode.  



        Parameters
        ----------
        * `mode` :  
            (modes are defined in xtid.h)  
             mode = XTID_LED_MODE_OFF : OFF  
             mode = XTID_LED_MODE_SIMPLE : simple  
             mode = XTID_LED_MODE_FULL : full (default)  
        * `intensity` :  
            0 to 100, 0=low, 100=high, not implemented yet  

        """
        return _moduleconnectorwrapper.PyX4M300_set_led_control(self, mode, intensity)


    def get_led_control(self) -> "uint32_t":
        """
        get_led_control(PyX4M300 self) -> uint32_t



        Gets LED mode mode = XTID_LED_MODE_OFF : OFF  
         mode = XTID_LED_MODE_SIMPLE : simple  
         mode = XTID_LED_MODE_FULL : full (default)  
         *.  

        Returns
        -------
        mode  

        """
        return _moduleconnectorwrapper.PyX4M300_get_led_control(self)


    def set_output_control(self, output_feature: 'uint32_t', output_control: 'uint32_t') -> "void":
        """
        set_output_control(PyX4M300 self, uint32_t output_feature, uint32_t output_control)



        Control module profile output.  

        Enable and disable data messages. Several calls can be made, one for each
        available output message the profile provides.  

        Only one of XTS_ID_BASEBAND_IQ and XTS_ID_BASEBAND_AMPLITUDE_PHASE can be
        enabled at a time. Enabling one disables the other. Disabling one, even if it is
        already disabled, disables the other.  

        Only one of XTS_ID_PULSEDOPPLER_FLOAT and XTS_ID_PULSEDOPPLER_BYTE can be
        enabled for each of XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE and
        XTID_OUTPUT_CONTROL_PD_FAST_ENABLE. Same with XTS_ID_NOISEMAP_FLOAT and
        XTS_ID_NOISEMAP_BYTE. Turning on a float output automatically disables the byte
        output, and vice versa.  

        Parameters
        ----------
        * `output_feature` :  
            see values in xtid.h.  
             Possible features are:  
             XTS_ID_PRESENCE_SINGLE,  
             XTS_ID_PRESENCE_MOVINGLIST,  
             XTS_ID_BASEBAND_IQ,  
             XTS_ID_BASEBAND_AMPLITUDE_PHASE,  
             XTS_ID_PULSEDOPPLER_FLOAT,  
             XTS_ID_PULSEDOPPLER_BYTE,  
             XTS_ID_NOISEMAP_FLOAT and  
             XTS_ID_NOISEMAP_BYTE  
        * `output_control` :  
            see values in xtid.h.  
             Typical values:  
             XTID_OUTPUT_CONTROL_DISABLE = disable,  
             XTID_OUTPUT_CONTROL_ENABLE = enable.  
             For pulse-Doppler and noisemap byte/float:  
             XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE  
             XTID_OUTPUT_CONTROL_PD_FAST_ENABLE  

        """
        return _moduleconnectorwrapper.PyX4M300_set_output_control(self, output_feature, output_control)


    def set_debug_output_control(self, output_feature: 'uint32_t', output_control: 'uint32_t') -> "void":
        """
        set_debug_output_control(PyX4M300 self, uint32_t output_feature, uint32_t output_control)



        """
        return _moduleconnectorwrapper.PyX4M300_set_debug_output_control(self, output_feature, output_control)


    def get_output_control(self, output_feature: 'uint32_t const') -> "uint32_t":
        """
        get_output_control(PyX4M300 self, uint32_t const output_feature) -> uint32_t



        """
        return _moduleconnectorwrapper.PyX4M300_get_output_control(self, output_feature)


    def get_debug_output_control(self, output_feature: 'uint32_t const') -> "uint32_t":
        """
        get_debug_output_control(PyX4M300 self, uint32_t const output_feature) -> uint32_t



        """
        return _moduleconnectorwrapper.PyX4M300_get_debug_output_control(self, output_feature)


    def peek_message_presence_single(self) -> "int":
        """
        peek_message_presence_single(PyX4M300 self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_presence_single(self)


    def read_message_presence_single(self) -> "XeThru::PresenceSingleData":
        """
        read_message_presence_single(PyX4M300 self) -> PresenceSingleData



        Read a single PresenceSingleData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        presence_single:  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_presence_single(self)


    def peek_message_presence_movinglist(self) -> "int":
        """
        peek_message_presence_movinglist(PyX4M300 self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_presence_movinglist(self)


    def read_message_presence_movinglist(self) -> "XeThru::PresenceMovingListData":
        """
        read_message_presence_movinglist(PyX4M300 self) -> PresenceMovingListData



        Read a single PresenceMovingList item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        presence_moving_list:  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_presence_movinglist(self)


    def peek_message_baseband_ap(self) -> "int":
        """
        peek_message_baseband_ap(PyX4M300 self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_baseband_ap(self)


    def read_message_baseband_ap(self) -> "XeThru::BasebandApData":
        """
        read_message_baseband_ap(PyX4M300 self) -> BasebandApData



        Read a single BasebandApData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        baseband_ap:  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_baseband_ap(self)


    def peek_message_baseband_iq(self) -> "int":
        """
        peek_message_baseband_iq(PyX4M300 self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_baseband_iq(self)


    def read_message_baseband_iq(self) -> "XeThru::BasebandIqData":
        """
        read_message_baseband_iq(PyX4M300 self) -> BasebandIqData



        Read a single BasebandIqData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        baseband_qi:  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_baseband_iq(self)


    def peek_message_pulsedoppler_float(self) -> "int":
        """
        peek_message_pulsedoppler_float(PyX4M300 self) -> int



        Return number of pulse-Doppler float packets available in the queue.  

        Returns
        -------
        size: number og messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_pulsedoppler_float(self)


    def read_message_pulsedoppler_float(self) -> "XeThru::PulseDopplerFloatData":
        """
        read_message_pulsedoppler_float(PyX4M300 self) -> PulseDopplerFloatData



        Get one pulse-Doppler float data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting pulse-Doppler float data  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_pulsedoppler_float(self)


    def peek_message_pulsedoppler_byte(self) -> "int":
        """
        peek_message_pulsedoppler_byte(PyX4M300 self) -> int



        Return number of pulse-Doppler byte packets available in the queue.  

        Returns
        -------
        size: number og messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_pulsedoppler_byte(self)


    def read_message_pulsedoppler_byte(self) -> "XeThru::PulseDopplerByteData":
        """
        read_message_pulsedoppler_byte(PyX4M300 self) -> PulseDopplerByteData



        Get one pulse-Doppler byte data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting pulse-Doppler float data  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_pulsedoppler_byte(self)


    def peek_message_noisemap_float(self) -> "int":
        """
        peek_message_noisemap_float(PyX4M300 self) -> int



        Return number of noisemap float packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_noisemap_float(self)


    def read_message_noisemap_float(self) -> "XeThru::PulseDopplerFloatData":
        """
        read_message_noisemap_float(PyX4M300 self) -> PulseDopplerFloatData



        Get one noisemap float data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting noisemap float data  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_noisemap_float(self)


    def peek_message_noisemap_byte(self) -> "int":
        """
        peek_message_noisemap_byte(PyX4M300 self) -> int



        Return number of noisemap byte packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_noisemap_byte(self)


    def read_message_noisemap_byte(self) -> "XeThru::PulseDopplerByteData":
        """
        read_message_noisemap_byte(PyX4M300 self) -> PulseDopplerByteData



        Get one noisemap byte data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting noisemap byte data  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_noisemap_byte(self)


    def load_noisemap(self) -> "void":
        """
        load_noisemap(PyX4M300 self)



        Send command to module to load a previously stored noisemap.  

        Not yet functional as of FW 1.3  

        """
        return _moduleconnectorwrapper.PyX4M300_load_noisemap(self)


    def store_noisemap(self) -> "void":
        """
        store_noisemap(PyX4M300 self)



        Send command to module to store the current noisemap to module flash.  

        Fails if a store already is active, for example during the first initialize with
        XTID_NOISEMAP_CONTROL_INIT_ON_RESET disabled.  

        """
        return _moduleconnectorwrapper.PyX4M300_store_noisemap(self)


    def delete_noisemap(self) -> "void":
        """
        delete_noisemap(PyX4M300 self)



        Send command to module to delete stored noisemap from module flash.  

        Fails in case of flash access issues.  

        """
        return _moduleconnectorwrapper.PyX4M300_delete_noisemap(self)


    def set_noisemap_control(self, noisemap_control: 'uint32_t') -> "void":
        """
        set_noisemap_control(PyX4M300 self, uint32_t noisemap_control)



        Configure the use of noisemap.  

        Parameters
        ----------
        * `noisemap_control` :  
            A bitfield of the various features.  

            *   Use Stored Noise Map
                -   On - XTID_NOISEMAP_CONTROL_USE_STORED
                    -   If a valid Stored Noise Map exists this will be used at reset or
                        when the Profile is started.  
                    -   If no valid Stored Noise Map exists and Use Default Noise Map is
                        off, a new Noise Map will be created during Initialization
                        state. The newly created Noise Map will be stored in the sensor
                        when Initialization is done. A noise map created with a
                        different Detection Zone is not valid.  
                    -   If no valid Stored Noise Map exists and Use Default Noise Map is
                        on, the Default Noise Map will be used at reset or when the
                        Profile is started.  
                -   Off - XTID_NOISEMAP_CONTROL_INIT_ON_RESET
                    -   If Use Default Noise Map is off, a new Noise Map will always be
                        created at reset or when the Profile is started. Sensor will be
                        in Initialization state during Noise Map creation. A previously
                        Stored Noise Map in the sensor will be ignored, but not
                        overwritten, when the Profile starts.  
                    -   If Use Default Noise Map is on, the Default Noise Map will be
                        used at reset or when the Profile is started.  
            *   Use Default Noise Map
                -   On - XTID_NOISEMAP_CONTROL_USE_DEFAULT / DISABLE
                    -   If Use Store Noise Map is on and a valid Stored Noise Map
                        exists, Default Noise Map will not be used.  
                    -   If Use Stored Noise Map is on and no valid Stored Noise Map
                        exists, the Default Noise Map will be used at reset or when the
                        Profile is started.  
                    -   If Use Stored Noise Map is off, the Default Noise Map will be
                        used at reset or when the Profile is started.  
                -   Off - XTID_NOISEMAP_CONTROL_ENABLE
                    -   The Default Noise Map will not be used.  
            *   Adaptive Noise Map
                -   On - XTID_NOISEMAP_CONTROL_ADAPTIVE
                    -   Enables Noise Map adaptation. Noise Map will still not adapt in
                        certain conditions as described in Firmware Algorithms section
                        below.  
                -   Off - XTID_NOISEMAP_CONTROL_NONADAPTIVE
                    -   Disables Noise Map adaptation (not implemented).  

        """
        return _moduleconnectorwrapper.PyX4M300_set_noisemap_control(self, noisemap_control)


    def get_noisemap_control(self) -> "uint32_t":
        """
        get_noisemap_control(PyX4M300 self) -> uint32_t



        Get current noisemap configuration.  

        Returns
        -------
        noisemap_control : A bitfield of the various features.  

        """
        return _moduleconnectorwrapper.PyX4M300_get_noisemap_control(self)


    def set_periodic_noisemap_store(self, interval_minutes: 'uint32_t', reserved: 'uint32_t') -> "void":
        """
        set_periodic_noisemap_store(PyX4M300 self, uint32_t interval_minutes, uint32_t reserved)



        Set interval for periodoc storing of noisemap.  

        Parameters
        ----------
        * `interval_minutes` :  
            Interval for storing moisemap  
        * `reserved` :  
            Reserved for future use, must be set to 0.  

        """
        return _moduleconnectorwrapper.PyX4M300_set_periodic_noisemap_store(self, interval_minutes, reserved)


    def get_periodic_noisemap_store(self) -> "XeThru::PeriodicNoisemapStore":
        """
        get_periodic_noisemap_store(PyX4M300 self) -> PeriodicNoisemapStore



        Get interval for periodoc storing of noisemap.  

        Parameters
        ----------
        * `interval_minutes` :  
            Interval for storing moisemap  
        * `reserved` :  
            Reserved for future use, must be set to 0.  

        """
        return _moduleconnectorwrapper.PyX4M300_get_periodic_noisemap_store(self)


    def get_parameter_file(self, filename: 'std::string const &') -> "std::string":
        """
        get_parameter_file(PyX4M300 self, std::string const & filename) -> std::string



        Read the complete parameter file from the module.  

        Returns
        -------
        a string containing the complete paramter file data  

        """
        return _moduleconnectorwrapper.PyX4M300_get_parameter_file(self, filename)


    def get_profileid(self) -> "uint32_t":
        """
        get_profileid(PyX4M300 self) -> uint32_t



        Get the id of the currently loaded profile.  

        Returns
        -------
        profileid: the id of the loaded profile or 0 in case of no loaded profile.  

        """
        return _moduleconnectorwrapper.PyX4M300_get_profileid(self)


    def set_parameter_file(self, filename: 'std::string const &', data: 'std::string const &') -> "void":
        """
        set_parameter_file(PyX4M300 self, std::string const & filename, std::string const & data)



        Set a named parameter file on target.  

        Parameters
        ----------
        * `filename` :  
            The name to call the parameter file.  
        * `data` :  
            The content of the parameter-file.  

        """
        return _moduleconnectorwrapper.PyX4M300_set_parameter_file(self, filename, data)


    def set_iopin_control(self, pin_id: 'uint32_t', pin_setup: 'uint32_t', pin_feature: 'uint32_t') -> "void":
        """
        set_iopin_control(PyX4M300 self, uint32_t pin_id, uint32_t pin_setup, uint32_t pin_feature)



        Configures GPIO pin.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the IO pin to configure. pin_id = 0 means all IO pins.  
        * `pin_setup` :  
            Specifies the direction and drive of the IO pin. bit 0: input = 0, output =
            1 bit 1: open-drain = 0, push-pull = 1 bit 2: active-high = 0, active-low =
            1 bit 3: no pull-up = 0, pull-up = 1  
        * `pin_feature` :  
            Specifies the configuration of the IO pin. 0 = Disable all iopin features. 1
            = Configure according to datasheet default. This overrides pin_setup. 2 =
            Passive, set and get iopin level from host. 3 = Presence, see X4M300
            datasheet for details.  

        See also: get_iopin_value  

        """
        return _moduleconnectorwrapper.PyX4M300_set_iopin_control(self, pin_id, pin_setup, pin_feature)


    def get_iopin_control(self, pin_id: 'uint32_t') -> "XeThru::IoPinControl":
        """
        get_iopin_control(PyX4M300 self, uint32_t pin_id) -> IoPinControl



        Gets the GPIO pin configuration.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the io pin to get.  

        Returns
        -------
        : A data object holding the pin configuration  

        See also: set_iopin_contron  

        """
        return _moduleconnectorwrapper.PyX4M300_get_iopin_control(self, pin_id)


    def set_iopin_value(self, pin_id: 'uint32_t', pin_value: 'uint32_t') -> "void":
        """
        set_iopin_value(PyX4M300 self, uint32_t pin_id, uint32_t pin_value)



        Sets GPIO pin value.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the pin.  
        * `pin_value` :  
            Specifies the value.  

        note: Pin must be configured as output pin.  

        See also: set_iopin_control  

        """
        return _moduleconnectorwrapper.PyX4M300_set_iopin_value(self, pin_id, pin_value)


    def get_iopin_value(self, pin_id: 'uint32_t') -> "uint32_t":
        """
        get_iopin_value(PyX4M300 self, uint32_t pin_id) -> uint32_t



        Gets GPIO pin value.  

        See also: set_iopin_value  

        """
        return _moduleconnectorwrapper.PyX4M300_get_iopin_value(self, pin_id)

PyX4M300_swigregister = _moduleconnectorwrapper.PyX4M300_swigregister
PyX4M300_swigregister(PyX4M300)

class PyDataRecorder(_object):
    """


    The DataRecorder class allows recording of xethru data types.  

    The DataRecorder class is a high level recorder class. It can be used to record
    all data types sent by a xethru device over serial port or similar. All low-
    level I/O is handled by the recorder itself with no setup required. Data is
    stored on disk as specified by the XeThru File Formats document and can be
    easily read back using the *DataReader* class.  

    @snippet record.py Typical usage  

    note: The DataRecorder has no means to enable or disable data output on a
        physical xethru device. It simply records the specified data type(s) if sent
        by the module. Therefore, it is the user's responsibility to enable or
        disable data ouput on the module itself. If no data is sent, no data will be
        recorded.  

    DataRecorder also supports more advance *RecordingOptions* such as splitting of
    files and directories.  

    See also: start_recording RecordingOptions DataReader.  

    C++ includes: PyDataRecorder.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyDataRecorder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyDataRecorder, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface: 'LockedRadarInterfacePtr &'):
        """
        __init__(XeThru::PyDataRecorder self, LockedRadarInterfacePtr & radar_interface) -> PyDataRecorder



        Constructs recorder.  

        """
        this = _moduleconnectorwrapper.new_PyDataRecorder(radar_interface)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyDataRecorder
    __del__ = lambda self: None

    def start_recording(self, *args) -> "int":
        """
        start_recording(PyDataRecorder self, XeThru::DataTypes data_types, std::string const & directory, RecordingOptions options) -> int
        start_recording(PyDataRecorder self, XeThru::DataTypes data_types, std::string const & directory) -> int



        Starts recording the specified data type(s) and output recorded files to the
        directory specified.  

        This command does not enable data output on the module.  

        Parameters
        ----------
        * `data_types` :  
            DataTypes is a bitmask that consists of a combination of DataType flags.
            These flags can be combined with the bitwise OR operator (|). For example:
            BasebandIqData | SleepData. A convenience value AllDataTypes can also be
            specified.  
        * `directory` :  
            Output folder where recorded files will be stored.  
        * `options` :  
            Specifies advanced options such as splitting of files and directories. By
            default, this parameter is RecordingOptions() (no advanced options).  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: RecordingOptions, stop_recording  

        """
        return _moduleconnectorwrapper.PyDataRecorder_start_recording(self, *args)


    def stop_recording(self, data_types: 'XeThru::DataTypes') -> "void":
        """
        stop_recording(PyDataRecorder self, XeThru::DataTypes data_types)



        Stops recording the specified data type(s).  

        This command does not disable data output on the module.  

        Parameters
        ----------
        * `data_types` :  
            DataTypes is a bitmask that consists of a combination of DataType flags.
            These flags can be combined with the bitwise OR operator (|). For example:
            BasebandIqData | SleepData. A convenience value AllDataTypes can also be
            specified.  

        See also: start_recording  

        """
        return _moduleconnectorwrapper.PyDataRecorder_stop_recording(self, data_types)


    def is_recording(self, data_type: 'uint32_t') -> "bool":
        """
        is_recording(PyDataRecorder self, uint32_t data_type) -> bool



        Returns
        -------
        true if recording is started for the specified data type, otherwise returns
        false  

        See also: start_recording  

        """
        return _moduleconnectorwrapper.PyDataRecorder_is_recording(self, data_type)


    def process(self, data_type: 'uint32_t', data: 'ucVector') -> "bool":
        """
        process(PyDataRecorder self, uint32_t data_type, ucVector data) -> bool



        This function should not be used when recording data from a physical xethru
        device.  

        It is only relevant for recording data generated elsewhere. Most users will not
        need this functionality.  

        Process the specified data for a given data type.  

        Parameters
        ----------
        * `data_type` :  
            Specifies the data type to process  
        * `data` :  
            Specifies the bytes to process  

        Returns
        -------
        true on success, otherwise returns false  

        """
        return _moduleconnectorwrapper.PyDataRecorder_process(self, data_type, data)


    def unsubscribe_to_file_available(self, data_types: 'XeThru::DataTypes') -> "void":
        """
        unsubscribe_to_file_available(PyDataRecorder self, XeThru::DataTypes data_types)



        Unsubscribes to notifications when a recorded file for a data type is available.  

        Parameters
        ----------
        * `data_types` :  
            DataTypes is a bitmask that consists of a combination of DataType flags.
            These flags can be combined with the bitwise OR operator (|). For example:
            BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can
            also be specified.  

        See also: subscribe_to_file_available  

        """
        return _moduleconnectorwrapper.PyDataRecorder_unsubscribe_to_file_available(self, data_types)


    def unsubscribe_to_meta_file_available(self) -> "int":
        """
        unsubscribe_to_meta_file_available(PyDataRecorder self) -> int



        Unsubscribes to notifications when a meta file is available.  

        See also: subscribe_to_meta_file_available  

        """
        return _moduleconnectorwrapper.PyDataRecorder_unsubscribe_to_meta_file_available(self)


    def set_basename_for_data_type(self, data_type: 'uint32_t', name: 'std::string const &') -> "void":
        """
        set_basename_for_data_type(PyDataRecorder self, uint32_t data_type, std::string const & name)



        Sets the basename for the specified data type.  

        Most users will not need this functionality.  

        Parameters
        ----------
        * `data_type` :  
            Specifies the data type  
        * `name` :  
            Specifies the name  

        See also: get_basename_for_data_type, clear_basename_for_data_types  

        """
        return _moduleconnectorwrapper.PyDataRecorder_set_basename_for_data_type(self, data_type, name)


    def get_basename_for_data_type(self, data_type: 'uint32_t') -> "std::string":
        """
        get_basename_for_data_type(PyDataRecorder self, uint32_t data_type) -> std::string



        Gets the basename for the specified data type.  

        Most users will not need this functionality.  

        Parameters
        ----------
        * `data_type` :  
            Specifies the data type.  

        Returns
        -------
        the basename for the specified data type  

        See also: set_basename_for_data_type  

        """
        return _moduleconnectorwrapper.PyDataRecorder_get_basename_for_data_type(self, data_type)


    def clear_basename_for_data_types(self, data_types: 'XeThru::DataTypes') -> "void":
        """
        clear_basename_for_data_types(PyDataRecorder self, XeThru::DataTypes data_types)



        Resets the basename(s) to default value(s) for the specified data type(s).  

        Most users will not need this functionality.  

        Parameters
        ----------
        * `data_types` :  
            DataTypes is a bitmask that consists of a combination of DataType flags.
            These flags can be combined with the bitwise OR operator (|). For example:
            BasebandIqData | SleepData. A convenience value AllDataTypes can also be
            specified.  

        See also: set_basename_for_data_type  

        """
        return _moduleconnectorwrapper.PyDataRecorder_clear_basename_for_data_types(self, data_types)


    def get_recording_directory(self, *args) -> "std::string":
        """
        get_recording_directory(PyDataRecorder self, std::string const & session_id) -> std::string
        get_recording_directory(PyDataRecorder self, uint32_t data_type) -> std::string



        Gets the output folder for the specified data type.  

        The folder is relative to the directory specified in start_recording.  

        Parameters
        ----------
        * `session_id` :  
            Specifies the data type.  

        Returns
        -------
        the output folder if a recording for the given data type is active, otherwise
        returns an empty string.  

        See also: is_recording  

        """
        return _moduleconnectorwrapper.PyDataRecorder_get_recording_directory(self, *args)


    def data_type_to_string(data_type: 'uint32_t') -> "std::string":
        """
        data_type_to_string(uint32_t data_type) -> std::string



        Convenience method for converting data type to human readable string
        representation.  

        Parameters
        ----------
        * `data_type` :  

        Returns
        -------
        the string representation of the specified data type  

        """
        return _moduleconnectorwrapper.PyDataRecorder_data_type_to_string(data_type)

    if _newclass:
        data_type_to_string = staticmethod(data_type_to_string)
    __swig_getmethods__["data_type_to_string"] = lambda x: data_type_to_string

    def subscribe_to_file_available(self, *args) -> "int":
        """
        subscribe_to_file_available(PyDataRecorder self, XeThru::DataTypes data_types, XeThru::PyDataRecorder::FileAvailableCallback const & callback) -> int
        subscribe_to_file_available(PyDataRecorder self, uint32_t data_type, PyObject * callback) -> int



        Subscribes to notifications when a recorded file for a data type is available.  

        The callback is triggered when a new file is stored on disk, i.e. when module
        connector is done with the file and no longer will perform I/O operations on it.
        This usually triggers when recording is stopped or as a result of file
        splitting. In either case module connector will no longer hold any reference to
        the file.  

        Declare a standard function:  

        @snippet record.py Callback declare  

        Then construct the callback and pass as parameter:  

        @snippet record.py Callback subscribe  

        Parameters
        ----------
        * `data_types` :  
            DataTypes is a bitmask that consists of a combination of DataType flags.
            These flags can be combined with the bitwise OR operator (|). For example:
            BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can
            also be specified.  
        * `callback` :  
            Specifies the function to be called when a recorded file is available.  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: start_recording, unsubscribe_to_file_available, FileAvailableCallback  

        """
        return _moduleconnectorwrapper.PyDataRecorder_subscribe_to_file_available(self, *args)


    def subscribe_to_meta_file_available(self, *args) -> "int":
        """
        subscribe_to_meta_file_available(PyDataRecorder self, XeThru::PyDataRecorder::MetaFileAvailableCallback const & callback) -> int
        subscribe_to_meta_file_available(PyDataRecorder self, PyObject * callback) -> int



        Subscribes to notifications when a meta file is available.  

        The callback is triggered when a new meta file is stored on disk, i.e. when
        module connector is done with the file and no longer perform I/O operations on
        it. This usually triggers when recording is stopped or as a result of
        file/directory splitting. In either case module connector will no longer hold
        any reference to the file.  

        The meta file contains detailed information about a particular recording
        session. For example which data types and files were written during the session.
        This information is possible to extract via *DataReader* and allows for
        convenient readback of data from disk. The meta file is only intended for use
        with *DataReader*.  

        Declare a standard function:  

        @snippet record.py Callback meta declare  

        Then construct the callback and pass as parameter:  

        @snippet record.py Callback meta subscribe  

        Parameters
        ----------
        * `callback` :  
            Specifies the function to be called when a meta file is available. For
            example: void on_meta_file_available(const std::string &session_id, const
            std::string &filename)  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: DataReader, start_recording, unsubscribe_to_meta_file_available,
            subscribe_to_file_available  

        """
        return _moduleconnectorwrapper.PyDataRecorder_subscribe_to_meta_file_available(self, *args)


    def set_error_callback(self, *args) -> "void":
        """
        set_error_callback(PyDataRecorder self, XeThru::PyDataRecorder::RecordingErrorCallback callback)
        set_error_callback(PyDataRecorder self, PyObject * callback)



        Supply a function that will be called if an error occurs during recording.  

        Call this method with nullptr as argument to clear the callback.  

        """
        return _moduleconnectorwrapper.PyDataRecorder_set_error_callback(self, *args)

PyDataRecorder_swigregister = _moduleconnectorwrapper.PyDataRecorder_swigregister
PyDataRecorder_swigregister(PyDataRecorder)

def PyDataRecorder_data_type_to_string(data_type: 'uint32_t') -> "std::string":
    """
    PyDataRecorder_data_type_to_string(uint32_t data_type) -> std::string



    Convenience method for converting data type to human readable string
    representation.  

    Parameters
    ----------
    * `data_type` :  

    Returns
    -------
    the string representation of the specified data type  

    """
    return _moduleconnectorwrapper.PyDataRecorder_data_type_to_string(data_type)

class PyDataReader(_object):
    """


    The PyDataReader class allows reading of xethru data records from a recording.  

    The PyDataReader class is a high level reader class. It can be used to read all
    data records stored on disk by the *DataRecorder* class. From the user's point
    of view the recording appears as one big file even if the recording may contain
    several files and folders on disk.  

    Data returned from this class is always aligned on complete data records as
    specified by the Xethru File Formats document for a given DataType.  

    @snippet read_recording.py Typical usage  

    note: Use *xethru_recording_meta.dat* as input argument to open. This file
        contains all required information for a particular recording.  

    See also: PyDataRecorder  

    C++ includes: PyDataReader.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyDataReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyDataReader, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(XeThru::PyDataReader self) -> PyDataReader



        Constructs reader.  

        """
        this = _moduleconnectorwrapper.new_PyDataReader()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyDataReader
    __del__ = lambda self: None

    def open(self, meta_filename: 'std::string const &', depth: 'int'=-1) -> "int":
        """
        open(PyDataReader self, std::string const & meta_filename, int depth=-1) -> int
        open(PyDataReader self, std::string const & meta_filename) -> int



        Opens a recording specified by the given meta filename.  

        One recording may contain several meta files, for example as a result of
        file/directory splitting. The meta file contains information about which files
        and data types were written to disk during a recording session. Common for all
        use cases is that *xethru_recording_meta.dat* is always present in the output
        folder generated by *DataRecorder*. Use that file as input argument to this
        function.  

        Parameters
        ----------
        * `meta_filename` :  
            Specifies which recording (*xethru_recording_meta.dat*) to open  
        * `depth` :  
            Specifies the number of meta files to open in 'chained mode'. By default,
            this parameter is -1 (automatically open all files, i.e. the entire
            recording).  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: read_record  

        """
        return _moduleconnectorwrapper.PyDataReader_open(self, meta_filename, depth)


    def is_open(self) -> "bool":
        """
        is_open(PyDataReader self) -> bool



        Returns
        -------
        true if the recording is successfully opened, otherwise returns false  

        See also: open  

        """
        return _moduleconnectorwrapper.PyDataReader_is_open(self)


    def close(self) -> "void":
        """
        close(PyDataReader self)



        Closes all meta files and data files opened by this class.  

        See also: open  

        """
        return _moduleconnectorwrapper.PyDataReader_close(self)


    def at_end(self) -> "bool":
        """
        at_end(PyDataReader self) -> bool



        Returns
        -------
        true if no more data records is available for reading, otherwise returns false.  

        See also: open, read_record  

        """
        return _moduleconnectorwrapper.PyDataReader_at_end(self)


    def read_record(self) -> "XeThru::DataRecord":
        """
        read_record(PyDataReader self) -> DataRecord



        Reads all bytes from a data record on disk and returns the DataRecord.  

        This is a convenience method that ensures all bytes from a record is read.  

        This method has no way of reporting error, however *DataRecord::is_valid* is set
        to true on success; otherwise set to false.  

        Returns
        -------
        the DataRecord.  

        See also: at_end, set_filter  

        """
        return _moduleconnectorwrapper.PyDataReader_read_record(self)


    def peek_record(self) -> "XeThru::DataRecord":
        """
        peek_record(PyDataReader self) -> DataRecord



        Reads all bytes from a data record on disk and returns the DataRecord without
        side effects (i.e.  

        if you call read after peek it will return the same data).  

        This is a convenience method that ensures all bytes from a record is read.  

        This method has no way of reporting error, however *DataRecord::is_valid* is set
        to true on success; otherwise set to false.  

        Returns
        -------
        the DataRecord.  

        See also: read_record, at_end, set_filter  

        """
        return _moduleconnectorwrapper.PyDataReader_peek_record(self)


    def seek_ms(self, position: 'int64_t') -> "int":
        """
        seek_ms(PyDataReader self, int64_t position) -> int



        Sets the current position as specified.  

        Parameters
        ----------
        * `position` :  
            Specifies the position as number of milliseconds.  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: seek_byte, get_duration, at_end  

        """
        return _moduleconnectorwrapper.PyDataReader_seek_ms(self, position)


    def seek_byte(self, position: 'int64_t') -> "int":
        """
        seek_byte(PyDataReader self, int64_t position) -> int



        Sets the current position as specified.  

        Parameters
        ----------
        * `position` :  
            Specifies the position as number of bytes.  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: seek_ms, get_size, at_end  

        """
        return _moduleconnectorwrapper.PyDataReader_seek_byte(self, position)


    def set_filter(self, data_types: 'uint32_t') -> "int":
        """
        set_filter(PyDataReader self, uint32_t data_types) -> int



        Sets the filter used by read_record and peek_record.  

        The filter is used to specify the kind of data records returned by read_record
        and peek_record.  

        By default, the filter is set to all data types.  

        Parameters
        ----------
        * `data_types` :  
            Specifies the filter as a bitmask that consists of a combination of DataType
            flags. These flags can be combined with the bitwise OR operator (|). For
            example: BasebandIqDataType | SleepDataType. A convenience value
            AllDataTypes can also be specified.  

        Returns
        -------
        0 success, otherwise returns 1  

        See also: read_record, peek_record  

        """
        return _moduleconnectorwrapper.PyDataReader_set_filter(self, data_types)


    def get_filter(self) -> "uint32_t":
        """
        get_filter(PyDataReader self) -> uint32_t



        Returns
        -------
        the filter used by read_record and peek_record. By default this value is all
        data types.  

        See also: set_filter  

        """
        return _moduleconnectorwrapper.PyDataReader_get_filter(self)


    def get_start_epoch(self) -> "int64_t":
        """
        get_start_epoch(PyDataReader self) -> int64_t



        Returns
        -------
        the start date/time for the recording as number of milliseconds since
        1970.01.01.  

        See also: get_size  

        """
        return _moduleconnectorwrapper.PyDataReader_get_start_epoch(self)


    def get_duration(self) -> "int64_t":
        """
        get_duration(PyDataReader self) -> int64_t



        Returns
        -------
        the total duration of the recording as milliseconds.  

        See also: get_start_epoch  

        """
        return _moduleconnectorwrapper.PyDataReader_get_duration(self)


    def get_size(self) -> "int64_t":
        """
        get_size(PyDataReader self) -> int64_t



        Returns
        -------
        the total size of the recording as number of bytes.  

        """
        return _moduleconnectorwrapper.PyDataReader_get_size(self)


    def get_data_types(self) -> "uint32_t":
        """
        get_data_types(PyDataReader self) -> uint32_t



        This function returns a bitmask of all data types included in the recording.  

        The bitmask is an OR combination of DataType flags. For example:
        BasebandIqDataType | SleepDataType.  

        Returns
        -------
        a bitmask of all data types included in the recording.  

        """
        return _moduleconnectorwrapper.PyDataReader_get_data_types(self)


    def get_max_record_size(self) -> "uint32_t":
        """
        get_max_record_size(PyDataReader self) -> uint32_t



        Returns
        -------
        the number of bytes of the largest record on disk included in the recording.  

        See also: read_record  

        """
        return _moduleconnectorwrapper.PyDataReader_get_max_record_size(self)


    def get_session_id(self) -> "std::string":
        """
        get_session_id(PyDataReader self) -> std::string



        Returns
        -------
        the session id for the recording.  

        See also: RecordingOptions::set_session_id  

        """
        return _moduleconnectorwrapper.PyDataReader_get_session_id(self)

PyDataReader_swigregister = _moduleconnectorwrapper.PyDataReader_swigregister
PyDataReader_swigregister(PyDataReader)

class PyDataPlayer(_object):
    """


    The DataPlayer class allows playback of telegrams / binary packets from a
    recording generated by PyDataRecorder.  

    The DataPlayer class is a high level data playback class. It provides the user
    with the ability to playback recorded data as if it was coming from a physical
    device. So rather than initialising PythonModuleConnector with a physical device
    (serial port), it is possible to construct PythonModuleConnector with a
    DataPlayer object and receive telegrams / binary packets as one would normally
    receive from a physical XeThru device. For example, CSV data on disk is
    converted back to its original telegram / binary format before it is dispatched
    via ModuleConnector.  

    Moreover, it is possible to control the playback via functions such as play,
    pause, stop, set_playback_rate, set_filter.  

    @snippet read_recording.py Typical usage  

    This class uses the PyDataReader class to read records from disk before it
    converts them into telegrams / binary packets.  

    See also: PythonModuleConnector, PyDataRecorder, PyDataReader  

    C++ includes: PyDataPlayer.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyDataPlayer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyDataPlayer, name)
    __repr__ = _swig_repr

    def __init__(self, meta_filename: 'std::string const &', depth: 'int'=-1):
        """
        __init__(XeThru::PyDataPlayer self, std::string const & meta_filename, int depth=-1) -> PyDataPlayer
        __init__(XeThru::PyDataPlayer self, std::string const & meta_filename) -> PyDataPlayer



        Constructs the player and opens the recording specified by the given meta
        filename.  

        One recording may contain several meta files, for example as a result of
        file/directory splitting. The meta file contains information about which files
        and data types were written to disk during a recording session. Common for all
        use cases is that *xethru_recording_meta.dat* is always present in the output
        folder generated by *DataRecorder*. Use that file as input argument to this
        constructor.  

        Parameters
        ----------
        * `meta_filename` :  
            Specifies which recording (*xethru_recording_meta.dat*) to open.  
        * `depth` :  
            Specifies the number of meta files to open in 'chained mode'. By default,
            this parameter is -1 (automatically open all files, i.e. the entire
            recording).  

        Constructor throws an runtime exception if the recording could not be opened.  

        """
        this = _moduleconnectorwrapper.new_PyDataPlayer(meta_filename, depth)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyDataPlayer
    __del__ = lambda self: None

    def play(self) -> "void":
        """
        play(PyDataPlayer self)



        Start or resume playback.  

        Convenience function, equivalent to set_state(DataPlayer::PlayingState).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_play(self)


    def pause(self) -> "void":
        """
        pause(PyDataPlayer self)



        Pause playback.  

        Convenience function, equivalent to set_state(DataPlayer::PausedState).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_pause(self)


    def stop(self) -> "void":
        """
        stop(PyDataPlayer self)



        Stop playback and reset the play position to the beginning.  

        Convenience function, equivalent to set_state(DataPlayer::StoppedState).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_stop(self)


    def set_filter(self, data_types: 'uint32_t') -> "int":
        """
        set_filter(PyDataPlayer self, uint32_t data_types) -> int



        Specifies which data types to play.  

        By default, the filter is set to all data types.  

        Parameters
        ----------
        * `data_types` :  
            Specifies the filter as a bitmask that consists of a combination of DataType
            flags. These flags can be combined with the bitwise OR operator (|). For
            example: BasebandIqDataType | SleepDataType. A convenience value
            AllDataTypes can also be specified.  

        Returns
        -------
        0 success, otherwise returns 1  

        See also: play  

        """
        return _moduleconnectorwrapper.PyDataPlayer_set_filter(self, data_types)


    def get_filter(self) -> "uint32_t":
        """
        get_filter(PyDataPlayer self) -> uint32_t



        Returns
        -------
        the filter used to specify which data types to play. By default this value is
        all data types.  

        See also: set_filter  

        """
        return _moduleconnectorwrapper.PyDataPlayer_get_filter(self)


    def set_playback_rate(self, rate: 'float') -> "void":
        """
        set_playback_rate(PyDataPlayer self, float rate)



        Sets the playback rate specified as a multiplier.  

        By default, this value is 1.0 indicating that the player is playing at the
        standard pace. Values higher than 1.0 will increase the pace, whereas a lower
        value will decrease the pace. Values less than zero indicate the player should
        play as fast as possible. Value zero is essentially the same as paused state.  

        Parameters
        ----------
        * `rate` :  
            Specifies the multiplier for the playback rate.  

        See also: play  

        """
        return _moduleconnectorwrapper.PyDataPlayer_set_playback_rate(self, rate)


    def get_playback_rate(self) -> "float":
        """
        get_playback_rate(PyDataPlayer self) -> float



        Returns
        -------
        the multiplayer used for the playback rate. By default, this value is 1.0.  

        See also: set_playback_rate  

        """
        return _moduleconnectorwrapper.PyDataPlayer_get_playback_rate(self)


    def set_loop_mode_enabled(self, enabled: 'bool') -> "void":
        """
        set_loop_mode_enabled(PyDataPlayer self, bool enabled)



        Enables or disables loop mode as specified.  

        When loop mode is enabled the, the player's position is reset to the beginning
        when the player reaches the end. This allows for playback forever.  

        Parameters
        ----------
        * `enabled` :  
            Specifies if loop mode is enabled or disabled. By default, loop mode is
            disabled (i.e. false).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_set_loop_mode_enabled(self, enabled)


    def get_loop_mode_enabled(self) -> "bool":
        """
        get_loop_mode_enabled(PyDataPlayer self) -> bool



        Returns
        -------
        true if loop mode is enabled, otherwise returns false. By default, this value is
        false.  

        See also: set_loop_mode_enabled  

        """
        return _moduleconnectorwrapper.PyDataPlayer_get_loop_mode_enabled(self)


    def set_position(self, position: 'int64_t') -> "int":
        """
        set_position(PyDataPlayer self, int64_t position) -> int



        Sets the current position (ms) as specified.  

        The value must be in range [0, get_duration()].  

        Parameters
        ----------
        * `position` :  
            Specifies the position as number of milliseconds (ms).  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: get_duration  

        """
        return _moduleconnectorwrapper.PyDataPlayer_set_position(self, position)


    def get_position(self) -> "int64_t":
        """
        get_position(PyDataPlayer self) -> int64_t



        Returns
        -------
        the player's current position specified as number of milliseconds (ms).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_get_position(self)


    def get_duration(self) -> "int64_t":
        """
        get_duration(PyDataPlayer self) -> int64_t



        Returns
        -------
        the total duration of the recording specified as number of milliseconds (ms).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_get_duration(self)


    def meta_filename(self) -> "std::string":
        """
        meta_filename(PyDataPlayer self) -> std::string



        Returns
        -------
        the meta filename used when constructing this class.  

        """
        return _moduleconnectorwrapper.PyDataPlayer_meta_filename(self)

PyDataPlayer_swigregister = _moduleconnectorwrapper.PyDataPlayer_swigregister
PyDataPlayer_swigregister(PyDataPlayer)


_moduleconnectorwrapper.DEPRECATED_XTS_SPR_APPDATA_FAST_swigconstant(_moduleconnectorwrapper)
DEPRECATED_XTS_SPR_APPDATA_FAST = _moduleconnectorwrapper.DEPRECATED_XTS_SPR_APPDATA_FAST

_moduleconnectorwrapper.XTS_DEF_ENTER_BOOTLOADER_KEY_swigconstant(_moduleconnectorwrapper)
XTS_DEF_ENTER_BOOTLOADER_KEY = _moduleconnectorwrapper.XTS_DEF_ENTER_BOOTLOADER_KEY

_moduleconnectorwrapper.XTS_DEF_PINGVAL_swigconstant(_moduleconnectorwrapper)
XTS_DEF_PINGVAL = _moduleconnectorwrapper.XTS_DEF_PINGVAL

_moduleconnectorwrapper.XTS_DEF_PONGVAL_READY_swigconstant(_moduleconnectorwrapper)
XTS_DEF_PONGVAL_READY = _moduleconnectorwrapper.XTS_DEF_PONGVAL_READY

_moduleconnectorwrapper.XTS_DEF_PONGVAL_NOTREADY_swigconstant(_moduleconnectorwrapper)
XTS_DEF_PONGVAL_NOTREADY = _moduleconnectorwrapper.XTS_DEF_PONGVAL_NOTREADY

_moduleconnectorwrapper.XTS_DEF_PONGVAL_SAFEMODE_swigconstant(_moduleconnectorwrapper)
XTS_DEF_PONGVAL_SAFEMODE = _moduleconnectorwrapper.XTS_DEF_PONGVAL_SAFEMODE

_moduleconnectorwrapper.XTS_DEF_ENTER_BOOTLOADER_KEY_2_swigconstant(_moduleconnectorwrapper)
XTS_DEF_ENTER_BOOTLOADER_KEY_2 = _moduleconnectorwrapper.XTS_DEF_ENTER_BOOTLOADER_KEY_2

_moduleconnectorwrapper.XTS_SPA_VSDM_GET_STATUS_swigconstant(_moduleconnectorwrapper)
XTS_SPA_VSDM_GET_STATUS = _moduleconnectorwrapper.XTS_SPA_VSDM_GET_STATUS

_moduleconnectorwrapper.XTS_SPA_COMMON_GET_SPECTRUM_swigconstant(_moduleconnectorwrapper)
XTS_SPA_COMMON_GET_SPECTRUM = _moduleconnectorwrapper.XTS_SPA_COMMON_GET_SPECTRUM

_moduleconnectorwrapper.XTS_USER_CONTENTID_COMFIGMSG_swigconstant(_moduleconnectorwrapper)
XTS_USER_CONTENTID_COMFIGMSG = _moduleconnectorwrapper.XTS_USER_CONTENTID_COMFIGMSG

_moduleconnectorwrapper.XTS_USER_CONTENTID_RADARSETTINGS_swigconstant(_moduleconnectorwrapper)
XTS_USER_CONTENTID_RADARSETTINGS = _moduleconnectorwrapper.XTS_USER_CONTENTID_RADARSETTINGS

_moduleconnectorwrapper.XTS_USER_CONTENTID_SYSTEM_STATUS_swigconstant(_moduleconnectorwrapper)
XTS_USER_CONTENTID_SYSTEM_STATUS = _moduleconnectorwrapper.XTS_USER_CONTENTID_SYSTEM_STATUS

_moduleconnectorwrapper.XTS_SPC_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPC_RESERVED = _moduleconnectorwrapper.XTS_SPC_RESERVED

_moduleconnectorwrapper.XTS_SPC_PING_swigconstant(_moduleconnectorwrapper)
XTS_SPC_PING = _moduleconnectorwrapper.XTS_SPC_PING

_moduleconnectorwrapper.XTS_SPC_START_BOOTLOADER_swigconstant(_moduleconnectorwrapper)
XTS_SPC_START_BOOTLOADER = _moduleconnectorwrapper.XTS_SPC_START_BOOTLOADER

_moduleconnectorwrapper.XTS_SPC_APPCOMMAND_swigconstant(_moduleconnectorwrapper)
XTS_SPC_APPCOMMAND = _moduleconnectorwrapper.XTS_SPC_APPCOMMAND

_moduleconnectorwrapper.XTS_SPC_MOD_SETMODE_swigconstant(_moduleconnectorwrapper)
XTS_SPC_MOD_SETMODE = _moduleconnectorwrapper.XTS_SPC_MOD_SETMODE

_moduleconnectorwrapper.XTS_SPC_MOD_LOADAPP_swigconstant(_moduleconnectorwrapper)
XTS_SPC_MOD_LOADAPP = _moduleconnectorwrapper.XTS_SPC_MOD_LOADAPP

_moduleconnectorwrapper.XTS_SPC_MOD_RESET_swigconstant(_moduleconnectorwrapper)
XTS_SPC_MOD_RESET = _moduleconnectorwrapper.XTS_SPC_MOD_RESET

_moduleconnectorwrapper.XTS_SPC_MOD_SETCOM_swigconstant(_moduleconnectorwrapper)
XTS_SPC_MOD_SETCOM = _moduleconnectorwrapper.XTS_SPC_MOD_SETCOM

_moduleconnectorwrapper.XTS_SPC_MOD_SETLEDCONTROL_swigconstant(_moduleconnectorwrapper)
XTS_SPC_MOD_SETLEDCONTROL = _moduleconnectorwrapper.XTS_SPC_MOD_SETLEDCONTROL

_moduleconnectorwrapper.XTS_SPC_MOD_NOISEMAP_swigconstant(_moduleconnectorwrapper)
XTS_SPC_MOD_NOISEMAP = _moduleconnectorwrapper.XTS_SPC_MOD_NOISEMAP

_moduleconnectorwrapper.XTS_SPC_MOD_GETMODE_swigconstant(_moduleconnectorwrapper)
XTS_SPC_MOD_GETMODE = _moduleconnectorwrapper.XTS_SPC_MOD_GETMODE

_moduleconnectorwrapper.XTS_SPC_IOPIN_swigconstant(_moduleconnectorwrapper)
XTS_SPC_IOPIN = _moduleconnectorwrapper.XTS_SPC_IOPIN

_moduleconnectorwrapper.XTS_SPC_OUTPUT_swigconstant(_moduleconnectorwrapper)
XTS_SPC_OUTPUT = _moduleconnectorwrapper.XTS_SPC_OUTPUT

_moduleconnectorwrapper.XTS_SPC_DEBUG_OUTPUT_swigconstant(_moduleconnectorwrapper)
XTS_SPC_DEBUG_OUTPUT = _moduleconnectorwrapper.XTS_SPC_DEBUG_OUTPUT

_moduleconnectorwrapper.XTS_SPC_X4DRIVER_swigconstant(_moduleconnectorwrapper)
XTS_SPC_X4DRIVER = _moduleconnectorwrapper.XTS_SPC_X4DRIVER

_moduleconnectorwrapper.XTS_SPC_DSP_swigconstant(_moduleconnectorwrapper)
XTS_SPC_DSP = _moduleconnectorwrapper.XTS_SPC_DSP

_moduleconnectorwrapper.XTS_SPC_DIR_COMMAND_swigconstant(_moduleconnectorwrapper)
XTS_SPC_DIR_COMMAND = _moduleconnectorwrapper.XTS_SPC_DIR_COMMAND

_moduleconnectorwrapper.XTS_SPC_HIL_swigconstant(_moduleconnectorwrapper)
XTS_SPC_HIL = _moduleconnectorwrapper.XTS_SPC_HIL

_moduleconnectorwrapper.XTS_SPC_DEBUG_LEVEL_swigconstant(_moduleconnectorwrapper)
XTS_SPC_DEBUG_LEVEL = _moduleconnectorwrapper.XTS_SPC_DEBUG_LEVEL

_moduleconnectorwrapper.XTS_SPC_BOOTLOADER_swigconstant(_moduleconnectorwrapper)
XTS_SPC_BOOTLOADER = _moduleconnectorwrapper.XTS_SPC_BOOTLOADER

_moduleconnectorwrapper.XTS_SPCD_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPCD_RESERVED = _moduleconnectorwrapper.XTS_SPCD_RESERVED

_moduleconnectorwrapper.XTS_SPCD_GET_swigconstant(_moduleconnectorwrapper)
XTS_SPCD_GET = _moduleconnectorwrapper.XTS_SPCD_GET

_moduleconnectorwrapper.XTS_SPCD_SET_swigconstant(_moduleconnectorwrapper)
XTS_SPCD_SET = _moduleconnectorwrapper.XTS_SPCD_SET

_moduleconnectorwrapper.XTS_SPCDI_NORMALIZATION_swigconstant(_moduleconnectorwrapper)
XTS_SPCDI_NORMALIZATION = _moduleconnectorwrapper.XTS_SPCDI_NORMALIZATION

_moduleconnectorwrapper.XTS_SPCDI_PHASE_NOISE_CORRECTION_swigconstant(_moduleconnectorwrapper)
XTS_SPCDI_PHASE_NOISE_CORRECTION = _moduleconnectorwrapper.XTS_SPCDI_PHASE_NOISE_CORRECTION

_moduleconnectorwrapper.XTS_SPCDI_DECIMATION_FACTOR_swigconstant(_moduleconnectorwrapper)
XTS_SPCDI_DECIMATION_FACTOR = _moduleconnectorwrapper.XTS_SPCDI_DECIMATION_FACTOR

_moduleconnectorwrapper.XTS_SPCDI_NUMBER_FORMAT_swigconstant(_moduleconnectorwrapper)
XTS_SPCDI_NUMBER_FORMAT = _moduleconnectorwrapper.XTS_SPCDI_NUMBER_FORMAT

_moduleconnectorwrapper.XTS_SPCDI_LEGACY_OUTPUT_swigconstant(_moduleconnectorwrapper)
XTS_SPCDI_LEGACY_OUTPUT = _moduleconnectorwrapper.XTS_SPCDI_LEGACY_OUTPUT

_moduleconnectorwrapper.XTS_SPCA_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPCA_RESERVED = _moduleconnectorwrapper.XTS_SPCA_RESERVED

_moduleconnectorwrapper.XTS_SPCA_SET_swigconstant(_moduleconnectorwrapper)
XTS_SPCA_SET = _moduleconnectorwrapper.XTS_SPCA_SET

_moduleconnectorwrapper.XTS_SPCA_GET_swigconstant(_moduleconnectorwrapper)
XTS_SPCA_GET = _moduleconnectorwrapper.XTS_SPCA_GET

_moduleconnectorwrapper.XTS_SPCA_FACTORY_PRESET_swigconstant(_moduleconnectorwrapper)
XTS_SPCA_FACTORY_PRESET = _moduleconnectorwrapper.XTS_SPCA_FACTORY_PRESET

_moduleconnectorwrapper.XTS_SPCA_STORE_NOISEMAP_swigconstant(_moduleconnectorwrapper)
XTS_SPCA_STORE_NOISEMAP = _moduleconnectorwrapper.XTS_SPCA_STORE_NOISEMAP

_moduleconnectorwrapper.XTS_SPCA_LOAD_NOISEMAP_swigconstant(_moduleconnectorwrapper)
XTS_SPCA_LOAD_NOISEMAP = _moduleconnectorwrapper.XTS_SPCA_LOAD_NOISEMAP

_moduleconnectorwrapper.XTS_SPCA_GET_PARAMETER_FILE_swigconstant(_moduleconnectorwrapper)
XTS_SPCA_GET_PARAMETER_FILE = _moduleconnectorwrapper.XTS_SPCA_GET_PARAMETER_FILE

_moduleconnectorwrapper.XTS_SPCA_DELETE_NOISEMAP_swigconstant(_moduleconnectorwrapper)
XTS_SPCA_DELETE_NOISEMAP = _moduleconnectorwrapper.XTS_SPCA_DELETE_NOISEMAP

_moduleconnectorwrapper.XTS_SPCA_POLL_swigconstant(_moduleconnectorwrapper)
XTS_SPCA_POLL = _moduleconnectorwrapper.XTS_SPCA_POLL

_moduleconnectorwrapper.XTS_SPCB_GET_DEVICE_INFO_swigconstant(_moduleconnectorwrapper)
XTS_SPCB_GET_DEVICE_INFO = _moduleconnectorwrapper.XTS_SPCB_GET_DEVICE_INFO

_moduleconnectorwrapper.XTS_SPCB_WRITE_PAGE_swigconstant(_moduleconnectorwrapper)
XTS_SPCB_WRITE_PAGE = _moduleconnectorwrapper.XTS_SPCB_WRITE_PAGE

_moduleconnectorwrapper.XTS_SPCB_START_APP_swigconstant(_moduleconnectorwrapper)
XTS_SPCB_START_APP = _moduleconnectorwrapper.XTS_SPCB_START_APP

_moduleconnectorwrapper.XTS_SPR_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPR_RESERVED = _moduleconnectorwrapper.XTS_SPR_RESERVED

_moduleconnectorwrapper.XTS_SPR_PONG_swigconstant(_moduleconnectorwrapper)
XTS_SPR_PONG = _moduleconnectorwrapper.XTS_SPR_PONG

_moduleconnectorwrapper.XTS_SPR_ACK_swigconstant(_moduleconnectorwrapper)
XTS_SPR_ACK = _moduleconnectorwrapper.XTS_SPR_ACK

_moduleconnectorwrapper.XTS_SPR_REPLY_swigconstant(_moduleconnectorwrapper)
XTS_SPR_REPLY = _moduleconnectorwrapper.XTS_SPR_REPLY

_moduleconnectorwrapper.XTS_SPR_HIL_swigconstant(_moduleconnectorwrapper)
XTS_SPR_HIL = _moduleconnectorwrapper.XTS_SPR_HIL

_moduleconnectorwrapper.XTS_SPR_ERROR_swigconstant(_moduleconnectorwrapper)
XTS_SPR_ERROR = _moduleconnectorwrapper.XTS_SPR_ERROR

_moduleconnectorwrapper.XTS_SPR_SYSTEM_swigconstant(_moduleconnectorwrapper)
XTS_SPR_SYSTEM = _moduleconnectorwrapper.XTS_SPR_SYSTEM

_moduleconnectorwrapper.XTS_SPR_APPDATA_swigconstant(_moduleconnectorwrapper)
XTS_SPR_APPDATA = _moduleconnectorwrapper.XTS_SPR_APPDATA

_moduleconnectorwrapper.XTS_SPR_DATA_swigconstant(_moduleconnectorwrapper)
XTS_SPR_DATA = _moduleconnectorwrapper.XTS_SPR_DATA

_moduleconnectorwrapper.XTS_SPRE_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPRE_RESERVED = _moduleconnectorwrapper.XTS_SPRE_RESERVED

_moduleconnectorwrapper.XTS_SPRE_NOT_RECOGNIZED_swigconstant(_moduleconnectorwrapper)
XTS_SPRE_NOT_RECOGNIZED = _moduleconnectorwrapper.XTS_SPRE_NOT_RECOGNIZED

_moduleconnectorwrapper.XTS_SPRE_CRC_FAILED_swigconstant(_moduleconnectorwrapper)
XTS_SPRE_CRC_FAILED = _moduleconnectorwrapper.XTS_SPRE_CRC_FAILED

_moduleconnectorwrapper.XTS_SPRE_BUSY_swigconstant(_moduleconnectorwrapper)
XTS_SPRE_BUSY = _moduleconnectorwrapper.XTS_SPRE_BUSY

_moduleconnectorwrapper.XTS_SPRE_APP_INVALID_swigconstant(_moduleconnectorwrapper)
XTS_SPRE_APP_INVALID = _moduleconnectorwrapper.XTS_SPRE_APP_INVALID

_moduleconnectorwrapper.XTS_SPRE_COMMAND_FAILED_swigconstant(_moduleconnectorwrapper)
XTS_SPRE_COMMAND_FAILED = _moduleconnectorwrapper.XTS_SPRE_COMMAND_FAILED

_moduleconnectorwrapper.XTS_SPRE_RESTARTING_swigconstant(_moduleconnectorwrapper)
XTS_SPRE_RESTARTING = _moduleconnectorwrapper.XTS_SPRE_RESTARTING

_moduleconnectorwrapper.XTS_SPRE_USER_swigconstant(_moduleconnectorwrapper)
XTS_SPRE_USER = _moduleconnectorwrapper.XTS_SPRE_USER

_moduleconnectorwrapper.XTS_SPRS_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPRS_RESERVED = _moduleconnectorwrapper.XTS_SPRS_RESERVED

_moduleconnectorwrapper.XTS_SPRS_BOOTING_swigconstant(_moduleconnectorwrapper)
XTS_SPRS_BOOTING = _moduleconnectorwrapper.XTS_SPRS_BOOTING

_moduleconnectorwrapper.XTS_SPRS_READY_swigconstant(_moduleconnectorwrapper)
XTS_SPRS_READY = _moduleconnectorwrapper.XTS_SPRS_READY

_moduleconnectorwrapper.XTS_SDC_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RESERVED = _moduleconnectorwrapper.XTS_SDC_RESERVED

_moduleconnectorwrapper.XTS_SDC_RADAR_FIRST_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADAR_FIRST = _moduleconnectorwrapper.XTS_SDC_RADAR_FIRST

_moduleconnectorwrapper.XTS_SDC_RADLIB_EXECUTE_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_EXECUTE = _moduleconnectorwrapper.XTS_SDC_RADLIB_EXECUTE

_moduleconnectorwrapper.XTS_SDC_RADLIB_SETVARINT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_SETVARINT = _moduleconnectorwrapper.XTS_SDC_RADLIB_SETVARINT

_moduleconnectorwrapper.XTS_SDC_RADLIB_GETVARINT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_GETVARINT = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETVARINT

_moduleconnectorwrapper.XTS_SDC_RADLIB_SETVARFLOAT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_SETVARFLOAT = _moduleconnectorwrapper.XTS_SDC_RADLIB_SETVARFLOAT

_moduleconnectorwrapper.XTS_SDC_RADLIB_GETVARFLOAT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_GETVARFLOAT = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETVARFLOAT

_moduleconnectorwrapper.XTS_SDC_RADLIB_SETREGFIELD_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_SETREGFIELD = _moduleconnectorwrapper.XTS_SDC_RADLIB_SETREGFIELD

_moduleconnectorwrapper.XTS_SDC_RADLIB_GETREGFIELD_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_GETREGFIELD = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETREGFIELD

_moduleconnectorwrapper.XTS_SDC_RADLIB_GETFRAMEFLOAT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_GETFRAMEFLOAT = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETFRAMEFLOAT

_moduleconnectorwrapper.XTS_SDC_RADLIB_GETFRAMERAW_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_GETFRAMERAW = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETFRAMERAW

_moduleconnectorwrapper.XTS_SDC_RADLIB_GETCHIPID_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_GETCHIPID = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETCHIPID

_moduleconnectorwrapper.XTS_SDC_RADLIB_TIMINGMEASUREMENT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADLIB_TIMINGMEASUREMENT = _moduleconnectorwrapper.XTS_SDC_RADLIB_TIMINGMEASUREMENT

_moduleconnectorwrapper.XTS_SDC_RADHW_RESET_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADHW_RESET = _moduleconnectorwrapper.XTS_SDC_RADHW_RESET

_moduleconnectorwrapper.XTS_SDC_RADHW_CLOCK_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADHW_CLOCK = _moduleconnectorwrapper.XTS_SDC_RADHW_CLOCK

_moduleconnectorwrapper.XTS_SDC_RADMSC_DOFRAMETOFLASH_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADMSC_DOFRAMETOFLASH = _moduleconnectorwrapper.XTS_SDC_RADMSC_DOFRAMETOFLASH

_moduleconnectorwrapper.XTS_SDC_RADAR_LAST_swigconstant(_moduleconnectorwrapper)
XTS_SDC_RADAR_LAST = _moduleconnectorwrapper.XTS_SDC_RADAR_LAST

_moduleconnectorwrapper.XTS_SDC_SYSTEM_FIRST_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSTEM_FIRST = _moduleconnectorwrapper.XTS_SDC_SYSTEM_FIRST

_moduleconnectorwrapper.XTS_SDC_SYSTEM_TEST_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSTEM_TEST = _moduleconnectorwrapper.XTS_SDC_SYSTEM_TEST

_moduleconnectorwrapper.XTS_SDC_SYSCFG_SETINT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSCFG_SETINT = _moduleconnectorwrapper.XTS_SDC_SYSCFG_SETINT

_moduleconnectorwrapper.XTS_SDC_SYSCFG_SETFLOAT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSCFG_SETFLOAT = _moduleconnectorwrapper.XTS_SDC_SYSCFG_SETFLOAT

_moduleconnectorwrapper.XTS_SDC_SYSFLASH_GETBLOCK_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSFLASH_GETBLOCK = _moduleconnectorwrapper.XTS_SDC_SYSFLASH_GETBLOCK

_moduleconnectorwrapper.XTS_SDC_SYSFLASH_SETBLOCK_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSFLASH_SETBLOCK = _moduleconnectorwrapper.XTS_SDC_SYSFLASH_SETBLOCK

_moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_VERSION_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSTEM_GET_VERSION = _moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_VERSION

_moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_BUILD_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSTEM_GET_BUILD = _moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_BUILD

_moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_PRODUCT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSTEM_GET_PRODUCT = _moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_PRODUCT

_moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_INFO_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSTEM_GET_INFO = _moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_INFO

_moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_DEBUG_DATA_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSTEM_GET_DEBUG_DATA = _moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_DEBUG_DATA

_moduleconnectorwrapper.XTS_SDC_GET_PARAMETER_FILE_swigconstant(_moduleconnectorwrapper)
XTS_SDC_GET_PARAMETER_FILE = _moduleconnectorwrapper.XTS_SDC_GET_PARAMETER_FILE

_moduleconnectorwrapper.XTS_SDC_GET_CRASH_DUMP_LENGTH_swigconstant(_moduleconnectorwrapper)
XTS_SDC_GET_CRASH_DUMP_LENGTH = _moduleconnectorwrapper.XTS_SDC_GET_CRASH_DUMP_LENGTH

_moduleconnectorwrapper.XTS_SDC_CLEAR_CRASH_DUMP_swigconstant(_moduleconnectorwrapper)
XTS_SDC_CLEAR_CRASH_DUMP = _moduleconnectorwrapper.XTS_SDC_CLEAR_CRASH_DUMP

_moduleconnectorwrapper.XTS_SDC_GET_CRASH_DUMP_swigconstant(_moduleconnectorwrapper)
XTS_SDC_GET_CRASH_DUMP = _moduleconnectorwrapper.XTS_SDC_GET_CRASH_DUMP

_moduleconnectorwrapper.XTS_SDC_SEARCH_FILE_TYPE_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SEARCH_FILE_TYPE = _moduleconnectorwrapper.XTS_SDC_SEARCH_FILE_TYPE

_moduleconnectorwrapper.XTS_SDC_FIND_ALL_FILES_swigconstant(_moduleconnectorwrapper)
XTS_SDC_FIND_ALL_FILES = _moduleconnectorwrapper.XTS_SDC_FIND_ALL_FILES

_moduleconnectorwrapper.XTS_SDC_CREATE_NEW_FILE_swigconstant(_moduleconnectorwrapper)
XTS_SDC_CREATE_NEW_FILE = _moduleconnectorwrapper.XTS_SDC_CREATE_NEW_FILE

_moduleconnectorwrapper.XTS_SDC_SET_FILE_DATA_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SET_FILE_DATA = _moduleconnectorwrapper.XTS_SDC_SET_FILE_DATA

_moduleconnectorwrapper.XTS_SDC_CLOSE_FILE_swigconstant(_moduleconnectorwrapper)
XTS_SDC_CLOSE_FILE = _moduleconnectorwrapper.XTS_SDC_CLOSE_FILE

_moduleconnectorwrapper.XTS_SDC_GET_FILE_LENGTH_swigconstant(_moduleconnectorwrapper)
XTS_SDC_GET_FILE_LENGTH = _moduleconnectorwrapper.XTS_SDC_GET_FILE_LENGTH

_moduleconnectorwrapper.XTS_SDC_DELETE_FILE_swigconstant(_moduleconnectorwrapper)
XTS_SDC_DELETE_FILE = _moduleconnectorwrapper.XTS_SDC_DELETE_FILE

_moduleconnectorwrapper.XTS_SDC_GET_FILE_DATA_swigconstant(_moduleconnectorwrapper)
XTS_SDC_GET_FILE_DATA = _moduleconnectorwrapper.XTS_SDC_GET_FILE_DATA

_moduleconnectorwrapper.XTS_SDC_OPEN_FILE_swigconstant(_moduleconnectorwrapper)
XTS_SDC_OPEN_FILE = _moduleconnectorwrapper.XTS_SDC_OPEN_FILE

_moduleconnectorwrapper.XTS_SDC_FORMAT_FILESYSTEM_swigconstant(_moduleconnectorwrapper)
XTS_SDC_FORMAT_FILESYSTEM = _moduleconnectorwrapper.XTS_SDC_FORMAT_FILESYSTEM

_moduleconnectorwrapper.XTS_SDC_GET_PROFILEID_swigconstant(_moduleconnectorwrapper)
XTS_SDC_GET_PROFILEID = _moduleconnectorwrapper.XTS_SDC_GET_PROFILEID

_moduleconnectorwrapper.XTS_SDC_INJECT_FRAME_swigconstant(_moduleconnectorwrapper)
XTS_SDC_INJECT_FRAME = _moduleconnectorwrapper.XTS_SDC_INJECT_FRAME

_moduleconnectorwrapper.XTS_SDC_PREPARE_INJECT_FRAME_swigconstant(_moduleconnectorwrapper)
XTS_SDC_PREPARE_INJECT_FRAME = _moduleconnectorwrapper.XTS_SDC_PREPARE_INJECT_FRAME

_moduleconnectorwrapper.XTS_SDC_SYSTEM_LAST_swigconstant(_moduleconnectorwrapper)
XTS_SDC_SYSTEM_LAST = _moduleconnectorwrapper.XTS_SDC_SYSTEM_LAST

_moduleconnectorwrapper.XTS_SDC_APP_FIRST_swigconstant(_moduleconnectorwrapper)
XTS_SDC_APP_FIRST = _moduleconnectorwrapper.XTS_SDC_APP_FIRST

_moduleconnectorwrapper.XTS_SDC_APP_SETFLOAT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_APP_SETFLOAT = _moduleconnectorwrapper.XTS_SDC_APP_SETFLOAT

_moduleconnectorwrapper.XTS_SDC_APP_SETINT_swigconstant(_moduleconnectorwrapper)
XTS_SDC_APP_SETINT = _moduleconnectorwrapper.XTS_SDC_APP_SETINT

_moduleconnectorwrapper.XTS_SDC_APP_LAST_swigconstant(_moduleconnectorwrapper)
XTS_SDC_APP_LAST = _moduleconnectorwrapper.XTS_SDC_APP_LAST

_moduleconnectorwrapper.XTS_SDC_COMM_FIRST_swigconstant(_moduleconnectorwrapper)
XTS_SDC_COMM_FIRST = _moduleconnectorwrapper.XTS_SDC_COMM_FIRST

_moduleconnectorwrapper.XTS_SDC_COMM_SETBAUDRATE_swigconstant(_moduleconnectorwrapper)
XTS_SDC_COMM_SETBAUDRATE = _moduleconnectorwrapper.XTS_SDC_COMM_SETBAUDRATE

_moduleconnectorwrapper.XTS_SDC_COMM_LAST_swigconstant(_moduleconnectorwrapper)
XTS_SDC_COMM_LAST = _moduleconnectorwrapper.XTS_SDC_COMM_LAST

_moduleconnectorwrapper.XTS_SPCIOP_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPCIOP_RESERVED = _moduleconnectorwrapper.XTS_SPCIOP_RESERVED

_moduleconnectorwrapper.XTS_SPCIOP_SETCONTROL_swigconstant(_moduleconnectorwrapper)
XTS_SPCIOP_SETCONTROL = _moduleconnectorwrapper.XTS_SPCIOP_SETCONTROL

_moduleconnectorwrapper.XTS_SPCIOP_GETCONTROL_swigconstant(_moduleconnectorwrapper)
XTS_SPCIOP_GETCONTROL = _moduleconnectorwrapper.XTS_SPCIOP_GETCONTROL

_moduleconnectorwrapper.XTS_SPCIOP_SETVALUE_swigconstant(_moduleconnectorwrapper)
XTS_SPCIOP_SETVALUE = _moduleconnectorwrapper.XTS_SPCIOP_SETVALUE

_moduleconnectorwrapper.XTS_SPCIOP_GETVALUE_swigconstant(_moduleconnectorwrapper)
XTS_SPCIOP_GETVALUE = _moduleconnectorwrapper.XTS_SPCIOP_GETVALUE

_moduleconnectorwrapper.XTS_SPCO_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPCO_RESERVED = _moduleconnectorwrapper.XTS_SPCO_RESERVED

_moduleconnectorwrapper.XTS_SPCO_SETCONTROL_swigconstant(_moduleconnectorwrapper)
XTS_SPCO_SETCONTROL = _moduleconnectorwrapper.XTS_SPCO_SETCONTROL

_moduleconnectorwrapper.XTS_SPCO_GETCONTROL_swigconstant(_moduleconnectorwrapper)
XTS_SPCO_GETCONTROL = _moduleconnectorwrapper.XTS_SPCO_GETCONTROL

_moduleconnectorwrapper.XTS_SPCN_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPCN_RESERVED = _moduleconnectorwrapper.XTS_SPCN_RESERVED

_moduleconnectorwrapper.XTS_SPCN_SETCONTROL_swigconstant(_moduleconnectorwrapper)
XTS_SPCN_SETCONTROL = _moduleconnectorwrapper.XTS_SPCN_SETCONTROL

_moduleconnectorwrapper.XTS_SPCN_GETCONTROL_swigconstant(_moduleconnectorwrapper)
XTS_SPCN_GETCONTROL = _moduleconnectorwrapper.XTS_SPCN_GETCONTROL

_moduleconnectorwrapper.XTS_SPCN_SETPERIODICSTORE_swigconstant(_moduleconnectorwrapper)
XTS_SPCN_SETPERIODICSTORE = _moduleconnectorwrapper.XTS_SPCN_SETPERIODICSTORE

_moduleconnectorwrapper.XTS_SPCN_GETPERIODICSTORE_swigconstant(_moduleconnectorwrapper)
XTS_SPCN_GETPERIODICSTORE = _moduleconnectorwrapper.XTS_SPCN_GETPERIODICSTORE

_moduleconnectorwrapper.XTS_SPCX_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPCX_RESERVED = _moduleconnectorwrapper.XTS_SPCX_RESERVED

_moduleconnectorwrapper.XTS_SPCX_SET_swigconstant(_moduleconnectorwrapper)
XTS_SPCX_SET = _moduleconnectorwrapper.XTS_SPCX_SET

_moduleconnectorwrapper.XTS_SPCX_GET_swigconstant(_moduleconnectorwrapper)
XTS_SPCX_GET = _moduleconnectorwrapper.XTS_SPCX_GET

_moduleconnectorwrapper.XTS_SPCX_WRITE_swigconstant(_moduleconnectorwrapper)
XTS_SPCX_WRITE = _moduleconnectorwrapper.XTS_SPCX_WRITE

_moduleconnectorwrapper.XTS_SPCX_READ_swigconstant(_moduleconnectorwrapper)
XTS_SPCX_READ = _moduleconnectorwrapper.XTS_SPCX_READ

_moduleconnectorwrapper.XTS_SPCX_I2C_WRITE_swigconstant(_moduleconnectorwrapper)
XTS_SPCX_I2C_WRITE = _moduleconnectorwrapper.XTS_SPCX_I2C_WRITE

_moduleconnectorwrapper.XTS_SPCX_I2C_READ_swigconstant(_moduleconnectorwrapper)
XTS_SPCX_I2C_READ = _moduleconnectorwrapper.XTS_SPCX_I2C_READ

_moduleconnectorwrapper.XTS_SPCX_INIT_swigconstant(_moduleconnectorwrapper)
XTS_SPCX_INIT = _moduleconnectorwrapper.XTS_SPCX_INIT

_moduleconnectorwrapper.XTS_SPCXI_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_RESERVED = _moduleconnectorwrapper.XTS_SPCXI_RESERVED

_moduleconnectorwrapper.XTS_SPCXI_FPS_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_FPS = _moduleconnectorwrapper.XTS_SPCXI_FPS

_moduleconnectorwrapper.XTS_SPCXI_PULSESPERSTEP_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_PULSESPERSTEP = _moduleconnectorwrapper.XTS_SPCXI_PULSESPERSTEP

_moduleconnectorwrapper.XTS_SPCXI_ITERATIONS_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_ITERATIONS = _moduleconnectorwrapper.XTS_SPCXI_ITERATIONS

_moduleconnectorwrapper.XTS_SPCXI_DOWNCONVERSION_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_DOWNCONVERSION = _moduleconnectorwrapper.XTS_SPCXI_DOWNCONVERSION

_moduleconnectorwrapper.XTS_SPCXI_FRAMEAREA_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_FRAMEAREA = _moduleconnectorwrapper.XTS_SPCXI_FRAMEAREA

_moduleconnectorwrapper.XTS_SPCXI_DACSTEP_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_DACSTEP = _moduleconnectorwrapper.XTS_SPCXI_DACSTEP

_moduleconnectorwrapper.XTS_SPCXI_DACMIN_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_DACMIN = _moduleconnectorwrapper.XTS_SPCXI_DACMIN

_moduleconnectorwrapper.XTS_SPCXI_DACMAX_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_DACMAX = _moduleconnectorwrapper.XTS_SPCXI_DACMAX

_moduleconnectorwrapper.XTS_SPCXI_FRAMEAREAOFFSET_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_FRAMEAREAOFFSET = _moduleconnectorwrapper.XTS_SPCXI_FRAMEAREAOFFSET

_moduleconnectorwrapper.XTS_SPCXI_ENABLE_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_ENABLE = _moduleconnectorwrapper.XTS_SPCXI_ENABLE

_moduleconnectorwrapper.XTS_SPCXI_TXCENTERFREQUENCY_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_TXCENTERFREQUENCY = _moduleconnectorwrapper.XTS_SPCXI_TXCENTERFREQUENCY

_moduleconnectorwrapper.XTS_SPCXI_TXPOWER_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_TXPOWER = _moduleconnectorwrapper.XTS_SPCXI_TXPOWER

_moduleconnectorwrapper.XTS_SPCXI_SPIREGISTER_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_SPIREGISTER = _moduleconnectorwrapper.XTS_SPCXI_SPIREGISTER

_moduleconnectorwrapper.XTS_SPCXI_PIFREGISTER_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_PIFREGISTER = _moduleconnectorwrapper.XTS_SPCXI_PIFREGISTER

_moduleconnectorwrapper.XTS_SPCXI_XIFREGISTER_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_XIFREGISTER = _moduleconnectorwrapper.XTS_SPCXI_XIFREGISTER

_moduleconnectorwrapper.XTS_SPCXI_PRFDIV_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_PRFDIV = _moduleconnectorwrapper.XTS_SPCXI_PRFDIV

_moduleconnectorwrapper.XTS_SPCXI_FRAMEBINCOUNT_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_FRAMEBINCOUNT = _moduleconnectorwrapper.XTS_SPCXI_FRAMEBINCOUNT

_moduleconnectorwrapper.XTS_SPCXI_I2CREGISTER_swigconstant(_moduleconnectorwrapper)
XTS_SPCXI_I2CREGISTER = _moduleconnectorwrapper.XTS_SPCXI_I2CREGISTER

_moduleconnectorwrapper.XTS_SPH_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SPH_RESERVED = _moduleconnectorwrapper.XTS_SPH_RESERVED

_moduleconnectorwrapper.XTS_SPH_CMD_CONTINUE_swigconstant(_moduleconnectorwrapper)
XTS_SPH_CMD_CONTINUE = _moduleconnectorwrapper.XTS_SPH_CMD_CONTINUE

_moduleconnectorwrapper.XTS_SPH_SEND_FLOAT_swigconstant(_moduleconnectorwrapper)
XTS_SPH_SEND_FLOAT = _moduleconnectorwrapper.XTS_SPH_SEND_FLOAT

_moduleconnectorwrapper.XTS_SSCR_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_RESERVED = _moduleconnectorwrapper.XTS_SSCR_RESERVED

_moduleconnectorwrapper.XTS_SSCR_PULSESPERSTEP_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_PULSESPERSTEP = _moduleconnectorwrapper.XTS_SSCR_PULSESPERSTEP

_moduleconnectorwrapper.XTS_SSCR_ITERATIONS_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_ITERATIONS = _moduleconnectorwrapper.XTS_SSCR_ITERATIONS

_moduleconnectorwrapper.XTS_SSCR_DACSTEP_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_DACSTEP = _moduleconnectorwrapper.XTS_SSCR_DACSTEP

_moduleconnectorwrapper.XTS_SSCR_DACMIN_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_DACMIN = _moduleconnectorwrapper.XTS_SSCR_DACMIN

_moduleconnectorwrapper.XTS_SSCR_DACMAX_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_DACMAX = _moduleconnectorwrapper.XTS_SSCR_DACMAX

_moduleconnectorwrapper.XTS_SSCR_SAMPLEDELAY_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_SAMPLEDELAY = _moduleconnectorwrapper.XTS_SSCR_SAMPLEDELAY

_moduleconnectorwrapper.XTS_SSCR_PGSELECT_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_PGSELECT = _moduleconnectorwrapper.XTS_SSCR_PGSELECT

_moduleconnectorwrapper.XTS_SSCR_MCLKDIV_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_MCLKDIV = _moduleconnectorwrapper.XTS_SSCR_MCLKDIV

_moduleconnectorwrapper.XTS_SSCR_STAGGEREDPRFENABLE_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_STAGGEREDPRFENABLE = _moduleconnectorwrapper.XTS_SSCR_STAGGEREDPRFENABLE

_moduleconnectorwrapper.XTS_SSCR_DACAUTO_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_DACAUTO = _moduleconnectorwrapper.XTS_SSCR_DACAUTO

_moduleconnectorwrapper.XTS_SSCR_FPS_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_FPS = _moduleconnectorwrapper.XTS_SSCR_FPS

_moduleconnectorwrapper.XTS_SSCR_FRAMESTITCH_swigconstant(_moduleconnectorwrapper)
XTS_SSCR_FRAMESTITCH = _moduleconnectorwrapper.XTS_SSCR_FRAMESTITCH

_moduleconnectorwrapper.XTS_SACR_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SACR_RESERVED = _moduleconnectorwrapper.XTS_SACR_RESERVED

_moduleconnectorwrapper.XTS_SACR_OUTPUTBASEBAND_swigconstant(_moduleconnectorwrapper)
XTS_SACR_OUTPUTBASEBAND = _moduleconnectorwrapper.XTS_SACR_OUTPUTBASEBAND

_moduleconnectorwrapper.XTS_SACR_OUTPUTSTATUS_swigconstant(_moduleconnectorwrapper)
XTS_SACR_OUTPUTSTATUS = _moduleconnectorwrapper.XTS_SACR_OUTPUTSTATUS

_moduleconnectorwrapper.XTS_SACR_OUTPUTSTATUSEXT_swigconstant(_moduleconnectorwrapper)
XTS_SACR_OUTPUTSTATUSEXT = _moduleconnectorwrapper.XTS_SACR_OUTPUTSTATUSEXT

_moduleconnectorwrapper.XTS_SACR_OUTPUT_RF_swigconstant(_moduleconnectorwrapper)
XTS_SACR_OUTPUT_RF = _moduleconnectorwrapper.XTS_SACR_OUTPUT_RF

_moduleconnectorwrapper.XTS_SACR_OUTPUT_PULSE_DOPPLER_swigconstant(_moduleconnectorwrapper)
XTS_SACR_OUTPUT_PULSE_DOPPLER = _moduleconnectorwrapper.XTS_SACR_OUTPUT_PULSE_DOPPLER

_moduleconnectorwrapper.XTS_SPRD_NONE_swigconstant(_moduleconnectorwrapper)
XTS_SPRD_NONE = _moduleconnectorwrapper.XTS_SPRD_NONE

_moduleconnectorwrapper.XTS_SPRD_BYTE_swigconstant(_moduleconnectorwrapper)
XTS_SPRD_BYTE = _moduleconnectorwrapper.XTS_SPRD_BYTE

_moduleconnectorwrapper.XTS_SPRD_INT_swigconstant(_moduleconnectorwrapper)
XTS_SPRD_INT = _moduleconnectorwrapper.XTS_SPRD_INT

_moduleconnectorwrapper.XTS_SPRD_FLOAT_swigconstant(_moduleconnectorwrapper)
XTS_SPRD_FLOAT = _moduleconnectorwrapper.XTS_SPRD_FLOAT

_moduleconnectorwrapper.XTS_SPRD_STRING_swigconstant(_moduleconnectorwrapper)
XTS_SPRD_STRING = _moduleconnectorwrapper.XTS_SPRD_STRING

_moduleconnectorwrapper.XTS_SPRD_USER_swigconstant(_moduleconnectorwrapper)
XTS_SPRD_USER = _moduleconnectorwrapper.XTS_SPRD_USER

_moduleconnectorwrapper.XTS_FLAG_START_swigconstant(_moduleconnectorwrapper)
XTS_FLAG_START = _moduleconnectorwrapper.XTS_FLAG_START

_moduleconnectorwrapper.XTS_FLAG_END_swigconstant(_moduleconnectorwrapper)
XTS_FLAG_END = _moduleconnectorwrapper.XTS_FLAG_END

_moduleconnectorwrapper.XTS_FLAG_ESC_swigconstant(_moduleconnectorwrapper)
XTS_FLAG_ESC = _moduleconnectorwrapper.XTS_FLAG_ESC

_moduleconnectorwrapper.XTS_FLAGSEQUENCE_START_NOESCAPE_swigconstant(_moduleconnectorwrapper)
XTS_FLAGSEQUENCE_START_NOESCAPE = _moduleconnectorwrapper.XTS_FLAGSEQUENCE_START_NOESCAPE

_moduleconnectorwrapper.XTS_SSTC_SUCCESS_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_SUCCESS = _moduleconnectorwrapper.XTS_SSTC_SUCCESS

_moduleconnectorwrapper.XTS_SSTC_FAILED_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_FAILED = _moduleconnectorwrapper.XTS_SSTC_FAILED

_moduleconnectorwrapper.XTS_SSTC_NOTIMPLEMENTED_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_NOTIMPLEMENTED = _moduleconnectorwrapper.XTS_SSTC_NOTIMPLEMENTED

_moduleconnectorwrapper.XTS_SSTC_TEST_FIRST_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_FIRST = _moduleconnectorwrapper.XTS_SSTC_TEST_FIRST

_moduleconnectorwrapper.XTS_SSTC_TEST_RESETCOUNT_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_RESETCOUNT = _moduleconnectorwrapper.XTS_SSTC_TEST_RESETCOUNT

_moduleconnectorwrapper.XTS_SSTC_TEST_EXTRAM_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_EXTRAM = _moduleconnectorwrapper.XTS_SSTC_TEST_EXTRAM

_moduleconnectorwrapper.XTS_SSTC_TEST_EXTFLASH_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_EXTFLASH = _moduleconnectorwrapper.XTS_SSTC_TEST_EXTFLASH

_moduleconnectorwrapper.XTS_SSTC_TEST_PMIC_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_PMIC = _moduleconnectorwrapper.XTS_SSTC_TEST_PMIC

_moduleconnectorwrapper.XTS_SSTC_TEST_INPUT_HIGH_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_INPUT_HIGH = _moduleconnectorwrapper.XTS_SSTC_TEST_INPUT_HIGH

_moduleconnectorwrapper.XTS_SSTC_TEST_INPUT_LOW_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_INPUT_LOW = _moduleconnectorwrapper.XTS_SSTC_TEST_INPUT_LOW

_moduleconnectorwrapper.XTS_SSTC_TEST_OUTPUT_HIGH_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_OUTPUT_HIGH = _moduleconnectorwrapper.XTS_SSTC_TEST_OUTPUT_HIGH

_moduleconnectorwrapper.XTS_SSTC_TEST_OUTPUT_LOW_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_OUTPUT_LOW = _moduleconnectorwrapper.XTS_SSTC_TEST_OUTPUT_LOW

_moduleconnectorwrapper.XTS_SSTC_TEST_READ_IOPINS_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_READ_IOPINS = _moduleconnectorwrapper.XTS_SSTC_TEST_READ_IOPINS

_moduleconnectorwrapper.XTS_SSTC_TEST_X4_CONN_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_X4_CONN = _moduleconnectorwrapper.XTS_SSTC_TEST_X4_CONN

_moduleconnectorwrapper.XTS_SSTC_TEST_CERT_MODE_EN_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_CERT_MODE_EN = _moduleconnectorwrapper.XTS_SSTC_TEST_CERT_MODE_EN

_moduleconnectorwrapper.XTS_SSTC_TEST_CERT_MODE_DIS_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_CERT_MODE_DIS = _moduleconnectorwrapper.XTS_SSTC_TEST_CERT_MODE_DIS

_moduleconnectorwrapper.XTS_SSTC_TEST_HW_CONFIG_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_HW_CONFIG = _moduleconnectorwrapper.XTS_SSTC_TEST_HW_CONFIG

_moduleconnectorwrapper.XTS_SSTC_TEST_CERT_TX_ONLY_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_CERT_TX_ONLY = _moduleconnectorwrapper.XTS_SSTC_TEST_CERT_TX_ONLY

_moduleconnectorwrapper.XTS_SSTC_TEST_CERT_TX_ONLY_TX_OFF_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_CERT_TX_ONLY_TX_OFF = _moduleconnectorwrapper.XTS_SSTC_TEST_CERT_TX_ONLY_TX_OFF

_moduleconnectorwrapper.XTS_SSTC_TEST_CERT_STREAM_TX_OFF_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_CERT_STREAM_TX_OFF = _moduleconnectorwrapper.XTS_SSTC_TEST_CERT_STREAM_TX_OFF

_moduleconnectorwrapper.XTS_SSTC_TEST_LAST_swigconstant(_moduleconnectorwrapper)
XTS_SSTC_TEST_LAST = _moduleconnectorwrapper.XTS_SSTC_TEST_LAST

_moduleconnectorwrapper.XTS_SSIC_ITEMNUMBER_swigconstant(_moduleconnectorwrapper)
XTS_SSIC_ITEMNUMBER = _moduleconnectorwrapper.XTS_SSIC_ITEMNUMBER

_moduleconnectorwrapper.XTS_SSIC_ORDERCODE_swigconstant(_moduleconnectorwrapper)
XTS_SSIC_ORDERCODE = _moduleconnectorwrapper.XTS_SSIC_ORDERCODE

_moduleconnectorwrapper.XTS_SSIC_FIRMWAREID_swigconstant(_moduleconnectorwrapper)
XTS_SSIC_FIRMWAREID = _moduleconnectorwrapper.XTS_SSIC_FIRMWAREID

_moduleconnectorwrapper.XTS_SSIC_VERSION_swigconstant(_moduleconnectorwrapper)
XTS_SSIC_VERSION = _moduleconnectorwrapper.XTS_SSIC_VERSION

_moduleconnectorwrapper.XTS_SSIC_BUILD_swigconstant(_moduleconnectorwrapper)
XTS_SSIC_BUILD = _moduleconnectorwrapper.XTS_SSIC_BUILD

_moduleconnectorwrapper.XTS_SSIC_APPIDLIST_swigconstant(_moduleconnectorwrapper)
XTS_SSIC_APPIDLIST = _moduleconnectorwrapper.XTS_SSIC_APPIDLIST

_moduleconnectorwrapper.XTS_SSIC_SERIALNUMBER_swigconstant(_moduleconnectorwrapper)
XTS_SSIC_SERIALNUMBER = _moduleconnectorwrapper.XTS_SSIC_SERIALNUMBER

_moduleconnectorwrapper.XTS_SM_RESERVED_swigconstant(_moduleconnectorwrapper)
XTS_SM_RESERVED = _moduleconnectorwrapper.XTS_SM_RESERVED

_moduleconnectorwrapper.XTS_SM_RUN_swigconstant(_moduleconnectorwrapper)
XTS_SM_RUN = _moduleconnectorwrapper.XTS_SM_RUN

_moduleconnectorwrapper.XTS_SM_NORMAL_swigconstant(_moduleconnectorwrapper)
XTS_SM_NORMAL = _moduleconnectorwrapper.XTS_SM_NORMAL

_moduleconnectorwrapper.XTS_SM_IDLE_swigconstant(_moduleconnectorwrapper)
XTS_SM_IDLE = _moduleconnectorwrapper.XTS_SM_IDLE

_moduleconnectorwrapper.XTS_SM_MANUAL_swigconstant(_moduleconnectorwrapper)
XTS_SM_MANUAL = _moduleconnectorwrapper.XTS_SM_MANUAL

_moduleconnectorwrapper.XTS_SM_STOP_swigconstant(_moduleconnectorwrapper)
XTS_SM_STOP = _moduleconnectorwrapper.XTS_SM_STOP

_moduleconnectorwrapper.XTS_SM_REG_swigconstant(_moduleconnectorwrapper)
XTS_SM_REG = _moduleconnectorwrapper.XTS_SM_REG

_moduleconnectorwrapper.XTS_SM_REG_IDLE_swigconstant(_moduleconnectorwrapper)
XTS_SM_REG_IDLE = _moduleconnectorwrapper.XTS_SM_REG_IDLE

_moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY_swigconstant(_moduleconnectorwrapper)
XTS_SM_REG_CERT_TX_ONLY = _moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY

_moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY_TX_OFF_swigconstant(_moduleconnectorwrapper)
XTS_SM_REG_CERT_TX_ONLY_TX_OFF = _moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY_TX_OFF

_moduleconnectorwrapper.XTS_SM_REG_CERT_STREAM_TX_OFF_swigconstant(_moduleconnectorwrapper)
XTS_SM_REG_CERT_STREAM_TX_OFF = _moduleconnectorwrapper.XTS_SM_REG_CERT_STREAM_TX_OFF

_moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY_EXTCLK_swigconstant(_moduleconnectorwrapper)
XTS_SM_REG_CERT_TX_ONLY_EXTCLK = _moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY_EXTCLK

_moduleconnectorwrapper.XTS_SM_REG_CERT_STREAM_swigconstant(_moduleconnectorwrapper)
XTS_SM_REG_CERT_STREAM = _moduleconnectorwrapper.XTS_SM_REG_CERT_STREAM

_moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY_CLKOUT_swigconstant(_moduleconnectorwrapper)
XTS_SM_REG_CERT_TX_ONLY_CLKOUT = _moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY_CLKOUT

_moduleconnectorwrapper.XTS_SM_REG_CERT_RX_FAILURE_EMU_swigconstant(_moduleconnectorwrapper)
XTS_SM_REG_CERT_RX_FAILURE_EMU = _moduleconnectorwrapper.XTS_SM_REG_CERT_RX_FAILURE_EMU

_moduleconnectorwrapper.XTS_SM_NORMAL_EMBEDDED_swigconstant(_moduleconnectorwrapper)
XTS_SM_NORMAL_EMBEDDED = _moduleconnectorwrapper.XTS_SM_NORMAL_EMBEDDED

_moduleconnectorwrapper.XTS_SM_NORMAL_HIL_UP_swigconstant(_moduleconnectorwrapper)
XTS_SM_NORMAL_HIL_UP = _moduleconnectorwrapper.XTS_SM_NORMAL_HIL_UP

_moduleconnectorwrapper.XTS_SM_NORMAL_HIL_DOWN_swigconstant(_moduleconnectorwrapper)
XTS_SM_NORMAL_HIL_DOWN = _moduleconnectorwrapper.XTS_SM_NORMAL_HIL_DOWN

_moduleconnectorwrapper.XTS_SM_NORMAL_DEFAULT_swigconstant(_moduleconnectorwrapper)
XTS_SM_NORMAL_DEFAULT = _moduleconnectorwrapper.XTS_SM_NORMAL_DEFAULT

_moduleconnectorwrapper.ID_RAW_FRAME_BUFFER_swigconstant(_moduleconnectorwrapper)
ID_RAW_FRAME_BUFFER = _moduleconnectorwrapper.ID_RAW_FRAME_BUFFER

_moduleconnectorwrapper.ID_BASEBAND_BUFFER_ICHANN_swigconstant(_moduleconnectorwrapper)
ID_BASEBAND_BUFFER_ICHANN = _moduleconnectorwrapper.ID_BASEBAND_BUFFER_ICHANN

_moduleconnectorwrapper.ID_BASEBAND_BUFFER_QCHANN_swigconstant(_moduleconnectorwrapper)
ID_BASEBAND_BUFFER_QCHANN = _moduleconnectorwrapper.ID_BASEBAND_BUFFER_QCHANN

_moduleconnectorwrapper.ID_BASEBAND_BUFFER_IQCHANN_LEGACY_swigconstant(_moduleconnectorwrapper)
ID_BASEBAND_BUFFER_IQCHANN_LEGACY = _moduleconnectorwrapper.ID_BASEBAND_BUFFER_IQCHANN_LEGACY

_moduleconnectorwrapper.ID_BASEBAND_ENVELOPE_swigconstant(_moduleconnectorwrapper)
ID_BASEBAND_ENVELOPE = _moduleconnectorwrapper.ID_BASEBAND_ENVELOPE

_moduleconnectorwrapper.ID_DOPPLER_FFT_INPUT_swigconstant(_moduleconnectorwrapper)
ID_DOPPLER_FFT_INPUT = _moduleconnectorwrapper.ID_DOPPLER_FFT_INPUT

_moduleconnectorwrapper.ID_DOPPLER_FFT_OUTPUT_swigconstant(_moduleconnectorwrapper)
ID_DOPPLER_FFT_OUTPUT = _moduleconnectorwrapper.ID_DOPPLER_FFT_OUTPUT

_moduleconnectorwrapper.ID_PULSEDOPPLER_MATRIX_swigconstant(_moduleconnectorwrapper)
ID_PULSEDOPPLER_MATRIX = _moduleconnectorwrapper.ID_PULSEDOPPLER_MATRIX

_moduleconnectorwrapper.ID_NOISEMAP_swigconstant(_moduleconnectorwrapper)
ID_NOISEMAP = _moduleconnectorwrapper.ID_NOISEMAP

_moduleconnectorwrapper.ID_FRAMESTORAGE_BUFFER_ICHANN_swigconstant(_moduleconnectorwrapper)
ID_FRAMESTORAGE_BUFFER_ICHANN = _moduleconnectorwrapper.ID_FRAMESTORAGE_BUFFER_ICHANN

_moduleconnectorwrapper.ID_FRAMESTORAGE_BUFFER_QCHANN_swigconstant(_moduleconnectorwrapper)
ID_FRAMESTORAGE_BUFFER_QCHANN = _moduleconnectorwrapper.ID_FRAMESTORAGE_BUFFER_QCHANN

_moduleconnectorwrapper.ID_RAW_FLASH_FRAME_swigconstant(_moduleconnectorwrapper)
ID_RAW_FLASH_FRAME = _moduleconnectorwrapper.ID_RAW_FLASH_FRAME

_moduleconnectorwrapper.ID_BASEBAND_IQ_swigconstant(_moduleconnectorwrapper)
ID_BASEBAND_IQ = _moduleconnectorwrapper.ID_BASEBAND_IQ

_moduleconnectorwrapper.ID_BASEBAND_AP_swigconstant(_moduleconnectorwrapper)
ID_BASEBAND_AP = _moduleconnectorwrapper.ID_BASEBAND_AP

_moduleconnectorwrapper.ID_GENERIC_BYTE_STREAM_swigconstant(_moduleconnectorwrapper)
ID_GENERIC_BYTE_STREAM = _moduleconnectorwrapper.ID_GENERIC_BYTE_STREAM

_moduleconnectorwrapper.NUMBER_OF_MESSAGE_IDS_swigconstant(_moduleconnectorwrapper)
NUMBER_OF_MESSAGE_IDS = _moduleconnectorwrapper.NUMBER_OF_MESSAGE_IDS

_moduleconnectorwrapper.XTS_SACR_ID_BASEBAND_OUTPUT_OFF_swigconstant(_moduleconnectorwrapper)
XTS_SACR_ID_BASEBAND_OUTPUT_OFF = _moduleconnectorwrapper.XTS_SACR_ID_BASEBAND_OUTPUT_OFF

_moduleconnectorwrapper.XTS_SACR_ID_BASEBAND_OUTPUT_IQ_swigconstant(_moduleconnectorwrapper)
XTS_SACR_ID_BASEBAND_OUTPUT_IQ = _moduleconnectorwrapper.XTS_SACR_ID_BASEBAND_OUTPUT_IQ

_moduleconnectorwrapper.XTS_SACR_ID_BASEBAND_OUTPUT_AMPLITUDE_PHASE_swigconstant(_moduleconnectorwrapper)
XTS_SACR_ID_BASEBAND_OUTPUT_AMPLITUDE_PHASE = _moduleconnectorwrapper.XTS_SACR_ID_BASEBAND_OUTPUT_AMPLITUDE_PHASE

_moduleconnectorwrapper.XTS_BASEBAND_AMPLITUDE_ONLY_swigconstant(_moduleconnectorwrapper)
XTS_BASEBAND_AMPLITUDE_ONLY = _moduleconnectorwrapper.XTS_BASEBAND_AMPLITUDE_ONLY

_moduleconnectorwrapper.XTS_BASEBAND_PHASE_ONLY_swigconstant(_moduleconnectorwrapper)
XTS_BASEBAND_PHASE_ONLY = _moduleconnectorwrapper.XTS_BASEBAND_PHASE_ONLY
class baseband_output_header_t(_object):
    """Proxy of C++ baseband_output_header_t class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, baseband_output_header_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, baseband_output_header_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["id"] = _moduleconnectorwrapper.baseband_output_header_t_id_set
    __swig_getmethods__["id"] = _moduleconnectorwrapper.baseband_output_header_t_id_get
    if _newclass:
        id = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_id_get, _moduleconnectorwrapper.baseband_output_header_t_id_set)
    __swig_setmethods__["Counter"] = _moduleconnectorwrapper.baseband_output_header_t_Counter_set
    __swig_getmethods__["Counter"] = _moduleconnectorwrapper.baseband_output_header_t_Counter_get
    if _newclass:
        Counter = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_Counter_get, _moduleconnectorwrapper.baseband_output_header_t_Counter_set)
    __swig_setmethods__["NumOfBins"] = _moduleconnectorwrapper.baseband_output_header_t_NumOfBins_set
    __swig_getmethods__["NumOfBins"] = _moduleconnectorwrapper.baseband_output_header_t_NumOfBins_get
    if _newclass:
        NumOfBins = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_NumOfBins_get, _moduleconnectorwrapper.baseband_output_header_t_NumOfBins_set)
    __swig_setmethods__["BinLength"] = _moduleconnectorwrapper.baseband_output_header_t_BinLength_set
    __swig_getmethods__["BinLength"] = _moduleconnectorwrapper.baseband_output_header_t_BinLength_get
    if _newclass:
        BinLength = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_BinLength_get, _moduleconnectorwrapper.baseband_output_header_t_BinLength_set)
    __swig_setmethods__["SamplingFrequency"] = _moduleconnectorwrapper.baseband_output_header_t_SamplingFrequency_set
    __swig_getmethods__["SamplingFrequency"] = _moduleconnectorwrapper.baseband_output_header_t_SamplingFrequency_get
    if _newclass:
        SamplingFrequency = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_SamplingFrequency_get, _moduleconnectorwrapper.baseband_output_header_t_SamplingFrequency_set)
    __swig_setmethods__["CarrierFrequency"] = _moduleconnectorwrapper.baseband_output_header_t_CarrierFrequency_set
    __swig_getmethods__["CarrierFrequency"] = _moduleconnectorwrapper.baseband_output_header_t_CarrierFrequency_get
    if _newclass:
        CarrierFrequency = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_CarrierFrequency_get, _moduleconnectorwrapper.baseband_output_header_t_CarrierFrequency_set)
    __swig_setmethods__["RangeOffset"] = _moduleconnectorwrapper.baseband_output_header_t_RangeOffset_set
    __swig_getmethods__["RangeOffset"] = _moduleconnectorwrapper.baseband_output_header_t_RangeOffset_get
    if _newclass:
        RangeOffset = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_RangeOffset_get, _moduleconnectorwrapper.baseband_output_header_t_RangeOffset_set)

    def __init__(self):
        """__init__(baseband_output_header_t self) -> baseband_output_header_t"""
        this = _moduleconnectorwrapper.new_baseband_output_header_t()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_baseband_output_header_t
    __del__ = lambda self: None
baseband_output_header_t_swigregister = _moduleconnectorwrapper.baseband_output_header_t_swigregister
baseband_output_header_t_swigregister(baseband_output_header_t)


_moduleconnectorwrapper.XTS_PULSEDOPPLER_OUTPUT_OFF_swigconstant(_moduleconnectorwrapper)
XTS_PULSEDOPPLER_OUTPUT_OFF = _moduleconnectorwrapper.XTS_PULSEDOPPLER_OUTPUT_OFF

_moduleconnectorwrapper.XTS_PULSEDOPPLER_AS_FLOAT_swigconstant(_moduleconnectorwrapper)
XTS_PULSEDOPPLER_AS_FLOAT = _moduleconnectorwrapper.XTS_PULSEDOPPLER_AS_FLOAT

_moduleconnectorwrapper.XTS_PULSEDOPPLER_AS_BYTE_swigconstant(_moduleconnectorwrapper)
XTS_PULSEDOPPLER_AS_BYTE = _moduleconnectorwrapper.XTS_PULSEDOPPLER_AS_BYTE

_moduleconnectorwrapper.CRC_ERROR_swigconstant(_moduleconnectorwrapper)
CRC_ERROR = _moduleconnectorwrapper.CRC_ERROR

_moduleconnectorwrapper.LOST_BYTES_swigconstant(_moduleconnectorwrapper)
LOST_BYTES = _moduleconnectorwrapper.LOST_BYTES

_moduleconnectorwrapper.INCOMPLETE_PACKET_swigconstant(_moduleconnectorwrapper)
INCOMPLETE_PACKET = _moduleconnectorwrapper.INCOMPLETE_PACKET

_moduleconnectorwrapper.OUT_OF_BUFFER_swigconstant(_moduleconnectorwrapper)
OUT_OF_BUFFER = _moduleconnectorwrapper.OUT_OF_BUFFER

_moduleconnectorwrapper.COMMAND_TIMEOUT_swigconstant(_moduleconnectorwrapper)
COMMAND_TIMEOUT = _moduleconnectorwrapper.COMMAND_TIMEOUT
class xtsUserVsdmStatus(_object):
    """Proxy of C++ xtsUserVsdmStatus class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, xtsUserVsdmStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, xtsUserVsdmStatus, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frameCtr"] = _moduleconnectorwrapper.xtsUserVsdmStatus_frameCtr_set
    __swig_getmethods__["frameCtr"] = _moduleconnectorwrapper.xtsUserVsdmStatus_frameCtr_get
    if _newclass:
        frameCtr = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_frameCtr_get, _moduleconnectorwrapper.xtsUserVsdmStatus_frameCtr_set)
    __swig_setmethods__["state"] = _moduleconnectorwrapper.xtsUserVsdmStatus_state_set
    __swig_getmethods__["state"] = _moduleconnectorwrapper.xtsUserVsdmStatus_state_get
    if _newclass:
        state = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_state_get, _moduleconnectorwrapper.xtsUserVsdmStatus_state_set)
    __swig_setmethods__["stateData"] = _moduleconnectorwrapper.xtsUserVsdmStatus_stateData_set
    __swig_getmethods__["stateData"] = _moduleconnectorwrapper.xtsUserVsdmStatus_stateData_get
    if _newclass:
        stateData = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_stateData_get, _moduleconnectorwrapper.xtsUserVsdmStatus_stateData_set)
    __swig_setmethods__["objectDistance"] = _moduleconnectorwrapper.xtsUserVsdmStatus_objectDistance_set
    __swig_getmethods__["objectDistance"] = _moduleconnectorwrapper.xtsUserVsdmStatus_objectDistance_get
    if _newclass:
        objectDistance = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_objectDistance_get, _moduleconnectorwrapper.xtsUserVsdmStatus_objectDistance_set)
    __swig_setmethods__["objectMovement"] = _moduleconnectorwrapper.xtsUserVsdmStatus_objectMovement_set
    __swig_getmethods__["objectMovement"] = _moduleconnectorwrapper.xtsUserVsdmStatus_objectMovement_get
    if _newclass:
        objectMovement = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_objectMovement_get, _moduleconnectorwrapper.xtsUserVsdmStatus_objectMovement_set)
    __swig_setmethods__["signalQuality"] = _moduleconnectorwrapper.xtsUserVsdmStatus_signalQuality_set
    __swig_getmethods__["signalQuality"] = _moduleconnectorwrapper.xtsUserVsdmStatus_signalQuality_get
    if _newclass:
        signalQuality = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_signalQuality_get, _moduleconnectorwrapper.xtsUserVsdmStatus_signalQuality_set)

    def __init__(self):
        """__init__(xtsUserVsdmStatus self) -> xtsUserVsdmStatus"""
        this = _moduleconnectorwrapper.new_xtsUserVsdmStatus()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_xtsUserVsdmStatus
    __del__ = lambda self: None
xtsUserVsdmStatus_swigregister = _moduleconnectorwrapper.xtsUserVsdmStatus_swigregister
xtsUserVsdmStatus_swigregister(xtsUserVsdmStatus)

class xtsUserPresenceStatus(_object):
    """Proxy of C++ xtsUserPresenceStatus class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, xtsUserPresenceStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, xtsUserPresenceStatus, name)
    __repr__ = _swig_repr
    __swig_setmethods__["presence"] = _moduleconnectorwrapper.xtsUserPresenceStatus_presence_set
    __swig_getmethods__["presence"] = _moduleconnectorwrapper.xtsUserPresenceStatus_presence_get
    if _newclass:
        presence = _swig_property(_moduleconnectorwrapper.xtsUserPresenceStatus_presence_get, _moduleconnectorwrapper.xtsUserPresenceStatus_presence_set)
    __swig_setmethods__["objectDistance"] = _moduleconnectorwrapper.xtsUserPresenceStatus_objectDistance_set
    __swig_getmethods__["objectDistance"] = _moduleconnectorwrapper.xtsUserPresenceStatus_objectDistance_get
    if _newclass:
        objectDistance = _swig_property(_moduleconnectorwrapper.xtsUserPresenceStatus_objectDistance_get, _moduleconnectorwrapper.xtsUserPresenceStatus_objectDistance_set)
    __swig_setmethods__["detectionValue"] = _moduleconnectorwrapper.xtsUserPresenceStatus_detectionValue_set
    __swig_getmethods__["detectionValue"] = _moduleconnectorwrapper.xtsUserPresenceStatus_detectionValue_get
    if _newclass:
        detectionValue = _swig_property(_moduleconnectorwrapper.xtsUserPresenceStatus_detectionValue_get, _moduleconnectorwrapper.xtsUserPresenceStatus_detectionValue_set)
    __swig_setmethods__["signalQuality"] = _moduleconnectorwrapper.xtsUserPresenceStatus_signalQuality_set
    __swig_getmethods__["signalQuality"] = _moduleconnectorwrapper.xtsUserPresenceStatus_signalQuality_get
    if _newclass:
        signalQuality = _swig_property(_moduleconnectorwrapper.xtsUserPresenceStatus_signalQuality_get, _moduleconnectorwrapper.xtsUserPresenceStatus_signalQuality_set)

    def __init__(self):
        """__init__(xtsUserPresenceStatus self) -> xtsUserPresenceStatus"""
        this = _moduleconnectorwrapper.new_xtsUserPresenceStatus()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_xtsUserPresenceStatus
    __del__ = lambda self: None
xtsUserPresenceStatus_swigregister = _moduleconnectorwrapper.xtsUserPresenceStatus_swigregister
xtsUserPresenceStatus_swigregister(xtsUserPresenceStatus)

class xtssRadarSettings_t(_object):
    """Proxy of C++ xtssRadarSettings_t class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, xtssRadarSettings_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, xtssRadarSettings_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["timingValue"] = _moduleconnectorwrapper.xtssRadarSettings_t_timingValue_set
    __swig_getmethods__["timingValue"] = _moduleconnectorwrapper.xtssRadarSettings_t_timingValue_get
    if _newclass:
        timingValue = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_timingValue_get, _moduleconnectorwrapper.xtssRadarSettings_t_timingValue_set)
    __swig_setmethods__["timingValueRaw"] = _moduleconnectorwrapper.xtssRadarSettings_t_timingValueRaw_set
    __swig_getmethods__["timingValueRaw"] = _moduleconnectorwrapper.xtssRadarSettings_t_timingValueRaw_get
    if _newclass:
        timingValueRaw = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_timingValueRaw_get, _moduleconnectorwrapper.xtssRadarSettings_t_timingValueRaw_set)
    __swig_setmethods__["PRF"] = _moduleconnectorwrapper.xtssRadarSettings_t_PRF_set
    __swig_getmethods__["PRF"] = _moduleconnectorwrapper.xtssRadarSettings_t_PRF_get
    if _newclass:
        PRF = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_PRF_get, _moduleconnectorwrapper.xtssRadarSettings_t_PRF_set)
    __swig_setmethods__["delayInCoarseMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInCoarseMeasured_set
    __swig_getmethods__["delayInCoarseMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInCoarseMeasured_get
    if _newclass:
        delayInCoarseMeasured = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayInCoarseMeasured_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayInCoarseMeasured_set)
    __swig_setmethods__["delayInMediumMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInMediumMeasured_set
    __swig_getmethods__["delayInMediumMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInMediumMeasured_get
    if _newclass:
        delayInMediumMeasured = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayInMediumMeasured_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayInMediumMeasured_set)
    __swig_setmethods__["delayInFineMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInFineMeasured_set
    __swig_getmethods__["delayInFineMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInFineMeasured_get
    if _newclass:
        delayInFineMeasured = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayInFineMeasured_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayInFineMeasured_set)
    __swig_setmethods__["delayCoarseTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayCoarseTune_set
    __swig_getmethods__["delayCoarseTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayCoarseTune_get
    if _newclass:
        delayCoarseTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayCoarseTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayCoarseTune_set)
    __swig_setmethods__["delayMediumTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayMediumTune_set
    __swig_getmethods__["delayMediumTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayMediumTune_get
    if _newclass:
        delayMediumTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayMediumTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayMediumTune_set)
    __swig_setmethods__["delayFineTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayFineTune_set
    __swig_getmethods__["delayFineTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayFineTune_get
    if _newclass:
        delayFineTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayFineTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayFineTune_set)
    __swig_setmethods__["samplesPerSecond"] = _moduleconnectorwrapper.xtssRadarSettings_t_samplesPerSecond_set
    __swig_getmethods__["samplesPerSecond"] = _moduleconnectorwrapper.xtssRadarSettings_t_samplesPerSecond_get
    if _newclass:
        samplesPerSecond = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_samplesPerSecond_get, _moduleconnectorwrapper.xtssRadarSettings_t_samplesPerSecond_set)
    __swig_setmethods__["frameSize"] = _moduleconnectorwrapper.xtssRadarSettings_t_frameSize_set
    __swig_getmethods__["frameSize"] = _moduleconnectorwrapper.xtssRadarSettings_t_frameSize_get
    if _newclass:
        frameSize = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_frameSize_get, _moduleconnectorwrapper.xtssRadarSettings_t_frameSize_set)
    __swig_setmethods__["mediumInCoarseAverage"] = _moduleconnectorwrapper.xtssRadarSettings_t_mediumInCoarseAverage_set
    __swig_getmethods__["mediumInCoarseAverage"] = _moduleconnectorwrapper.xtssRadarSettings_t_mediumInCoarseAverage_get
    if _newclass:
        mediumInCoarseAverage = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_mediumInCoarseAverage_get, _moduleconnectorwrapper.xtssRadarSettings_t_mediumInCoarseAverage_set)
    __swig_setmethods__["fineInMediumAverage"] = _moduleconnectorwrapper.xtssRadarSettings_t_fineInMediumAverage_set
    __swig_getmethods__["fineInMediumAverage"] = _moduleconnectorwrapper.xtssRadarSettings_t_fineInMediumAverage_get
    if _newclass:
        fineInMediumAverage = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_fineInMediumAverage_get, _moduleconnectorwrapper.xtssRadarSettings_t_fineInMediumAverage_set)
    __swig_setmethods__["delayLengthCoarseTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthCoarseTune_set
    __swig_getmethods__["delayLengthCoarseTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthCoarseTune_get
    if _newclass:
        delayLengthCoarseTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayLengthCoarseTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthCoarseTune_set)
    __swig_setmethods__["delayLengthMediumTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthMediumTune_set
    __swig_getmethods__["delayLengthMediumTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthMediumTune_get
    if _newclass:
        delayLengthMediumTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayLengthMediumTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthMediumTune_set)
    __swig_setmethods__["delayLengthFineTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthFineTune_set
    __swig_getmethods__["delayLengthFineTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthFineTune_get
    if _newclass:
        delayLengthFineTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayLengthFineTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthFineTune_set)
    __swig_setmethods__["stopWatchInitialized"] = _moduleconnectorwrapper.xtssRadarSettings_t_stopWatchInitialized_set
    __swig_getmethods__["stopWatchInitialized"] = _moduleconnectorwrapper.xtssRadarSettings_t_stopWatchInitialized_get
    if _newclass:
        stopWatchInitialized = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_stopWatchInitialized_get, _moduleconnectorwrapper.xtssRadarSettings_t_stopWatchInitialized_set)
    __swig_setmethods__["frameLengths"] = _moduleconnectorwrapper.xtssRadarSettings_t_frameLengths_set
    __swig_getmethods__["frameLengths"] = _moduleconnectorwrapper.xtssRadarSettings_t_frameLengths_get
    if _newclass:
        frameLengths = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_frameLengths_get, _moduleconnectorwrapper.xtssRadarSettings_t_frameLengths_set)
    __swig_setmethods__["origSampleDelayLength"] = _moduleconnectorwrapper.xtssRadarSettings_t_origSampleDelayLength_set
    __swig_getmethods__["origSampleDelayLength"] = _moduleconnectorwrapper.xtssRadarSettings_t_origSampleDelayLength_get
    if _newclass:
        origSampleDelayLength = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_origSampleDelayLength_get, _moduleconnectorwrapper.xtssRadarSettings_t_origSampleDelayLength_set)
    __swig_setmethods__["sampleDelayLengthError"] = _moduleconnectorwrapper.xtssRadarSettings_t_sampleDelayLengthError_set
    __swig_getmethods__["sampleDelayLengthError"] = _moduleconnectorwrapper.xtssRadarSettings_t_sampleDelayLengthError_get
    if _newclass:
        sampleDelayLengthError = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_sampleDelayLengthError_get, _moduleconnectorwrapper.xtssRadarSettings_t_sampleDelayLengthError_set)
    __swig_setmethods__["PGDelay"] = _moduleconnectorwrapper.xtssRadarSettings_t_PGDelay_set
    __swig_getmethods__["PGDelay"] = _moduleconnectorwrapper.xtssRadarSettings_t_PGDelay_get
    if _newclass:
        PGDelay = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_PGDelay_get, _moduleconnectorwrapper.xtssRadarSettings_t_PGDelay_set)
    __swig_setmethods__["chekcsum"] = _moduleconnectorwrapper.xtssRadarSettings_t_chekcsum_set
    __swig_getmethods__["chekcsum"] = _moduleconnectorwrapper.xtssRadarSettings_t_chekcsum_get
    if _newclass:
        chekcsum = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_chekcsum_get, _moduleconnectorwrapper.xtssRadarSettings_t_chekcsum_set)
    __swig_setmethods__["modified"] = _moduleconnectorwrapper.xtssRadarSettings_t_modified_set
    __swig_getmethods__["modified"] = _moduleconnectorwrapper.xtssRadarSettings_t_modified_get
    if _newclass:
        modified = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_modified_get, _moduleconnectorwrapper.xtssRadarSettings_t_modified_set)
    __swig_setmethods__["cfgPulsesPerStep"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgPulsesPerStep_set
    __swig_getmethods__["cfgPulsesPerStep"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgPulsesPerStep_get
    if _newclass:
        cfgPulsesPerStep = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgPulsesPerStep_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgPulsesPerStep_set)
    __swig_setmethods__["cfgIterations"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgIterations_set
    __swig_getmethods__["cfgIterations"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgIterations_get
    if _newclass:
        cfgIterations = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgIterations_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgIterations_set)
    __swig_setmethods__["cfgDACStep"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACStep_set
    __swig_getmethods__["cfgDACStep"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACStep_get
    if _newclass:
        cfgDACStep = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgDACStep_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACStep_set)
    __swig_setmethods__["cfgDACMin"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMin_set
    __swig_getmethods__["cfgDACMin"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMin_get
    if _newclass:
        cfgDACMin = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMin_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMin_set)
    __swig_setmethods__["cfgDACMax"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMax_set
    __swig_getmethods__["cfgDACMax"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMax_get
    if _newclass:
        cfgDACMax = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMax_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMax_set)
    __swig_setmethods__["cfgPGSelect"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgPGSelect_set
    __swig_getmethods__["cfgPGSelect"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgPGSelect_get
    if _newclass:
        cfgPGSelect = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgPGSelect_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgPGSelect_set)
    __swig_setmethods__["cfgMClkDiv"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgMClkDiv_set
    __swig_getmethods__["cfgMClkDiv"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgMClkDiv_get
    if _newclass:
        cfgMClkDiv = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgMClkDiv_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgMClkDiv_set)
    __swig_setmethods__["cfgStaggeredPRFEnable"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgStaggeredPRFEnable_set
    __swig_getmethods__["cfgStaggeredPRFEnable"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgStaggeredPRFEnable_get
    if _newclass:
        cfgStaggeredPRFEnable = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgStaggeredPRFEnable_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgStaggeredPRFEnable_set)
    __swig_setmethods__["cfgSampleDelay"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgSampleDelay_set
    __swig_getmethods__["cfgSampleDelay"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgSampleDelay_get
    if _newclass:
        cfgSampleDelay = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgSampleDelay_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgSampleDelay_set)
    __swig_setmethods__["cfgDACAuto"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACAuto_set
    __swig_getmethods__["cfgDACAuto"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACAuto_get
    if _newclass:
        cfgDACAuto = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgDACAuto_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACAuto_set)
    __swig_setmethods__["cfgFPS"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgFPS_set
    __swig_getmethods__["cfgFPS"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgFPS_get
    if _newclass:
        cfgFPS = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgFPS_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgFPS_set)
    __swig_setmethods__["cfgFrameStitch"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgFrameStitch_set
    __swig_getmethods__["cfgFrameStitch"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgFrameStitch_get
    if _newclass:
        cfgFrameStitch = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgFrameStitch_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgFrameStitch_set)
    __swig_setmethods__["carrierFreqFromPG"] = _moduleconnectorwrapper.xtssRadarSettings_t_carrierFreqFromPG_set
    __swig_getmethods__["carrierFreqFromPG"] = _moduleconnectorwrapper.xtssRadarSettings_t_carrierFreqFromPG_get
    if _newclass:
        carrierFreqFromPG = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_carrierFreqFromPG_get, _moduleconnectorwrapper.xtssRadarSettings_t_carrierFreqFromPG_set)

    def __init__(self):
        """__init__(xtssRadarSettings_t self) -> xtssRadarSettings_t"""
        this = _moduleconnectorwrapper.new_xtssRadarSettings_t()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_xtssRadarSettings_t
    __del__ = lambda self: None
xtssRadarSettings_t_swigregister = _moduleconnectorwrapper.xtssRadarSettings_t_swigregister
xtssRadarSettings_t_swigregister(xtssRadarSettings_t)

class xtsUserRadarPerformanceStatus_t(_object):
    """Proxy of C++ xtsUserRadarPerformanceStatus_t class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, xtsUserRadarPerformanceStatus_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, xtsUserRadarPerformanceStatus_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["swRadarSweep"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarSweep_set
    __swig_getmethods__["swRadarSweep"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarSweep_get
    if _newclass:
        swRadarSweep = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarSweep_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarSweep_set)
    __swig_setmethods__["swRadarCaptureFrame"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarCaptureFrame_set
    __swig_getmethods__["swRadarCaptureFrame"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarCaptureFrame_get
    if _newclass:
        swRadarCaptureFrame = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarCaptureFrame_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarCaptureFrame_set)
    __swig_setmethods__["swRadarNormalizeFrame"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarNormalizeFrame_set
    __swig_getmethods__["swRadarNormalizeFrame"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarNormalizeFrame_get
    if _newclass:
        swRadarNormalizeFrame = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarNormalizeFrame_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarNormalizeFrame_set)
    __swig_setmethods__["swDoPrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoPrimary_set
    __swig_getmethods__["swDoPrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoPrimary_get
    if _newclass:
        swDoPrimary = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoPrimary_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoPrimary_set)
    __swig_setmethods__["swDoSecondary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoSecondary_set
    __swig_getmethods__["swDoSecondary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoSecondary_get
    if _newclass:
        swDoSecondary = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoSecondary_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoSecondary_set)
    __swig_setmethods__["swDoOutput"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoOutput_set
    __swig_getmethods__["swDoOutput"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoOutput_get
    if _newclass:
        swDoOutput = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoOutput_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoOutput_set)
    __swig_setmethods__["frameStitch"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_frameStitch_set
    __swig_getmethods__["frameStitch"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_frameStitch_get
    if _newclass:
        frameStitch = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_frameStitch_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_frameStitch_set)
    __swig_setmethods__["FPS"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_FPS_set
    __swig_getmethods__["FPS"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_FPS_get
    if _newclass:
        FPS = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_FPS_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_FPS_set)
    __swig_setmethods__["overflowRadarTrigger"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowRadarTrigger_set
    __swig_getmethods__["overflowRadarTrigger"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowRadarTrigger_get
    if _newclass:
        overflowRadarTrigger = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowRadarTrigger_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowRadarTrigger_set)
    __swig_setmethods__["overflowPrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowPrimary_set
    __swig_getmethods__["overflowPrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowPrimary_get
    if _newclass:
        overflowPrimary = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowPrimary_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowPrimary_set)
    __swig_setmethods__["overflowOutput"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowOutput_set
    __swig_getmethods__["overflowOutput"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowOutput_get
    if _newclass:
        overflowOutput = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowOutput_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowOutput_set)
    __swig_setmethods__["memSysStackUntouched"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memSysStackUntouched_set
    __swig_getmethods__["memSysStackUntouched"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memSysStackUntouched_get
    if _newclass:
        memSysStackUntouched = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memSysStackUntouched_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memSysStackUntouched_set)
    __swig_setmethods__["memOSHeap"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memOSHeap_set
    __swig_getmethods__["memOSHeap"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memOSHeap_get
    if _newclass:
        memOSHeap = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memOSHeap_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memOSHeap_set)
    __swig_setmethods__["memTaskRadar"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskRadar_set
    __swig_getmethods__["memTaskRadar"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskRadar_get
    if _newclass:
        memTaskRadar = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskRadar_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskRadar_set)
    __swig_setmethods__["memTaskAppEnginePrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEnginePrimary_set
    __swig_getmethods__["memTaskAppEnginePrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEnginePrimary_get
    if _newclass:
        memTaskAppEnginePrimary = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEnginePrimary_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEnginePrimary_set)
    __swig_setmethods__["memTaskAppEngineSecondary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEngineSecondary_set
    __swig_getmethods__["memTaskAppEngineSecondary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEngineSecondary_get
    if _newclass:
        memTaskAppEngineSecondary = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEngineSecondary_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEngineSecondary_set)
    __swig_setmethods__["memTaskSystem"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskSystem_set
    __swig_getmethods__["memTaskSystem"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskSystem_get
    if _newclass:
        memTaskSystem = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskSystem_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskSystem_set)
    __swig_setmethods__["memTaskUartRx"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartRx_set
    __swig_getmethods__["memTaskUartRx"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartRx_get
    if _newclass:
        memTaskUartRx = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartRx_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartRx_set)
    __swig_setmethods__["memTaskUartTx"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartTx_set
    __swig_getmethods__["memTaskUartTx"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartTx_get
    if _newclass:
        memTaskUartTx = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartTx_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartTx_set)
    __swig_setmethods__["idleTicks"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_idleTicks_set
    __swig_getmethods__["idleTicks"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_idleTicks_get
    if _newclass:
        idleTicks = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_idleTicks_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_idleTicks_set)
    __swig_setmethods__["comTxBufHighWatermark"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_comTxBufHighWatermark_set
    __swig_getmethods__["comTxBufHighWatermark"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_comTxBufHighWatermark_get
    if _newclass:
        comTxBufHighWatermark = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_comTxBufHighWatermark_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_comTxBufHighWatermark_set)
    __swig_setmethods__["periodSystemTicks"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_periodSystemTicks_set
    __swig_getmethods__["periodSystemTicks"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_periodSystemTicks_get
    if _newclass:
        periodSystemTicks = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_periodSystemTicks_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_periodSystemTicks_set)
    __swig_setmethods__["lastSystemTick"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_lastSystemTick_set
    __swig_getmethods__["lastSystemTick"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_lastSystemTick_get
    if _newclass:
        lastSystemTick = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_lastSystemTick_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_lastSystemTick_set)

    def __init__(self):
        """__init__(xtsUserRadarPerformanceStatus_t self) -> xtsUserRadarPerformanceStatus_t"""
        this = _moduleconnectorwrapper.new_xtsUserRadarPerformanceStatus_t()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_xtsUserRadarPerformanceStatus_t
    __del__ = lambda self: None
xtsUserRadarPerformanceStatus_t_swigregister = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swigregister
xtsUserRadarPerformanceStatus_t_swigregister(xtsUserRadarPerformanceStatus_t)


_moduleconnectorwrapper.XTS_ID_APP_UNKNOWN_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_UNKNOWN = _moduleconnectorwrapper.XTS_ID_APP_UNKNOWN

_moduleconnectorwrapper.XTS_ID_APP_PRESENCE_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_PRESENCE = _moduleconnectorwrapper.XTS_ID_APP_PRESENCE

_moduleconnectorwrapper.XTS_ID_APP_RESP_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_RESP = _moduleconnectorwrapper.XTS_ID_APP_RESP

_moduleconnectorwrapper.XTS_ID_APP_SLEEP_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_SLEEP = _moduleconnectorwrapper.XTS_ID_APP_SLEEP

_moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_2_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_RESPIRATION_2 = _moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_2

_moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_3_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_RESPIRATION_3 = _moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_3

_moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_4_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_RESPIRATION_4 = _moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_4

_moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_5_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_RESPIRATION_5 = _moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_5

_moduleconnectorwrapper.XTS_ID_APP_HEARTRATE_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_HEARTRATE = _moduleconnectorwrapper.XTS_ID_APP_HEARTRATE

_moduleconnectorwrapper.XTS_ID_APP_DECIM_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_DECIM = _moduleconnectorwrapper.XTS_ID_APP_DECIM

_moduleconnectorwrapper.XTS_ID_APP_PRESENCE_2_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_PRESENCE_2 = _moduleconnectorwrapper.XTS_ID_APP_PRESENCE_2

_moduleconnectorwrapper.XTS_ID_APP_PRESENCE_3_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_PRESENCE_3 = _moduleconnectorwrapper.XTS_ID_APP_PRESENCE_3

_moduleconnectorwrapper.XTS_ID_APP_PRESENCE_3_DEBUG_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_PRESENCE_3_DEBUG = _moduleconnectorwrapper.XTS_ID_APP_PRESENCE_3_DEBUG

_moduleconnectorwrapper.XTS_ID_APP_HIGHBAY_1_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_HIGHBAY_1 = _moduleconnectorwrapper.XTS_ID_APP_HIGHBAY_1

_moduleconnectorwrapper.XTS_ID_APP_HIGHBAY_1_DEBUG_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_HIGHBAY_1_DEBUG = _moduleconnectorwrapper.XTS_ID_APP_HIGHBAY_1_DEBUG

_moduleconnectorwrapper.XTS_ID_APP_RADAR_swigconstant(_moduleconnectorwrapper)
XTS_ID_APP_RADAR = _moduleconnectorwrapper.XTS_ID_APP_RADAR

_moduleconnectorwrapper.XTS_ID_RADAR_RF_swigconstant(_moduleconnectorwrapper)
XTS_ID_RADAR_RF = _moduleconnectorwrapper.XTS_ID_RADAR_RF

_moduleconnectorwrapper.XTS_ID_RADAR_RF_NORMALIZED_swigconstant(_moduleconnectorwrapper)
XTS_ID_RADAR_RF_NORMALIZED = _moduleconnectorwrapper.XTS_ID_RADAR_RF_NORMALIZED

_moduleconnectorwrapper.XTS_ID_RADAR_BASEBAND_FLOAT_swigconstant(_moduleconnectorwrapper)
XTS_ID_RADAR_BASEBAND_FLOAT = _moduleconnectorwrapper.XTS_ID_RADAR_BASEBAND_FLOAT

_moduleconnectorwrapper.XTS_ID_RADAR_BASEBAND_Q15_swigconstant(_moduleconnectorwrapper)
XTS_ID_RADAR_BASEBAND_Q15 = _moduleconnectorwrapper.XTS_ID_RADAR_BASEBAND_Q15

_moduleconnectorwrapper.XTS_ID_DETECTION_ZONE_swigconstant(_moduleconnectorwrapper)
XTS_ID_DETECTION_ZONE = _moduleconnectorwrapper.XTS_ID_DETECTION_ZONE

_moduleconnectorwrapper.XTS_ID_APPLICATION_USER_ZONE_swigconstant(_moduleconnectorwrapper)
XTS_ID_APPLICATION_USER_ZONE = _moduleconnectorwrapper.XTS_ID_APPLICATION_USER_ZONE

_moduleconnectorwrapper.XTS_ID_DETECTION_ZONE_LIMITS_swigconstant(_moduleconnectorwrapper)
XTS_ID_DETECTION_ZONE_LIMITS = _moduleconnectorwrapper.XTS_ID_DETECTION_ZONE_LIMITS

_moduleconnectorwrapper.XTS_ID_SENSITIVITY_swigconstant(_moduleconnectorwrapper)
XTS_ID_SENSITIVITY = _moduleconnectorwrapper.XTS_ID_SENSITIVITY

_moduleconnectorwrapper.XTS_ID_PRESENCE_STATUS_swigconstant(_moduleconnectorwrapper)
XTS_ID_PRESENCE_STATUS = _moduleconnectorwrapper.XTS_ID_PRESENCE_STATUS

_moduleconnectorwrapper.XTS_ID_RESP_STATUS_swigconstant(_moduleconnectorwrapper)
XTS_ID_RESP_STATUS = _moduleconnectorwrapper.XTS_ID_RESP_STATUS

_moduleconnectorwrapper.XTS_ID_RESP_STATUS_EXT_swigconstant(_moduleconnectorwrapper)
XTS_ID_RESP_STATUS_EXT = _moduleconnectorwrapper.XTS_ID_RESP_STATUS_EXT

_moduleconnectorwrapper.XTS_ID_SLEEP_STATUS_swigconstant(_moduleconnectorwrapper)
XTS_ID_SLEEP_STATUS = _moduleconnectorwrapper.XTS_ID_SLEEP_STATUS

_moduleconnectorwrapper.XTS_ID_PRESENCE_SINGLE_swigconstant(_moduleconnectorwrapper)
XTS_ID_PRESENCE_SINGLE = _moduleconnectorwrapper.XTS_ID_PRESENCE_SINGLE

_moduleconnectorwrapper.XTS_ID_PRESENCE_MOVINGLIST_swigconstant(_moduleconnectorwrapper)
XTS_ID_PRESENCE_MOVINGLIST = _moduleconnectorwrapper.XTS_ID_PRESENCE_MOVINGLIST

_moduleconnectorwrapper.XTS_ID_PROFILE_PARAMETERFILE_swigconstant(_moduleconnectorwrapper)
XTS_ID_PROFILE_PARAMETERFILE = _moduleconnectorwrapper.XTS_ID_PROFILE_PARAMETERFILE

_moduleconnectorwrapper.XTS_ID_BASEBAND_IQ_swigconstant(_moduleconnectorwrapper)
XTS_ID_BASEBAND_IQ = _moduleconnectorwrapper.XTS_ID_BASEBAND_IQ

_moduleconnectorwrapper.XTS_ID_BASEBAND_AMPLITUDE_PHASE_swigconstant(_moduleconnectorwrapper)
XTS_ID_BASEBAND_AMPLITUDE_PHASE = _moduleconnectorwrapper.XTS_ID_BASEBAND_AMPLITUDE_PHASE

_moduleconnectorwrapper.XTS_ID_DECIM_STATUS_swigconstant(_moduleconnectorwrapper)
XTS_ID_DECIM_STATUS = _moduleconnectorwrapper.XTS_ID_DECIM_STATUS

_moduleconnectorwrapper.XTS_ID_PULSEDOPPLER_FLOAT_swigconstant(_moduleconnectorwrapper)
XTS_ID_PULSEDOPPLER_FLOAT = _moduleconnectorwrapper.XTS_ID_PULSEDOPPLER_FLOAT

_moduleconnectorwrapper.XTS_ID_PULSEDOPPLER_BYTE_swigconstant(_moduleconnectorwrapper)
XTS_ID_PULSEDOPPLER_BYTE = _moduleconnectorwrapper.XTS_ID_PULSEDOPPLER_BYTE

_moduleconnectorwrapper.XTS_ID_NOISEMAP_FLOAT_swigconstant(_moduleconnectorwrapper)
XTS_ID_NOISEMAP_FLOAT = _moduleconnectorwrapper.XTS_ID_NOISEMAP_FLOAT

_moduleconnectorwrapper.XTS_ID_NOISEMAP_BYTE_swigconstant(_moduleconnectorwrapper)
XTS_ID_NOISEMAP_BYTE = _moduleconnectorwrapper.XTS_ID_NOISEMAP_BYTE

_moduleconnectorwrapper.XTS_ID_RESPIRATION_MOVINGLIST_swigconstant(_moduleconnectorwrapper)
XTS_ID_RESPIRATION_MOVINGLIST = _moduleconnectorwrapper.XTS_ID_RESPIRATION_MOVINGLIST

_moduleconnectorwrapper.XTS_ID_RESPIRATION_MOVEMENTLIST_swigconstant(_moduleconnectorwrapper)
XTS_ID_RESPIRATION_MOVEMENTLIST = _moduleconnectorwrapper.XTS_ID_RESPIRATION_MOVEMENTLIST

_moduleconnectorwrapper.XTS_ID_RESPIRATION_DETECTIONLIST_swigconstant(_moduleconnectorwrapper)
XTS_ID_RESPIRATION_DETECTIONLIST = _moduleconnectorwrapper.XTS_ID_RESPIRATION_DETECTIONLIST

_moduleconnectorwrapper.XTS_ID_RESPIRATION_NORMALIZEDMOVEMENTLIST_swigconstant(_moduleconnectorwrapper)
XTS_ID_RESPIRATION_NORMALIZEDMOVEMENTLIST = _moduleconnectorwrapper.XTS_ID_RESPIRATION_NORMALIZEDMOVEMENTLIST

_moduleconnectorwrapper.XTS_ID_VITAL_SIGNS_swigconstant(_moduleconnectorwrapper)
XTS_ID_VITAL_SIGNS = _moduleconnectorwrapper.XTS_ID_VITAL_SIGNS

_moduleconnectorwrapper.XTS_ID_SLEEPSTAGE_swigconstant(_moduleconnectorwrapper)
XTS_ID_SLEEPSTAGE = _moduleconnectorwrapper.XTS_ID_SLEEPSTAGE

_moduleconnectorwrapper.XTS_ID_TX_CENTER_FREQ_swigconstant(_moduleconnectorwrapper)
XTS_ID_TX_CENTER_FREQ = _moduleconnectorwrapper.XTS_ID_TX_CENTER_FREQ

_moduleconnectorwrapper.XTS_ID_LED_CONTROL_swigconstant(_moduleconnectorwrapper)
XTS_ID_LED_CONTROL = _moduleconnectorwrapper.XTS_ID_LED_CONTROL

_moduleconnectorwrapper.XTID_SSIC_ITEMNUMBER_swigconstant(_moduleconnectorwrapper)
XTID_SSIC_ITEMNUMBER = _moduleconnectorwrapper.XTID_SSIC_ITEMNUMBER

_moduleconnectorwrapper.XTID_SSIC_ORDERCODE_swigconstant(_moduleconnectorwrapper)
XTID_SSIC_ORDERCODE = _moduleconnectorwrapper.XTID_SSIC_ORDERCODE

_moduleconnectorwrapper.XTID_SSIC_FIRMWAREID_swigconstant(_moduleconnectorwrapper)
XTID_SSIC_FIRMWAREID = _moduleconnectorwrapper.XTID_SSIC_FIRMWAREID

_moduleconnectorwrapper.XTID_SSIC_VERSION_swigconstant(_moduleconnectorwrapper)
XTID_SSIC_VERSION = _moduleconnectorwrapper.XTID_SSIC_VERSION

_moduleconnectorwrapper.XTID_SSIC_BUILD_swigconstant(_moduleconnectorwrapper)
XTID_SSIC_BUILD = _moduleconnectorwrapper.XTID_SSIC_BUILD

_moduleconnectorwrapper.XTID_SSIC_SERIALNUMBER_swigconstant(_moduleconnectorwrapper)
XTID_SSIC_SERIALNUMBER = _moduleconnectorwrapper.XTID_SSIC_SERIALNUMBER

_moduleconnectorwrapper.XTID_SSIC_VERSIONLIST_swigconstant(_moduleconnectorwrapper)
XTID_SSIC_VERSIONLIST = _moduleconnectorwrapper.XTID_SSIC_VERSIONLIST

_moduleconnectorwrapper.XTID_SSIC_SYSTEMCOREID_swigconstant(_moduleconnectorwrapper)
XTID_SSIC_SYSTEMCOREID = _moduleconnectorwrapper.XTID_SSIC_SYSTEMCOREID

_moduleconnectorwrapper.XTID_SSIC_BOOTLOADER_swigconstant(_moduleconnectorwrapper)
XTID_SSIC_BOOTLOADER = _moduleconnectorwrapper.XTID_SSIC_BOOTLOADER

_moduleconnectorwrapper.XTID_SM_RUN_swigconstant(_moduleconnectorwrapper)
XTID_SM_RUN = _moduleconnectorwrapper.XTID_SM_RUN

_moduleconnectorwrapper.XTID_SM_NORMAL_swigconstant(_moduleconnectorwrapper)
XTID_SM_NORMAL = _moduleconnectorwrapper.XTID_SM_NORMAL

_moduleconnectorwrapper.XTID_SM_IDLE_swigconstant(_moduleconnectorwrapper)
XTID_SM_IDLE = _moduleconnectorwrapper.XTID_SM_IDLE

_moduleconnectorwrapper.XTID_SM_MANUAL_swigconstant(_moduleconnectorwrapper)
XTID_SM_MANUAL = _moduleconnectorwrapper.XTID_SM_MANUAL

_moduleconnectorwrapper.XTID_SM_STOP_swigconstant(_moduleconnectorwrapper)
XTID_SM_STOP = _moduleconnectorwrapper.XTID_SM_STOP

_moduleconnectorwrapper.XTID_FIM_LOOP_swigconstant(_moduleconnectorwrapper)
XTID_FIM_LOOP = _moduleconnectorwrapper.XTID_FIM_LOOP

_moduleconnectorwrapper.XTID_FIM_SEQUENTIAL_swigconstant(_moduleconnectorwrapper)
XTID_FIM_SEQUENTIAL = _moduleconnectorwrapper.XTID_FIM_SEQUENTIAL

_moduleconnectorwrapper.XTID_FIM_SINGLE_swigconstant(_moduleconnectorwrapper)
XTID_FIM_SINGLE = _moduleconnectorwrapper.XTID_FIM_SINGLE

_moduleconnectorwrapper.XTID_BAUDRATE_9600_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_9600 = _moduleconnectorwrapper.XTID_BAUDRATE_9600

_moduleconnectorwrapper.XTID_BAUDRATE_19200_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_19200 = _moduleconnectorwrapper.XTID_BAUDRATE_19200

_moduleconnectorwrapper.XTID_BAUDRATE_38400_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_38400 = _moduleconnectorwrapper.XTID_BAUDRATE_38400

_moduleconnectorwrapper.XTID_BAUDRATE_115200_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_115200 = _moduleconnectorwrapper.XTID_BAUDRATE_115200

_moduleconnectorwrapper.XTID_BAUDRATE_230400_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_230400 = _moduleconnectorwrapper.XTID_BAUDRATE_230400

_moduleconnectorwrapper.XTID_BAUDRATE_460800_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_460800 = _moduleconnectorwrapper.XTID_BAUDRATE_460800

_moduleconnectorwrapper.XTID_BAUDRATE_500000_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_500000 = _moduleconnectorwrapper.XTID_BAUDRATE_500000

_moduleconnectorwrapper.XTID_BAUDRATE_576000_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_576000 = _moduleconnectorwrapper.XTID_BAUDRATE_576000

_moduleconnectorwrapper.XTID_BAUDRATE_921600_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_921600 = _moduleconnectorwrapper.XTID_BAUDRATE_921600

_moduleconnectorwrapper.XTID_BAUDRATE_1000000_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_1000000 = _moduleconnectorwrapper.XTID_BAUDRATE_1000000

_moduleconnectorwrapper.XTID_BAUDRATE_2000000_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_2000000 = _moduleconnectorwrapper.XTID_BAUDRATE_2000000

_moduleconnectorwrapper.XTID_BAUDRATE_3000000_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_3000000 = _moduleconnectorwrapper.XTID_BAUDRATE_3000000

_moduleconnectorwrapper.XTID_BAUDRATE_4000000_swigconstant(_moduleconnectorwrapper)
XTID_BAUDRATE_4000000 = _moduleconnectorwrapper.XTID_BAUDRATE_4000000

_moduleconnectorwrapper.XTID_IOPIN_SETUP_INPUT_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_SETUP_INPUT = _moduleconnectorwrapper.XTID_IOPIN_SETUP_INPUT

_moduleconnectorwrapper.XTID_IOPIN_SETUP_OUTPUT_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_SETUP_OUTPUT = _moduleconnectorwrapper.XTID_IOPIN_SETUP_OUTPUT

_moduleconnectorwrapper.XTID_IOPIN_SETUP_PUSH_PULL_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_SETUP_PUSH_PULL = _moduleconnectorwrapper.XTID_IOPIN_SETUP_PUSH_PULL

_moduleconnectorwrapper.XTID_IOPIN_SETUP_INVERTED_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_SETUP_INVERTED = _moduleconnectorwrapper.XTID_IOPIN_SETUP_INVERTED

_moduleconnectorwrapper.XTID_IOPIN_SETUP_PULLUP_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_SETUP_PULLUP = _moduleconnectorwrapper.XTID_IOPIN_SETUP_PULLUP

_moduleconnectorwrapper.XTID_IOPIN_FEATURE_DISABLE_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_FEATURE_DISABLE = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_DISABLE

_moduleconnectorwrapper.XTID_IOPIN_FEATURE_DEFAULT_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_FEATURE_DEFAULT = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_DEFAULT

_moduleconnectorwrapper.XTID_IOPIN_FEATURE_PASSIVE_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_FEATURE_PASSIVE = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_PASSIVE

_moduleconnectorwrapper.XTID_IOPIN_FEATURE_PRESENCE_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_FEATURE_PRESENCE = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_PRESENCE

_moduleconnectorwrapper.XTID_IOPIN_FEATURE_MOVEMENT_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_FEATURE_MOVEMENT = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_MOVEMENT

_moduleconnectorwrapper.XTID_IOPIN_FEATURE_BREATHING_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_FEATURE_BREATHING = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_BREATHING

_moduleconnectorwrapper.XTID_IOPIN_FEATURE_NOPRESENCE_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_FEATURE_NOPRESENCE = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_NOPRESENCE

_moduleconnectorwrapper.XTID_IOPIN_FEATURE_LAST_swigconstant(_moduleconnectorwrapper)
XTID_IOPIN_FEATURE_LAST = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_LAST

_moduleconnectorwrapper.XTID_OUTPUT_CONTROL_DISABLE_swigconstant(_moduleconnectorwrapper)
XTID_OUTPUT_CONTROL_DISABLE = _moduleconnectorwrapper.XTID_OUTPUT_CONTROL_DISABLE

_moduleconnectorwrapper.XTID_OUTPUT_CONTROL_ENABLE_swigconstant(_moduleconnectorwrapper)
XTID_OUTPUT_CONTROL_ENABLE = _moduleconnectorwrapper.XTID_OUTPUT_CONTROL_ENABLE

_moduleconnectorwrapper.XTID_OUTPUT_CONTROL_DEBUG_swigconstant(_moduleconnectorwrapper)
XTID_OUTPUT_CONTROL_DEBUG = _moduleconnectorwrapper.XTID_OUTPUT_CONTROL_DEBUG

_moduleconnectorwrapper.XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE_swigconstant(_moduleconnectorwrapper)
XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE = _moduleconnectorwrapper.XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE

_moduleconnectorwrapper.XTID_OUTPUT_CONTROL_PD_FAST_ENABLE_swigconstant(_moduleconnectorwrapper)
XTID_OUTPUT_CONTROL_PD_FAST_ENABLE = _moduleconnectorwrapper.XTID_OUTPUT_CONTROL_PD_FAST_ENABLE

_moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_USE_DEFAULT_swigconstant(_moduleconnectorwrapper)
XTID_NOISEMAP_CONTROL_USE_DEFAULT = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_USE_DEFAULT

_moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_DISABLE_swigconstant(_moduleconnectorwrapper)
XTID_NOISEMAP_CONTROL_DISABLE = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_DISABLE

_moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_ENABLE_swigconstant(_moduleconnectorwrapper)
XTID_NOISEMAP_CONTROL_ENABLE = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_ENABLE

_moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_NONADAPTIVE_swigconstant(_moduleconnectorwrapper)
XTID_NOISEMAP_CONTROL_NONADAPTIVE = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_NONADAPTIVE

_moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_ADAPTIVE_swigconstant(_moduleconnectorwrapper)
XTID_NOISEMAP_CONTROL_ADAPTIVE = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_ADAPTIVE

_moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_USE_STORED_swigconstant(_moduleconnectorwrapper)
XTID_NOISEMAP_CONTROL_USE_STORED = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_USE_STORED

_moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_INIT_ON_RESET_swigconstant(_moduleconnectorwrapper)
XTID_NOISEMAP_CONTROL_INIT_ON_RESET = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_INIT_ON_RESET

_moduleconnectorwrapper.XTID_LED_MODE_OFF_swigconstant(_moduleconnectorwrapper)
XTID_LED_MODE_OFF = _moduleconnectorwrapper.XTID_LED_MODE_OFF

_moduleconnectorwrapper.XTID_LED_MODE_SIMPLE_swigconstant(_moduleconnectorwrapper)
XTID_LED_MODE_SIMPLE = _moduleconnectorwrapper.XTID_LED_MODE_SIMPLE

_moduleconnectorwrapper.XTID_LED_MODE_FULL_swigconstant(_moduleconnectorwrapper)
XTID_LED_MODE_FULL = _moduleconnectorwrapper.XTID_LED_MODE_FULL

_moduleconnectorwrapper.XTID_CENTER_FREQ_LOWBAND_swigconstant(_moduleconnectorwrapper)
XTID_CENTER_FREQ_LOWBAND = _moduleconnectorwrapper.XTID_CENTER_FREQ_LOWBAND

_moduleconnectorwrapper.XTID_CENTER_FREQ_HIGHBAND_swigconstant(_moduleconnectorwrapper)
XTID_CENTER_FREQ_HIGHBAND = _moduleconnectorwrapper.XTID_CENTER_FREQ_HIGHBAND

_moduleconnectorwrapper.XTID_MCP_ERROR_NOT_RECOGNIZED_swigconstant(_moduleconnectorwrapper)
XTID_MCP_ERROR_NOT_RECOGNIZED = _moduleconnectorwrapper.XTID_MCP_ERROR_NOT_RECOGNIZED

_moduleconnectorwrapper.XTS_VAL_RESP_STATE_BREATHING_swigconstant(_moduleconnectorwrapper)
XTS_VAL_RESP_STATE_BREATHING = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_BREATHING

_moduleconnectorwrapper.XTS_VAL_RESP_STATE_MOVEMENT_swigconstant(_moduleconnectorwrapper)
XTS_VAL_RESP_STATE_MOVEMENT = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_MOVEMENT

_moduleconnectorwrapper.XTS_VAL_RESP_STATE_MOVEMENT_TRACKING_swigconstant(_moduleconnectorwrapper)
XTS_VAL_RESP_STATE_MOVEMENT_TRACKING = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_MOVEMENT_TRACKING

_moduleconnectorwrapper.XTS_VAL_RESP_STATE_NO_MOVEMENT_swigconstant(_moduleconnectorwrapper)
XTS_VAL_RESP_STATE_NO_MOVEMENT = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_NO_MOVEMENT

_moduleconnectorwrapper.XTS_VAL_RESP_STATE_INITIALIZING_swigconstant(_moduleconnectorwrapper)
XTS_VAL_RESP_STATE_INITIALIZING = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_INITIALIZING

_moduleconnectorwrapper.XTS_VAL_RESP_STATE_ERROR_swigconstant(_moduleconnectorwrapper)
XTS_VAL_RESP_STATE_ERROR = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_ERROR

_moduleconnectorwrapper.XTS_VAL_RESP_STATE_UNKNOWN_swigconstant(_moduleconnectorwrapper)
XTS_VAL_RESP_STATE_UNKNOWN = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_UNKNOWN

_moduleconnectorwrapper.XTS_VAL_RESP_STATE_HEART_RATE_AND_BREATHING_swigconstant(_moduleconnectorwrapper)
XTS_VAL_RESP_STATE_HEART_RATE_AND_BREATHING = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_HEART_RATE_AND_BREATHING

_moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_NO_PRESENCE_swigconstant(_moduleconnectorwrapper)
XTS_VAL_PRESENCE_PRESENCESTATE_NO_PRESENCE = _moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_NO_PRESENCE

_moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_PRESENCE_swigconstant(_moduleconnectorwrapper)
XTS_VAL_PRESENCE_PRESENCESTATE_PRESENCE = _moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_PRESENCE

_moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_INITIALIZING_swigconstant(_moduleconnectorwrapper)
XTS_VAL_PRESENCE_PRESENCESTATE_INITIALIZING = _moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_INITIALIZING

_moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_UNKNOWN_swigconstant(_moduleconnectorwrapper)
XTS_VAL_PRESENCE_PRESENCESTATE_UNKNOWN = _moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_UNKNOWN
# This file is compatible with both classic and new-style classes.


