<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pymoduleconnector: pymoduleconnector.moduleconnectorwrapper.PyDataReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- Platform title -->
    <div class="page-title-bar container-fluid">
      <div id="projectalign" class="row">
        <div id="projectname" class="col-sm-12">pymoduleconnector
          &#160;<span id="projectnumber">1.6.2</span>
        </div>
        <div id="projectbrief" class="col-sm-12">A Python wrapper for XeThru ModuleConnector</div>
      </div>
    </div>
    <div class="topbar">
      <div class="container">
        <div id="titlearea">
          <div class="xethru-logo">
            <img src="xethru-logo_220x55HD.png" alt="Novelda XeThru web site" id="logo-image" />
          </div>
        </div>
        <!-- end header part -->
        <!-- Generated by Doxygen 1.8.12 -->
        <!--BEGIN MAIN-NAV AND SEARCHENGINE-->
        <div id="main-nav"></div>
        <!--END MAIN-NAV AND SEARCHENGINE-->
      </div>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pymoduleconnector</b></li><li class="navelem"><b>moduleconnectorwrapper</b></li><li class="navelem"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml">PyDataReader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader-members.xhtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pymoduleconnector.moduleconnectorwrapper.PyDataReader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml" title="The PyDataReader class allows reading of xethru data records from a recording. ">PyDataReader</a> class allows reading of xethru data records from a recording.  
 <a href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad02007207029a9ab693d0893f96701eb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#ad02007207029a9ab693d0893f96701eb">__init__</a> (self)</td></tr>
<tr class="memdesc:ad02007207029a9ab693d0893f96701eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>init</b>(XeThru::PyDataReader self) -&gt; <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml" title="The PyDataReader class allows reading of xethru data records from a recording. ">PyDataReader</a>  <a href="#ad02007207029a9ab693d0893f96701eb">More...</a><br /></td></tr>
<tr class="separator:ad02007207029a9ab693d0893f96701eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6cf3b4fd0d770062466a071743a87b"><td class="memItemLeft" align="right" valign="top"><a id="a5b6cf3b4fd0d770062466a071743a87b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>open</b> (self, meta_filename, depth=-1)</td></tr>
<tr class="separator:a5b6cf3b4fd0d770062466a071743a87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb3c4cec3f2ff9d5a84966bbad60674"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a1eb3c4cec3f2ff9d5a84966bbad60674">is_open</a> (self)</td></tr>
<tr class="memdesc:a1eb3c4cec3f2ff9d5a84966bbad60674"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_open(PyDataReader self) -&gt; bool  <a href="#a1eb3c4cec3f2ff9d5a84966bbad60674">More...</a><br /></td></tr>
<tr class="separator:a1eb3c4cec3f2ff9d5a84966bbad60674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d9ab5c94876677960fc763bfe1f10c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a78d9ab5c94876677960fc763bfe1f10c">close</a> (self)</td></tr>
<tr class="memdesc:a78d9ab5c94876677960fc763bfe1f10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">close(PyDataReader self)  <a href="#a78d9ab5c94876677960fc763bfe1f10c">More...</a><br /></td></tr>
<tr class="separator:a78d9ab5c94876677960fc763bfe1f10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431013ff5ca9ca471136c84702ff5082"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a431013ff5ca9ca471136c84702ff5082">at_end</a> (self)</td></tr>
<tr class="memdesc:a431013ff5ca9ca471136c84702ff5082"><td class="mdescLeft">&#160;</td><td class="mdescRight">at_end(PyDataReader self) -&gt; bool  <a href="#a431013ff5ca9ca471136c84702ff5082">More...</a><br /></td></tr>
<tr class="separator:a431013ff5ca9ca471136c84702ff5082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484cf503c0acd9b29742bd4b51bb4aae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a484cf503c0acd9b29742bd4b51bb4aae">read_record</a> (self)</td></tr>
<tr class="memdesc:a484cf503c0acd9b29742bd4b51bb4aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">read_record(PyDataReader self) -&gt; <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a>  <a href="#a484cf503c0acd9b29742bd4b51bb4aae">More...</a><br /></td></tr>
<tr class="separator:a484cf503c0acd9b29742bd4b51bb4aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669fb19723ccbfd0902e706c64826320"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a669fb19723ccbfd0902e706c64826320">peek_record</a> (self)</td></tr>
<tr class="memdesc:a669fb19723ccbfd0902e706c64826320"><td class="mdescLeft">&#160;</td><td class="mdescRight">peek_record(PyDataReader self) -&gt; <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a>  <a href="#a669fb19723ccbfd0902e706c64826320">More...</a><br /></td></tr>
<tr class="separator:a669fb19723ccbfd0902e706c64826320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660a5fac2b90e1534a2b49ae3430ffff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a660a5fac2b90e1534a2b49ae3430ffff">seek_ms</a> (self, position)</td></tr>
<tr class="memdesc:a660a5fac2b90e1534a2b49ae3430ffff"><td class="mdescLeft">&#160;</td><td class="mdescRight">seek_ms(PyDataReader self, int64_t position) -&gt; int  <a href="#a660a5fac2b90e1534a2b49ae3430ffff">More...</a><br /></td></tr>
<tr class="separator:a660a5fac2b90e1534a2b49ae3430ffff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b92b46c44725ee2bce909f7b1822fd2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a1b92b46c44725ee2bce909f7b1822fd2">seek_byte</a> (self, position)</td></tr>
<tr class="memdesc:a1b92b46c44725ee2bce909f7b1822fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">seek_byte(PyDataReader self, int64_t position) -&gt; int  <a href="#a1b92b46c44725ee2bce909f7b1822fd2">More...</a><br /></td></tr>
<tr class="separator:a1b92b46c44725ee2bce909f7b1822fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d35851b4623552ddd2b731f9c7ef55"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a81d35851b4623552ddd2b731f9c7ef55">set_filter</a> (self, data_types)</td></tr>
<tr class="memdesc:a81d35851b4623552ddd2b731f9c7ef55"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_filter(PyDataReader self, uint32_t data_types) -&gt; int  <a href="#a81d35851b4623552ddd2b731f9c7ef55">More...</a><br /></td></tr>
<tr class="separator:a81d35851b4623552ddd2b731f9c7ef55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705c594eea8fd18623b75337450c8628"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a705c594eea8fd18623b75337450c8628">get_filter</a> (self)</td></tr>
<tr class="memdesc:a705c594eea8fd18623b75337450c8628"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_filter(PyDataReader self) -&gt; uint32_t  <a href="#a705c594eea8fd18623b75337450c8628">More...</a><br /></td></tr>
<tr class="separator:a705c594eea8fd18623b75337450c8628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1e58304ec531a1a024e7b3d4e9906d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a7b1e58304ec531a1a024e7b3d4e9906d">get_start_epoch</a> (self)</td></tr>
<tr class="memdesc:a7b1e58304ec531a1a024e7b3d4e9906d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_start_epoch(PyDataReader self) -&gt; int64_t  <a href="#a7b1e58304ec531a1a024e7b3d4e9906d">More...</a><br /></td></tr>
<tr class="separator:a7b1e58304ec531a1a024e7b3d4e9906d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22916a88891aafb8144df25f402b3fbc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a22916a88891aafb8144df25f402b3fbc">get_duration</a> (self)</td></tr>
<tr class="memdesc:a22916a88891aafb8144df25f402b3fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_duration(PyDataReader self) -&gt; int64_t  <a href="#a22916a88891aafb8144df25f402b3fbc">More...</a><br /></td></tr>
<tr class="separator:a22916a88891aafb8144df25f402b3fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa261009bec3bd73ec34d9e87e34f2872"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#aa261009bec3bd73ec34d9e87e34f2872">get_size</a> (self)</td></tr>
<tr class="memdesc:aa261009bec3bd73ec34d9e87e34f2872"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_size(PyDataReader self) -&gt; int64_t  <a href="#aa261009bec3bd73ec34d9e87e34f2872">More...</a><br /></td></tr>
<tr class="separator:aa261009bec3bd73ec34d9e87e34f2872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab306acd00d6e7ad29ec0d21e6750134c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#ab306acd00d6e7ad29ec0d21e6750134c">get_data_types</a> (self)</td></tr>
<tr class="memdesc:ab306acd00d6e7ad29ec0d21e6750134c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_data_types(PyDataReader self) -&gt; uint32_t  <a href="#ab306acd00d6e7ad29ec0d21e6750134c">More...</a><br /></td></tr>
<tr class="separator:ab306acd00d6e7ad29ec0d21e6750134c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e73c279ae7aefa618bd2cca8c46edf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#ad9e73c279ae7aefa618bd2cca8c46edf">get_max_record_size</a> (self)</td></tr>
<tr class="memdesc:ad9e73c279ae7aefa618bd2cca8c46edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_max_record_size(PyDataReader self) -&gt; uint32_t  <a href="#ad9e73c279ae7aefa618bd2cca8c46edf">More...</a><br /></td></tr>
<tr class="separator:ad9e73c279ae7aefa618bd2cca8c46edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dac7662b2bad5c8e1e43802576d29d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml#a5dac7662b2bad5c8e1e43802576d29d4">get_session_id</a> (self)</td></tr>
<tr class="memdesc:a5dac7662b2bad5c8e1e43802576d29d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_session_id(PyDataReader self) -&gt; std::string  <a href="#a5dac7662b2bad5c8e1e43802576d29d4">More...</a><br /></td></tr>
<tr class="separator:a5dac7662b2bad5c8e1e43802576d29d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2943790efe0e1d992e15180324fa65aa"><td class="memItemLeft" align="right" valign="top"><a id="a2943790efe0e1d992e15180324fa65aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>this</b></td></tr>
<tr class="separator:a2943790efe0e1d992e15180324fa65aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml" title="The PyDataReader class allows reading of xethru data records from a recording. ">PyDataReader</a> class allows reading of xethru data records from a recording. </p>
<p>The <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml" title="The PyDataReader class allows reading of xethru data records from a recording. ">PyDataReader</a> class is a high level reader class. It can be used to read all data records stored on disk by the <em>DataRecorder</em> class. From the user's point of view the recording appears as one big file even if the recording may contain several files and folders on disk.</p>
<p>Data returned from this class is always aligned on complete data records as specified by the Xethru File Formats document for a given <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_type.xhtml" title="Proxy of C++ XeThru::DataType class. ">DataType</a>.</p>
<div class="fragment"></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Use <em>xethru_recording_meta.dat</em> as input argument to open. This file contains all required information for a particular recording.</dd></dl>
<p>See <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types. ">PyDataRecorder</a></p>
<p>C++ includes: PyDataReader.hpp </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad02007207029a9ab693d0893f96701eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02007207029a9ab693d0893f96701eb">&sect;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>init</b>(XeThru::PyDataReader self) -&gt; <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_reader.xhtml" title="The PyDataReader class allows reading of xethru data records from a recording. ">PyDataReader</a> </p>
<p>Constructs reader. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a431013ff5ca9ca471136c84702ff5082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431013ff5ca9ca471136c84702ff5082">&sect;&nbsp;</a></span>at_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.at_end </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>at_end(PyDataReader self) -&gt; bool </p>
<h2>Returns </h2>
<p>true if no more data records is available for reading, otherwise returns false.</p>
<p>See open, read_record </p>

</div>
</div>
<a id="a78d9ab5c94876677960fc763bfe1f10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d9ab5c94876677960fc763bfe1f10c">&sect;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>close(PyDataReader self) </p>
<p>Closes all meta files and data files opened by this class.</p>
<p>See open </p>

</div>
</div>
<a id="ab306acd00d6e7ad29ec0d21e6750134c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab306acd00d6e7ad29ec0d21e6750134c">&sect;&nbsp;</a></span>get_data_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.get_data_types </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_data_types(PyDataReader self) -&gt; uint32_t </p>
<p>This function returns a bitmask of all data types included in the recording.</p>
<p>The bitmask is an OR combination of <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_type.xhtml" title="Proxy of C++ XeThru::DataType class. ">DataType</a> flags. For example: BasebandIqDataType | SleepDataType.</p>
<h2>Returns </h2>
<p>a bitmask of all data types included in the recording. </p>

</div>
</div>
<a id="a22916a88891aafb8144df25f402b3fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22916a88891aafb8144df25f402b3fbc">&sect;&nbsp;</a></span>get_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.get_duration </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_duration(PyDataReader self) -&gt; int64_t </p>
<h2>Returns </h2>
<p>the total duration of the recording as milliseconds.</p>
<p>See get_start_epoch </p>

</div>
</div>
<a id="a705c594eea8fd18623b75337450c8628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705c594eea8fd18623b75337450c8628">&sect;&nbsp;</a></span>get_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.get_filter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_filter(PyDataReader self) -&gt; uint32_t </p>
<h2>Returns </h2>
<p>the filter used by read_record and peek_record. By default this value is all data types.</p>
<p>See set_filter </p>

</div>
</div>
<a id="ad9e73c279ae7aefa618bd2cca8c46edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e73c279ae7aefa618bd2cca8c46edf">&sect;&nbsp;</a></span>get_max_record_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.get_max_record_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_max_record_size(PyDataReader self) -&gt; uint32_t </p>
<h2>Returns </h2>
<p>the number of bytes of the largest record on disk included in the recording.</p>
<p>See read_record </p>

</div>
</div>
<a id="a5dac7662b2bad5c8e1e43802576d29d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dac7662b2bad5c8e1e43802576d29d4">&sect;&nbsp;</a></span>get_session_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.get_session_id </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_session_id(PyDataReader self) -&gt; std::string </p>
<h2>Returns </h2>
<p>the session id for the recording.</p>
<p>See <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_recording_options.xhtml#a3748f23da0a1e6582e7ac54ec11c400d" title="set_session_id(RecordingOptions self, std::string const &amp; id) ">RecordingOptions::set_session_id</a> </p>

</div>
</div>
<a id="aa261009bec3bd73ec34d9e87e34f2872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa261009bec3bd73ec34d9e87e34f2872">&sect;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.get_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_size(PyDataReader self) -&gt; int64_t </p>
<h2>Returns </h2>
<p>the total size of the recording as number of bytes. </p>

</div>
</div>
<a id="a7b1e58304ec531a1a024e7b3d4e9906d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1e58304ec531a1a024e7b3d4e9906d">&sect;&nbsp;</a></span>get_start_epoch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.get_start_epoch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_start_epoch(PyDataReader self) -&gt; int64_t </p>
<h2>Returns </h2>
<p>the start date/time for the recording as number of milliseconds since 1970.01.01.</p>
<p>See get_size </p>

</div>
</div>
<a id="a1eb3c4cec3f2ff9d5a84966bbad60674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb3c4cec3f2ff9d5a84966bbad60674">&sect;&nbsp;</a></span>is_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.is_open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_open(PyDataReader self) -&gt; bool </p>
<h2>Returns </h2>
<p>true if the recording is successfully opened, otherwise returns false</p>
<p>See open </p>

</div>
</div>
<a id="a669fb19723ccbfd0902e706c64826320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669fb19723ccbfd0902e706c64826320">&sect;&nbsp;</a></span>peek_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.peek_record </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>peek_record(PyDataReader self) -&gt; <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a> </p>
<p>Reads all bytes from a data record on disk and returns the <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a> without side effects (i.e.</p>
<p>if you call read after peek it will return the same data).</p>
<p>This is a convenience method that ensures all bytes from a record is read.</p>
<p>This method has no way of reporting error, however <em>DataRecord::is_valid</em> is set to true on success; otherwise set to false.</p>
<h2>Returns </h2>
<p>the <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a>.</p>
<p>See read_record, at_end, set_filter </p>

</div>
</div>
<a id="a484cf503c0acd9b29742bd4b51bb4aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484cf503c0acd9b29742bd4b51bb4aae">&sect;&nbsp;</a></span>read_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.read_record </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read_record(PyDataReader self) -&gt; <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a> </p>
<p>Reads all bytes from a data record on disk and returns the <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a>.</p>
<p>This is a convenience method that ensures all bytes from a record is read.</p>
<p>This method has no way of reporting error, however <em>DataRecord::is_valid</em> is set to true on success; otherwise set to false.</p>
<h2>Returns </h2>
<p>the <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a>.</p>
<p>See at_end, set_filter </p>

</div>
</div>
<a id="a1b92b46c44725ee2bce909f7b1822fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b92b46c44725ee2bce909f7b1822fd2">&sect;&nbsp;</a></span>seek_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.seek_byte </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>seek_byte(PyDataReader self, int64_t position) -&gt; int </p>
<p>Sets the current position as specified.</p>
<h2>Parameters </h2>
<ul>
<li><code>position</code> : Specifies the position as number of bytes.</li>
</ul>
<h2>Returns </h2>
<p>0 on success, otherwise returns 1</p>
<p>See seek_ms, get_size, at_end </p>

</div>
</div>
<a id="a660a5fac2b90e1534a2b49ae3430ffff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660a5fac2b90e1534a2b49ae3430ffff">&sect;&nbsp;</a></span>seek_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.seek_ms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>seek_ms(PyDataReader self, int64_t position) -&gt; int </p>
<p>Sets the current position as specified.</p>
<h2>Parameters </h2>
<ul>
<li><code>position</code> : Specifies the position as number of milliseconds.</li>
</ul>
<h2>Returns </h2>
<p>0 on success, otherwise returns 1</p>
<p>See seek_byte, get_duration, at_end </p>

</div>
</div>
<a id="a81d35851b4623552ddd2b731f9c7ef55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d35851b4623552ddd2b731f9c7ef55">&sect;&nbsp;</a></span>set_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataReader.set_filter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set_filter(PyDataReader self, uint32_t data_types) -&gt; int </p>
<p>Sets the filter used by read_record and peek_record.</p>
<p>The filter is used to specify the kind of data records returned by read_record and peek_record.</p>
<p>By default, the filter is set to all data types.</p>
<h2>Parameters </h2>
<ul>
<li><code>data_types</code> : Specifies the filter as a bitmask that consists of a combination of <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_type.xhtml" title="Proxy of C++ XeThru::DataType class. ">DataType</a> flags. These flags can be combined with the bitwise OR operator (|). For example BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can also be specified.</li>
</ul>
<h2>Returns </h2>
<p>0 success, otherwise returns 1</p>
<p>See read_record, peek_record </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pymoduleconnector/moduleconnectorwrapper/__init__.py</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/>
 <address class="footer">
 Copyright &copy; 2016 Novelda AS - <a href="http://www.xethru.com">www.xehtru.com</a><br />
 <small>
  Generated by &#160;<a href="http://www.doxygen.org/index.html">
  <img class="footer" src="doxygen.png" alt="doxygen"/>
  </a> 1.8.12
 </small>
 </address>
</body>
</html>
