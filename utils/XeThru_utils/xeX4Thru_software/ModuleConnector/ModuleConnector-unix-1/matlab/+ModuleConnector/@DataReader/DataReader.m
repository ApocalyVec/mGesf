classdef DataReader
    % The DataReader class allows reading of xethru data records from a recording generated by DataRecorder.
    %
    % The DataReader class is a high level reader class. It can be used to read all data records
    % stored on disk by the DataRecorder class. From the user's point of view the recording
    % appears as one big file even if the recording may contain several files and folders on disk.
    %
    % Data returned from this class is always aligned on complete data records as specified by
    % the Xethru File Formats document for a given DataType.
    %
    % In some cases it might be more desirable to read records directly into a raw buffer. In such
    % case it is *important* to note that if the buffer is not big enough to hold the entire record,
    % the buffer will contain an incomplete record. Use get_max_record_size to avoid this:
    
    properties
        lib_name = 'libModuleConnector';
    end
    
    properties (SetAccess = private)
    	dataReader_instance;  % Libpointer to C/C++ library instance
        dataRecorderInterface   % Layer one wrapper class for recording API
    end
    
    properties (SetAccess = private, Hidden) % Read record buffers
        
        rr_max_size = 700;
        rr_data        = libpointer('uint8Ptr',zeros(700,1));
        rr_size        = libpointer('uint32Ptr',0);
        rr_data_type   = libpointer('uint32Ptr',0);
        rr_epoch       = libpointer('int64Ptr',0);
        rr_user_header = libpointer('uint8Ptr',0);
        
    end
    
    methods
        
        %% Methods for data reader
        function status = open(this, meta_filename, depth)
            %OPEN Opens a recording specified by the given meta filename.
            %
            % One recording may contain several meta files,
            % for example as a result of file/directory splitting. The meta file contains information about which files
            % and data types were written to disk during a recording session. Common for all use cases is that
            % *xethru_recording_meta.dat* is always present in the output folder generated by DataRecorder. Use that file
            % as input argument to this function.
            %
            % Input:
            % - meta_filename - Specifies which recording (*xethru_recording_meta.dat*) to open
            % - depth - Specifies the number of meta files to open in 'chained mode'.
            % By default, this parameter is -1 (automatically open all files, i.e. the entire recording).
            %
            % Output:
            % - return status 0 on success, otherwise returns 1
            if nargin < 3, depth = -1; end
            status = this.dataRecorderInterface.data_reader_open(this.dataReader_instance, meta_filename, length(meta_filename), depth);
        end
        
        function close(this)
            %CLOSE Closes all meta files and data files opened by this class.
            this.dataRecorderInterface.data_reader_close(this.dataReader_instance);
        end
        
        function ret = is_open(this)
            %IS_OPEN Return true if the recording is successfully opened, otherwise returns false
            ret = this.dataRecorderInterface.data_reader_is_open(this.dataReader_instance);
        end
        
        function ret = at_end(this)
            %AT_END Return true if no more data records is available for reading, otherwise returns false.
            ret = this.dataRecorderInterface.data_reader_at_end(this.dataReader_instance);
        end
        
        function [record,status] = read_record(this)
            %READ_RECORD Reads at most max_size bytes from disk into data and updates the output parameters.
            %
            % Upon success, data contains a complete record as stored on disk for a particular
            % data type. The format is specified by the Xethru File Formats document unless is_user_header
            % is true. In such case data contains custom user header as supplied by the user.
            %
            % Reading past the end is considered an error. Thus, always check at_end() before
            % calling this function.
            %
            % Output:
            % - record                 - A data struct containing the record data
            % - record.data            - Specifies the read record data.
            % - record.size            - Specifies the actual number of bytes read.
            % - record.data_type       - Specifies the DataType for the record.
            % - record.epoch           - Specifies the date/time the record was written to disk as number of milliseconds since 1970.01.01.
            % - record.is_user_header  - Set to true if the record is custom user header, otherwise false.
            % - status                 - 0 on success, otherwise returns 1.
            status = this.dataRecorderInterface.data_reader_read_record(this.dataReader_instance, this.rr_data, this.rr_max_size, this.rr_size, this.rr_data_type, this.rr_epoch, this.rr_user_header);
            record.data            = double(this.rr_data.Value);
            record.size            = double(this.rr_size.Value);
            record.data = record.data(1:record.size);
            record.data_type       = double(this.rr_data_type.Value);
            record.epoch           = double(this.rr_epoch.Value);
            record.is_user_header  = double(this.rr_user_header.Value);
        end
        
        function [record,status] = peek_record(this)
            %PEEK_RECORD Reads at most max_size bytes from disk into data and updates the output parameters
            %without side effects (i.e. if you call read after peek it will return the same data).
            %
            % Upon success, data contains a complete record as stored on disk for a particular
            % data type. The format is specified by the Xethru File Formats document unless is_user_header
            % is true. In such case data contains custom user header as supplied by the user.
            %
            % Reading past the end is considered an error. Thus, always check at_end() before
            % calling this function.
            %
            % Output:
            % - record                 - A data struct containing the record data
            % - record.data            - Specifies the read record data.
            % - record.size            - Specifies the actual number of bytes read.
            % - record.data_type       - Specifies the DataType for the record.
            % - record.epoch           - Specifies the date/time the record was written to disk as number of milliseconds since 1970.01.01.
            % - record.is_user_header  - Set to true if the record is custom user header, otherwise false.
            % - status                 - 0 on success, otherwise returns 1.
            status = this.dataRecorderInterface.data_reader_peek_record(this.dataReader_instance, this.rr_data, this.rr_max_size, this.rr_size, this.rr_data_type, this.rr_epoch, this.rr_user_header);
            record.data            = double(this.rr_data.Value);
            record.size            = double(this.rr_size.Value);
            record.data_type       = double(this.rr_data_type.Value);
            record.epoch           = double(this.rr_epoch.Value);
            record.is_user_header  = double(this.rr_user_header.Value);
        end
        
        function status = seek_ms(this, position)
            %SEEK_MS Sets the current position as specified in milliseconds
            %by position.
            status = this.dataRecorderInterface.data_reader_seek_ms(this.dataReader_instance, position);
        end
        
        function status = seek_byte(this, position)
            %SEEK_BYTE Sets the current position as specified in number of
            %bytes by position.
            status = this.dataRecorderInterface.data_reader_seek_byte(this.dataReader_instance, position);
        end
        
        function status = set_filter(this, data_types)
            %SET_FILTER Sets the filter used by read_record and peek_record.
            %
            % The filter is used to specify the kind of data records
            % returned by read_record and peek_record.
            %
            % By default, the filter is set to all data types.
            %
            % data_types Specifies the filter as a bitmask that consists of a combination of DataType flags.
            % A convenience value AllDataTypes can also be specified.
            %
            % For enumeration of the DataType flags, see
            % ModuleConnector.DataRecorderInterface
            status = this.dataRecorderInterface.data_reader_set_filter(this.dataReader_instance, data_types);
        end
        
        function [data_types,status] = get_filter(this)
            %GET_FILTER Return the filter used by read_record and peek_record.
            %
            % By default this value is all data types.
            dataTypesPtr = libpointer('uint32Ptr', 0);
            status = this.dataRecorderInterface.data_reader_get_filter(this.dataReader_instance,dataTypesPtr);
            data_types= double(dataTypesPtr.Value);
            clear dataTypesPtr;
        end
        
        function [start_epoch,status] = get_start_epoch(this)
            %GET_START_EPOCH Return the total duration of the recording as milliseconds.
            startEpochPtr = libpointer('int64Ptr',0);
            status = this.dataRecorderInterface.data_reader_get_start_epoch(this.dataReader_instance, startEpochPtr);
            start_epoch = double(startEpochPtr.Value);
            clear startEpochPtr;
        end
        
        function [dur,status] = get_duration(this)
            %GET_DURATION Return the total duration of the recording as milliseconds.
            durPtr = libpointer('int64Ptr',0);
            status = this.dataRecorderInterface.data_reader_get_duration(this.dataReader_instance, durPtr);
            dur = double(durPtr.Value);
            clear durPtr;
        end
        
        function [size,status] = get_size(this)
            %GET_SIZE Return the total size of the recording as number of bytes.
            sizePtr = libpointer('int64Ptr',0);
            status = this.dataRecorderInterface.data_reader_get_size(this.dataReader_instance, sizePtr);
            size = double(sizePtr.Value);
            clear sizePtr;
        end
        
        function [data_types,status] = get_data_types(this)
            %GET_DATA_TYPES This function returns a bitmask of all data types included in the recording.
            dataTypesPtr = libpointer('uint32Ptr',0);
            status = this.dataRecorderInterface.data_reader_get_data_types(this.dataReader_instance, dataTypesPtr);
            data_types = double(dataTypesPtr.Value);
            clear dataTypesPtr;
        end
             
        function [max_size,status] = get_max_record_size(this)
            %GET_MAX_RECORD_SIZE Return the number of bytes of the largest record on disk included in the recording.
            maxRecSizePtr = libpointer('uint32Ptr',0);
            status = this.dataRecorderInterface.data_reader_get_max_record_size(this.dataReader_instance, maxRecSizePtr);
            max_size = double(maxRecSizePtr.Value);
            clear maxRecSizePtr;
        end
        
        function [session_id,size,status] = get_session_id(this)
            %GET_SESSION_ID Return the number of bytes of the largest record on disk included in the recording.
            maxLength = 100;
            sessionIdPtr = libpointer('string',blanks(maxLength));
            sizePtr = libpointer('uint32Ptr',0);
            [status,~,session_id] = this.dataRecorderInterface.data_reader_get_session_id(this.dataReader_instance,sessionIdPtr, sizePtr, maxLength);
            size = sizePtr.Value;
            clear sessionIdPtr sizePtr;
        end
        
    end
    
    methods (Static)
        function data_types_array = convertDataTypesBitmaskToArray(data_types_bitmask)
            % Static method for converting the data_types bitmask to array.
            i = 32;
            data_types_array = zeros(1,i);
            ctr = 1;
            while i >= 0
                if data_types_bitmask - 2^i >= 0
                    data_types_array(ctr) = 1;
                    data_types_bitmask = data_types_bitmask - 2^i;
                    ctr = ctr+1;
                end
                i = i-1;
            end            
            data_types_array = fliplr(data_types_array);
        end
    end
    
    methods
        
        %% Constructor
        function dr = DataReader(lib_name)
            % Constructor
            
            if nargin > 0, dr.lib_name = lib_name; end
            
            % Get DataRecorderInterface layer one wrapper class.
            dr.dataRecorderInterface = ModuleConnector.DataRecorderInterface(dr.lib_name);
            
            % Get DataReader libpointer instance.
            dr.dataReader_instance = calllib(dr.lib_name,'data_reader_create');
            
        end
            
        %% Destructor
        function delete( this )
            % Destructor
            
            % Destroy data reader.
            calllib(this.lib_name, 'data_reader_destroy',this.dataReader_instance);
            clear('this.dataReader_instance');
        end
        
    end
    
end

