<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ModuleConnector: XeThru::DataReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- Platform title -->
    <div class="page-title-bar container-fluid">
      <div id="projectalign" class="row">
        <div id="projectname" class="col-sm-12">ModuleConnector
          &#160;<span id="projectnumber">1.6.2</span>
        </div>
        <div id="projectbrief" class="col-sm-12">Project brief</div>
      </div>
    </div>
    <div class="topbar">
      <div class="container">
        <div id="titlearea">
          <div class="xethru-logo">
            <img src="xethru-logo_220x55HD.png" alt="Novelda XeThru web site" id="logo-image" />
          </div>
        </div>
        <!-- end header part -->
        <!-- Generated by Doxygen 1.8.12 -->
        <!--BEGIN MAIN-NAV AND SEARCHENGINE-->
        <div id="main-nav"></div>
        <!--END MAIN-NAV AND SEARCHENGINE-->
      </div>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_xe_thru.xhtml">XeThru</a></li><li class="navelem"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml">DataReader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_xe_thru_1_1_data_reader-members.xhtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XeThru::DataReader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_xe_thru_1_1_data_reader.xhtml" title="The DataReader class allows reading of xethru data records from a recording generated by DataRecorder...">DataReader</a> class allows reading of xethru data records from a recording generated by <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml">DataRecorder</a>.  
 <a href="class_xe_thru_1_1_data_reader.xhtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_data_reader_8hpp_source.xhtml">DataReader.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5f4a1bc537931898300e24c49ed29078"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a5f4a1bc537931898300e24c49ed29078">DataReader</a> ()</td></tr>
<tr class="memdesc:a5f4a1bc537931898300e24c49ed29078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs reader.  <a href="#a5f4a1bc537931898300e24c49ed29078">More...</a><br /></td></tr>
<tr class="separator:a5f4a1bc537931898300e24c49ed29078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0bb4dae647cb16b3c5a9d046a32109"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#aed0bb4dae647cb16b3c5a9d046a32109">~DataReader</a> ()</td></tr>
<tr class="memdesc:aed0bb4dae647cb16b3c5a9d046a32109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the reader.  <a href="#aed0bb4dae647cb16b3c5a9d046a32109">More...</a><br /></td></tr>
<tr class="separator:aed0bb4dae647cb16b3c5a9d046a32109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdad4516ec41f83dc6aefd0af6adc51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0bdad4516ec41f83dc6aefd0af6adc51">open</a> (const std::string &amp;meta_filename, int depth=-1)</td></tr>
<tr class="memdesc:a0bdad4516ec41f83dc6aefd0af6adc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a recording specified by the given meta filename.  <a href="#a0bdad4516ec41f83dc6aefd0af6adc51">More...</a><br /></td></tr>
<tr class="separator:a0bdad4516ec41f83dc6aefd0af6adc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5f066bb4abf600cd15b4784a83b8ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#aca5f066bb4abf600cd15b4784a83b8ec">is_open</a> () const</td></tr>
<tr class="separator:aca5f066bb4abf600cd15b4784a83b8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e01deed041ff7cf5d82154e82b4c375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a8e01deed041ff7cf5d82154e82b4c375">close</a> ()</td></tr>
<tr class="memdesc:a8e01deed041ff7cf5d82154e82b4c375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes all meta files and data files opened by this class.  <a href="#a8e01deed041ff7cf5d82154e82b4c375">More...</a><br /></td></tr>
<tr class="separator:a8e01deed041ff7cf5d82154e82b4c375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dff9bce58c2fef4ba92846479819dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end</a> () const</td></tr>
<tr class="separator:a45dff9bce58c2fef4ba92846479819dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d54098add7ad28cf353134daf7951fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe">read_record</a> (uint8_t *data, uint32_t max_size, uint32_t *size, uint32_t *data_type, int64_t *epoch, uint8_t *is_user_header)</td></tr>
<tr class="memdesc:a0d54098add7ad28cf353134daf7951fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads at most max_size bytes from disk into <em>data</em> and updates the output parameters.  <a href="#a0d54098add7ad28cf353134daf7951fe">More...</a><br /></td></tr>
<tr class="separator:a0d54098add7ad28cf353134daf7951fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c0e0ef1de9c6459a6f8e1f76a0b818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xe_thru_1_1_data_record.xhtml">DataRecord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a82c0e0ef1de9c6459a6f8e1f76a0b818">read_record</a> ()</td></tr>
<tr class="memdesc:a82c0e0ef1de9c6459a6f8e1f76a0b818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all bytes from a data record on disk and returns the <a class="el" href="struct_xe_thru_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a>.  <a href="#a82c0e0ef1de9c6459a6f8e1f76a0b818">More...</a><br /></td></tr>
<tr class="separator:a82c0e0ef1de9c6459a6f8e1f76a0b818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed2620db178415f86c2cc834ac12731"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#aaed2620db178415f86c2cc834ac12731">peek_record</a> (uint8_t *data, uint32_t max_size, uint32_t *size, uint32_t *data_type, int64_t *epoch, uint8_t *is_user_header)</td></tr>
<tr class="memdesc:aaed2620db178415f86c2cc834ac12731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads at most max_size bytes from disk into <em>data</em> and updates the output parameters without side effects (i.e.  <a href="#aaed2620db178415f86c2cc834ac12731">More...</a><br /></td></tr>
<tr class="separator:aaed2620db178415f86c2cc834ac12731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa80ee973b35890a12f195d82dfe38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xe_thru_1_1_data_record.xhtml">DataRecord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0aa80ee973b35890a12f195d82dfe38c">peek_record</a> ()</td></tr>
<tr class="memdesc:a0aa80ee973b35890a12f195d82dfe38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all bytes from a data record on disk and returns the <a class="el" href="struct_xe_thru_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a> without side effects (i.e.  <a href="#a0aa80ee973b35890a12f195d82dfe38c">More...</a><br /></td></tr>
<tr class="separator:a0aa80ee973b35890a12f195d82dfe38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86576128946975370a484bd7e8b52c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#ac86576128946975370a484bd7e8b52c9">seek_ms</a> (int64_t position)</td></tr>
<tr class="memdesc:ac86576128946975370a484bd7e8b52c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current position as specified.  <a href="#ac86576128946975370a484bd7e8b52c9">More...</a><br /></td></tr>
<tr class="separator:ac86576128946975370a484bd7e8b52c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b5e8f4d82631c3a3e160d4b11eb0fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#ab5b5e8f4d82631c3a3e160d4b11eb0fe">seek_byte</a> (int64_t position)</td></tr>
<tr class="memdesc:ab5b5e8f4d82631c3a3e160d4b11eb0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current position as specified.  <a href="#ab5b5e8f4d82631c3a3e160d4b11eb0fe">More...</a><br /></td></tr>
<tr class="separator:ab5b5e8f4d82631c3a3e160d4b11eb0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0003e1d96e165d4095922244de9e726b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0003e1d96e165d4095922244de9e726b">set_filter</a> (uint32_t data_types)</td></tr>
<tr class="memdesc:a0003e1d96e165d4095922244de9e726b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter used by <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe">read_record</a> and <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#aaed2620db178415f86c2cc834ac12731">peek_record</a>.  <a href="#a0003e1d96e165d4095922244de9e726b">More...</a><br /></td></tr>
<tr class="separator:a0003e1d96e165d4095922244de9e726b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7502daa491ce32a6fbaad1faa8e528bd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a7502daa491ce32a6fbaad1faa8e528bd">get_filter</a> () const</td></tr>
<tr class="separator:a7502daa491ce32a6fbaad1faa8e528bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f76f54b74ce10b879981b06c952e66"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a04f76f54b74ce10b879981b06c952e66">get_start_epoch</a> () const</td></tr>
<tr class="separator:a04f76f54b74ce10b879981b06c952e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb03243e6bc40adc5d8a2b0a4ee8aea"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a4bb03243e6bc40adc5d8a2b0a4ee8aea">get_duration</a> () const</td></tr>
<tr class="separator:a4bb03243e6bc40adc5d8a2b0a4ee8aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf13744b104619a4941caebb6cb807c7"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#adf13744b104619a4941caebb6cb807c7">get_size</a> () const</td></tr>
<tr class="separator:adf13744b104619a4941caebb6cb807c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267710bf160046318ddd699a7b785b25"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a267710bf160046318ddd699a7b785b25">get_data_types</a> () const</td></tr>
<tr class="memdesc:a267710bf160046318ddd699a7b785b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a bitmask of all data types included in the recording.  <a href="#a267710bf160046318ddd699a7b785b25">More...</a><br /></td></tr>
<tr class="separator:a267710bf160046318ddd699a7b785b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e24f183f1d515e8aeee3fcf551bd00"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a25e24f183f1d515e8aeee3fcf551bd00">get_max_record_size</a> () const</td></tr>
<tr class="separator:a25e24f183f1d515e8aeee3fcf551bd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab7aeab6d5aac670f9272bf0b04fbc4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#aaab7aeab6d5aac670f9272bf0b04fbc4">get_session_id</a> () const</td></tr>
<tr class="separator:aaab7aeab6d5aac670f9272bf0b04fbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e405be2138b7a3fa778db429a215c3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a95e405be2138b7a3fa778db429a215c3">get_meta_version</a> () const</td></tr>
<tr class="separator:a95e405be2138b7a3fa778db429a215c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79ac5eb06eaf128d1d155b26e3235be"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#ab79ac5eb06eaf128d1d155b26e3235be">get_profile_id</a> () const</td></tr>
<tr class="separator:ab79ac5eb06eaf128d1d155b26e3235be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_xe_thru_1_1_data_reader.xhtml" title="The DataReader class allows reading of xethru data records from a recording generated by DataRecorder...">DataReader</a> class allows reading of xethru data records from a recording generated by <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml">DataRecorder</a>. </p>
<p>The <a class="el" href="class_xe_thru_1_1_data_reader.xhtml" title="The DataReader class allows reading of xethru data records from a recording generated by DataRecorder...">DataReader</a> class is a high level reader class. It can be used to read all data records stored on disk by the <em><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types to disk. ">DataRecorder</a></em> class. From the user's point of view the recording appears as one big file even if the recording may contain several files and folders on disk.</p>
<p>Data returned from this class is always aligned on complete data records as specified by the Xethru File Formats document for a given <a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>.</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespace_xe_thru.xhtml">XeThru</a>;</div><div class="line"></div><div class="line">    <a class="code" href="class_xe_thru_1_1_data_reader.xhtml">DataReader</a> reader;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (reader.<a class="code" href="class_xe_thru_1_1_data_reader.xhtml#a0bdad4516ec41f83dc6aefd0af6adc51">open</a>(meta_filename) != 0) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ERROR: failed to open recording&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Only interested in &#39;BasebandApDataType&#39; and &#39;SleepDataType&#39;</span></div><div class="line">    reader.<a class="code" href="class_xe_thru_1_1_data_reader.xhtml#a0003e1d96e165d4095922244de9e726b">set_filter</a>(BasebandApDataType | SleepDataType);</div><div class="line"></div><div class="line">    <span class="comment">// Read all records</span></div><div class="line">    <span class="keywordflow">while</span> (!reader.<a class="code" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end</a>()) {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_xe_thru_1_1_data_record.xhtml">DataRecord</a> record = reader.<a class="code" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe">read_record</a>();</div><div class="line">        <span class="keywordflow">if</span> (!record.<a class="code" href="struct_xe_thru_1_1_data_record.xhtml#a838b0261e3b4b676cb7e02a9bbd4e78e">is_valid</a>) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ERROR: failed to read record&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// record.data contains data fields (bytes) as specified by the</span></div><div class="line">        <span class="comment">// XeThru File Formats document unless record.is_user_header is true.</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;read record of data type: &quot;</span> &lt;&lt; record.<a class="code" href="struct_xe_thru_1_1_data_record.xhtml#a16654cf06464f8810819eb72bd191166">data_type</a></div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, size: &quot;</span> &lt;&lt; record.<a class="code" href="struct_xe_thru_1_1_data_record.xhtml#a48acf596179076a1a5c0212650a1c371">data</a>.size() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">if</span> (record.<a class="code" href="struct_xe_thru_1_1_data_record.xhtml#a12cc84a73f806e5303524bbd880e68f3">is_user_header</a>)</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;(custom user header)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">switch</span> (record.<a class="code" href="struct_xe_thru_1_1_data_record.xhtml#a16654cf06464f8810819eb72bd191166">data_type</a>) {</div><div class="line">        <span class="keywordflow">case</span> BasebandApDataType:</div><div class="line">            process_baseband_ap(record);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> SleepDataType:</div><div class="line">            process_sleep(record);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">            assert(<span class="keyword">false</span>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Use <em>xethru_recording_meta.dat</em> as input argument to <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0bdad4516ec41f83dc6aefd0af6adc51">open</a>. This file contains all required information for a particular recording.</dd></dl>
<p>In some cases it might be more desirable to read records directly into a raw buffer. In such case it is <em>important</em> to note that if the buffer is not big enough to hold the entire record, the buffer will contain an incomplete record. Use <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a25e24f183f1d515e8aeee3fcf551bd00">get_max_record_size</a> to avoid this:</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> uint32_t max_record_size = reader.<a class="code" href="class_xe_thru_1_1_data_reader.xhtml#a25e24f183f1d515e8aeee3fcf551bd00">get_max_record_size</a>();</div><div class="line">    std::unique_ptr&lt;uint8_t[]&gt; buffer(<span class="keyword">new</span> uint8_t[max_record_size]);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!reader.<a class="code" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end</a>()) {</div><div class="line">        uint32_t record_size;</div><div class="line">        uint32_t data_type;</div><div class="line">        int64_t epoch;</div><div class="line">        uint8_t is_user_header;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (reader.<a class="code" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe">read_record</a>(buffer.get(), max_record_size, &amp;record_size, &amp;data_type, &amp;epoch, &amp;is_user_header) != 0) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ERROR: failed to read record&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types to disk. ">DataRecorder</a>, <a class="el" href="class_xe_thru_1_1_data_player.xhtml" title="The DataPlayer class allows playback of telegrams / binary packets from a recording generated by Data...">DataPlayer</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5f4a1bc537931898300e24c49ed29078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4a1bc537931898300e24c49ed29078">&sect;&nbsp;</a></span>DataReader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::DataReader::DataReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs reader. </p>

</div>
</div>
<a id="aed0bb4dae647cb16b3c5a9d046a32109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0bb4dae647cb16b3c5a9d046a32109">&sect;&nbsp;</a></span>~DataReader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::DataReader::~DataReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the reader. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a45dff9bce58c2fef4ba92846479819dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dff9bce58c2fef4ba92846479819dd">&sect;&nbsp;</a></span>at_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XeThru::DataReader::at_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if no more data records is available for reading, otherwise returns false. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0bdad4516ec41f83dc6aefd0af6adc51" title="Opens a recording specified by the given meta filename. ">open</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe" title="Reads at most max_size bytes from disk into data and updates the output parameters. ">read_record</a> </dd></dl>

</div>
</div>
<a id="a8e01deed041ff7cf5d82154e82b4c375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e01deed041ff7cf5d82154e82b4c375">&sect;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XeThru::DataReader::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes all meta files and data files opened by this class. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0bdad4516ec41f83dc6aefd0af6adc51" title="Opens a recording specified by the given meta filename. ">open</a> </dd></dl>

</div>
</div>
<a id="a267710bf160046318ddd699a7b785b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267710bf160046318ddd699a7b785b25">&sect;&nbsp;</a></span>get_data_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XeThru::DataReader::get_data_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a bitmask of all data types included in the recording. </p>
<p>The bitmask is an OR combination of <a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> flags. For example: BasebandIqDataType | SleepDataType.</p>
<dl class="section return"><dt>Returns</dt><dd>a bitmask of all data types included in the recording. </dd></dl>

</div>
</div>
<a id="a4bb03243e6bc40adc5d8a2b0a4ee8aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb03243e6bc40adc5d8a2b0a4ee8aea">&sect;&nbsp;</a></span>get_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XeThru::DataReader::get_duration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total duration of the recording as milliseconds. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a04f76f54b74ce10b879981b06c952e66">get_start_epoch</a> </dd></dl>

</div>
</div>
<a id="a7502daa491ce32a6fbaad1faa8e528bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7502daa491ce32a6fbaad1faa8e528bd">&sect;&nbsp;</a></span>get_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XeThru::DataReader::get_filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the filter used by <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe">read_record</a> and <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#aaed2620db178415f86c2cc834ac12731">peek_record</a>. By default this value is all data types. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0003e1d96e165d4095922244de9e726b" title="Sets the filter used by read_record and peek_record. ">set_filter</a> </dd></dl>

</div>
</div>
<a id="a25e24f183f1d515e8aeee3fcf551bd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e24f183f1d515e8aeee3fcf551bd00">&sect;&nbsp;</a></span>get_max_record_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XeThru::DataReader::get_max_record_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of bytes of the largest record on disk included in the recording. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe" title="Reads at most max_size bytes from disk into data and updates the output parameters. ">read_record</a> </dd></dl>

</div>
</div>
<a id="a95e405be2138b7a3fa778db429a215c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e405be2138b7a3fa778db429a215c3">&sect;&nbsp;</a></span>get_meta_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XeThru::DataReader::get_meta_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the version number of the meta file format. </dd></dl>

</div>
</div>
<a id="ab79ac5eb06eaf128d1d155b26e3235be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79ac5eb06eaf128d1d155b26e3235be">&sect;&nbsp;</a></span>get_profile_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XeThru::DataReader::get_profile_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the profile id used by the module during recording, or 0 if unknown. </dd></dl>

</div>
</div>
<a id="aaab7aeab6d5aac670f9272bf0b04fbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab7aeab6d5aac670f9272bf0b04fbc4">&sect;&nbsp;</a></span>get_session_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XeThru::DataReader::get_session_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the session id for the recording. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_recording_options.xhtml#acc21fccb62a4ec3a3432ead88ce746d3" title="Sets the session id as specified, overriding the default constructed value which is an universally un...">RecordingOptions::set_session_id</a> </dd></dl>

</div>
</div>
<a id="adf13744b104619a4941caebb6cb807c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf13744b104619a4941caebb6cb807c7">&sect;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XeThru::DataReader::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total size of the recording as number of bytes. </dd></dl>

</div>
</div>
<a id="a04f76f54b74ce10b879981b06c952e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f76f54b74ce10b879981b06c952e66">&sect;&nbsp;</a></span>get_start_epoch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XeThru::DataReader::get_start_epoch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the start date/time for the recording as number of milliseconds since 1970.01.01. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#adf13744b104619a4941caebb6cb807c7">get_size</a> </dd></dl>

</div>
</div>
<a id="aca5f066bb4abf600cd15b4784a83b8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5f066bb4abf600cd15b4784a83b8ec">&sect;&nbsp;</a></span>is_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XeThru::DataReader::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the recording is successfully opened, otherwise returns false </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0bdad4516ec41f83dc6aefd0af6adc51" title="Opens a recording specified by the given meta filename. ">open</a> </dd></dl>

</div>
</div>
<a id="a0bdad4516ec41f83dc6aefd0af6adc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bdad4516ec41f83dc6aefd0af6adc51">&sect;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::DataReader::open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>meta_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a recording specified by the given meta filename. </p>
<p>One recording may contain several meta files, for example as a result of file/directory splitting. The meta file contains information about which files and data types were written to disk during a recording session. Common for all use cases is that <em>xethru_recording_meta.dat</em> is always present in the output folder generated by <em><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types to disk. ">DataRecorder</a></em>. Use that file as input argument to this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meta_filename</td><td>Specifies which recording (<em>xethru_recording_meta.dat</em>) to open </td></tr>
    <tr><td class="paramname">depth</td><td>Specifies the number of meta files to open in 'chained mode'. By default, this parameter is -1 (automatically open all files, i.e. the entire recording). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe" title="Reads at most max_size bytes from disk into data and updates the output parameters. ">read_record</a> </dd></dl>

</div>
</div>
<a id="aaed2620db178415f86c2cc834ac12731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed2620db178415f86c2cc834ac12731">&sect;&nbsp;</a></span>peek_record() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::DataReader::peek_record </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>is_user_header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads at most max_size bytes from disk into <em>data</em> and updates the output parameters without side effects (i.e. </p>
<p>if you call read after peek it will return the same data).</p>
<p>Upon success, <em>data</em> contains a complete record as stored on disk for a particular data type. The format is specified by the Xethru File Formats document unless <em>is_user_header</em> is true. In such case <em>data</em> contains custom user header as supplied by the user (see <em><a class="el" href="class_xe_thru_1_1_recording_options.xhtml#a2c62c00c220961615648a80770c3c79f" title="Sets a custom header applied to the beginning of the recorded file. ">RecordingOptions::set_user_header</a></em>).</p>
<p>Reading past the end is considered an error. Thus, always check <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end()</a> before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Specifies the buffer to read data into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_size</td><td>Specifies the maximum number of bytes to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Specifies the actual number of bytes read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_type</td><td>Specifies the <a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> for the record. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">epoch</td><td>Specifies the date/time the record was written to disk as number of milliseconds since 1970.01.01. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_user_header</td><td>Set to true if the record is custom user header; otherwise false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe" title="Reads at most max_size bytes from disk into data and updates the output parameters. ">read_record</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0003e1d96e165d4095922244de9e726b" title="Sets the filter used by read_record and peek_record. ">set_filter</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a25e24f183f1d515e8aeee3fcf551bd00">get_max_record_size</a> </dd></dl>

</div>
</div>
<a id="a0aa80ee973b35890a12f195d82dfe38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa80ee973b35890a12f195d82dfe38c">&sect;&nbsp;</a></span>peek_record() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xe_thru_1_1_data_record.xhtml">DataRecord</a> XeThru::DataReader::peek_record </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all bytes from a data record on disk and returns the <a class="el" href="struct_xe_thru_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a> without side effects (i.e. </p>
<p>if you call read after peek it will return the same data).</p>
<p>This is a convenience method that ensures all bytes from a record is read.</p>
<p>This method has no way of reporting error, however <em><a class="el" href="struct_xe_thru_1_1_data_record.xhtml#a838b0261e3b4b676cb7e02a9bbd4e78e">DataRecord::is_valid</a></em> is set to true on success; otherwise set to false.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="struct_xe_thru_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe" title="Reads at most max_size bytes from disk into data and updates the output parameters. ">read_record</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0003e1d96e165d4095922244de9e726b" title="Sets the filter used by read_record and peek_record. ">set_filter</a> </dd></dl>

</div>
</div>
<a id="a0d54098add7ad28cf353134daf7951fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d54098add7ad28cf353134daf7951fe">&sect;&nbsp;</a></span>read_record() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::DataReader::read_record </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>is_user_header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads at most max_size bytes from disk into <em>data</em> and updates the output parameters. </p>
<p>Upon success, <em>data</em> contains a complete record as stored on disk for a particular data type. The format is specified by the Xethru File Formats document unless <em>is_user_header</em> is true. In such case <em>data</em> contains custom user header as supplied by the user (see <em><a class="el" href="class_xe_thru_1_1_recording_options.xhtml#a2c62c00c220961615648a80770c3c79f" title="Sets a custom header applied to the beginning of the recorded file. ">RecordingOptions::set_user_header</a></em>).</p>
<p>Reading past the end is considered an error. Thus, always check <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end()</a> before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Specifies the buffer to read data into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_size</td><td>Specifies the maximum number of bytes to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Specifies the actual number of bytes read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_type</td><td>Specifies the <a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> for the record. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">epoch</td><td>Specifies the date/time the record was written to disk as number of milliseconds since 1970.01.01. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_user_header</td><td>Set to true if the record is custom user header; otherwise false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0003e1d96e165d4095922244de9e726b" title="Sets the filter used by read_record and peek_record. ">set_filter</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a25e24f183f1d515e8aeee3fcf551bd00">get_max_record_size</a> </dd></dl>

</div>
</div>
<a id="a82c0e0ef1de9c6459a6f8e1f76a0b818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c0e0ef1de9c6459a6f8e1f76a0b818">&sect;&nbsp;</a></span>read_record() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xe_thru_1_1_data_record.xhtml">DataRecord</a> XeThru::DataReader::read_record </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all bytes from a data record on disk and returns the <a class="el" href="struct_xe_thru_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a>. </p>
<p>This is a convenience method that ensures all bytes from a record is read.</p>
<p>This method has no way of reporting error, however <em><a class="el" href="struct_xe_thru_1_1_data_record.xhtml#a838b0261e3b4b676cb7e02a9bbd4e78e">DataRecord::is_valid</a></em> is set to true on success; otherwise set to false.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="struct_xe_thru_1_1_data_record.xhtml" title="Encapsulates data and information about one data record on disk. ">DataRecord</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0003e1d96e165d4095922244de9e726b" title="Sets the filter used by read_record and peek_record. ">set_filter</a> </dd></dl>

</div>
</div>
<a id="ab5b5e8f4d82631c3a3e160d4b11eb0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b5e8f4d82631c3a3e160d4b11eb0fe">&sect;&nbsp;</a></span>seek_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::DataReader::seek_byte </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current position as specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Specifies the position as number of bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#ac86576128946975370a484bd7e8b52c9" title="Sets the current position as specified. ">seek_ms</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#adf13744b104619a4941caebb6cb807c7">get_size</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end</a> </dd></dl>

</div>
</div>
<a id="ac86576128946975370a484bd7e8b52c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86576128946975370a484bd7e8b52c9">&sect;&nbsp;</a></span>seek_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::DataReader::seek_ms </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current position as specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Specifies the position as number of milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#ab5b5e8f4d82631c3a3e160d4b11eb0fe" title="Sets the current position as specified. ">seek_byte</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a4bb03243e6bc40adc5d8a2b0a4ee8aea">get_duration</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a45dff9bce58c2fef4ba92846479819dd">at_end</a> </dd></dl>

</div>
</div>
<a id="a0003e1d96e165d4095922244de9e726b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0003e1d96e165d4095922244de9e726b">&sect;&nbsp;</a></span>set_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::DataReader::set_filter </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the filter used by <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe">read_record</a> and <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#aaed2620db178415f86c2cc834ac12731">peek_record</a>. </p>
<p>The filter is used to specify the kind of data records returned by <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe">read_record</a> and <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#aaed2620db178415f86c2cc834ac12731">peek_record</a>.</p>
<p>By default, the filter is set to all data types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_types</td><td>Specifies the filter as a bitmask that consists of a combination of <a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> flags. These flags can be combined with the bitwise OR operator (|). For example: BasebandIqDataType | SleepDataType. A convenience value <a class="el" href="datatypes_8h.xhtml#ad8f6c77f86c26225ae61a6e07ded41f8">AllDataTypes</a> can also be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success, otherwise returns 1 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml#a0d54098add7ad28cf353134daf7951fe" title="Reads at most max_size bytes from disk into data and updates the output parameters. ">read_record</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml#aaed2620db178415f86c2cc834ac12731" title="Reads at most max_size bytes from disk into data and updates the output parameters without side effec...">peek_record</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_data_reader_8hpp_source.xhtml">DataReader.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/>
 <address class="footer">
 Copyright &copy; 2016 Novelda AS - <a href="http://www.xethru.com">www.xehtru.com</a><br />
 <small>
  Generated by &#160;<a href="http://www.doxygen.org/index.html">
  <img class="footer" src="doxygen.png" alt="doxygen"/>
  </a> 1.8.12
 </small>
 </address>
</body>
</html>
