#ifndef DATAPLAYER_HPP
#define DATAPLAYER_HPP

#include <memory>
#include <string>

class PlaybackModuleIo;
class DataPlayerPrivateAccess;

namespace XeThru {

/**
 * @class DataPlayer
 *
 * The DataPlayer class allows playback of telegrams / binary packets from a recording
 * generated by \ref DataRecorder.
 *
 * The DataPlayer class is a high level data playback class. It provides the user with
 * the ability to playback recorded data as if it was coming from a physical device.
 * So rather than initialising \ref ModuleConnector with a physical device (serial port),
 * it is possible to construct \ref ModuleConnector with a DataPlayer object and receive
 * telegrams / binary packets as one would normally receive from a physical XeThru device.
 * For example, CSV data on disk is converted back to its original telegram / binary format
 * before it is dispatched via ModuleConnector.
 *
 * Moreover, it is possible to control the playback via functions such as
 * \ref play, \ref pause, \ref stop, \ref set_playback_rate, \ref set_filter.
 *
 * @snippet playback_recording.cpp Typical usage
 *
 * This class uses the \ref DataReader class to read records from disk before it converts
 * them into telegrams / binary packets.
 *
 * @see ModuleConnector, DataRecorder, DataReader
 */
class DataReader;
class DataPlayerPrivate;
class DataPlayer
{
public:
    /**
     * @enum State
     *
     * This enum specifies the state of the player.
     *
     * @see play, pause, stop
     */
    enum State {
        StoppedState = 0, ///< (0) Stopped state (default)
        PlayingState = 1, ///< (1) Playing state
        PausedState = 2, ///< (2) Paused state
    };

    /**
     * Constructs the player and opens the recording specified by the given meta filename.
     *
     * One recording may contain several meta files, for example as a result of file/directory
     * splitting. The meta file contains information about which files and data types were
     * written to disk during a recording session. Common for all use cases is that
     * *xethru_recording_meta.dat* is always present in the output folder generated by \a DataRecorder.
     * Use that file as input argument to this constructor.
     *
     * @param meta_filename Specifies which recording (*xethru_recording_meta.dat*) to open.
     * @param depth Specifies the number of meta files to open in 'chained mode'. By default,
     * this parameter is -1 (automatically open all files, i.e. the entire recording).
     *
     * Constructor throws an runtime exception if the recording could not be opened.
     */
    DataPlayer(const std::string &meta_filename, int depth = -1);

    /**
     * Destroys the player.
     */
    ~DataPlayer();

    /**
     * Start or resume playback.
     *
     * Convenience function, equivalent to set_state(DataPlayer::PlayingState).
     */
    void play();

    /**
     * Pause playback.
     *
     * Convenience function, equivalent to set_state(DataPlayer::PausedState).
     */
    void pause();

    /**
     * Stop playback and reset the play position to the beginning.
     *
     * Convenience function, equivalent to set_state(DataPlayer::StoppedState).
     */
    void stop();

    /**
     * Sets the player's state as specified.
     *
     * By default, the player is in \ref StoppedState.
     *
     * @param state Specifies the state.
     * @see play, pause, stop
     */
    void set_state(State state);

    /**
     * @return the player's current state. By default, the player is in \ref StoppedState.
     */
    State get_state() const;

    /**
     * Specifies which data types to play.
     *
     * By default, the filter is set to all data types.
     *
     * @param data_types Specifies the filter as a bitmask that consists of a combination of \ref DataType flags.
     * These flags can be combined with the bitwise OR operator (|). For example: BasebandIqDataType | SleepDataType.
     * A convenience value \ref AllDataTypes can also be specified.
     *
     * @return 0 success, otherwise returns 1
     * @see play
     */
    int set_filter(uint32_t data_types);

    /**
     * @return the filter used to specify which data types to play. By default this value is all data types.
     * @see set_filter
     */
    uint32_t get_filter() const;

    /**
     * Sets the playback rate specified as a multiplier.
     *
     * By default, this value is 1.0 indicating that the player is playing at the standard pace.
     * Values higher than 1.0 will increase the pace, whereas a lower value will decrease the pace.
     * Values less than zero indicate the player should play as fast as possible. Value zero
     * is essentially the same as \ref PausedState.
     *
     * @param rate Specifies the multiplier for the playback rate.
     * @see play
     */
    void set_playback_rate(float rate);

    /**
     * @return the multiplayer used for the playback rate. By default, this value is 1.0.
     * @see set_playback_rate
     */
    float get_playback_rate() const;

    /**
     * Enables or disables loop mode as specified. When loop mode is enabled the, the player's
     * position is reset to the beginning when the player reaches the end. This allows for playback
     * forever.
     *
     * @param enabled Specifies if loop mode is enabled or disabled. By default, loop mode is
     * disabled (i.e. false).
     */
    void set_loop_mode_enabled(bool enabled);

    /**
     * @return true if loop mode is enabled, otherwise returns false. By default, this value is false.
     * @see set_loop_mode_enabled
     */
    bool get_loop_mode_enabled() const;

    /**
     * Sets the current position (ms) as specified. The value must be in range [0, \ref get_duration()].
     * @param position Specifies the position as number of milliseconds (ms).
     * @return 0 on success, otherwise returns 1
     * @see get_duration
     */
    int set_position(int64_t position);

    /**
     * @return the player's current position specified as number of milliseconds (ms).
     */
    int64_t get_position() const;

    /**
     * @return the total duration of the recording specified as number of milliseconds (ms).
     */
    int64_t get_duration() const;

    /**
     * @return the meta filename used when constructing this class.
     */
    std::string meta_filename() const;

private:
    DataPlayer(const DataPlayer &other) = delete;
    DataPlayer(DataPlayer &&other) = delete;
    DataPlayer& operator= (const DataPlayer &other) = delete;
    DataPlayer& operator= (DataPlayer &&other) = delete;

    friend class ::PlaybackModuleIo;
    friend class ::DataPlayerPrivateAccess;
    std::unique_ptr<DataPlayerPrivate> d_ptr;
};

} // namespace XeThru

#endif // DATAPLAYER_HPP
