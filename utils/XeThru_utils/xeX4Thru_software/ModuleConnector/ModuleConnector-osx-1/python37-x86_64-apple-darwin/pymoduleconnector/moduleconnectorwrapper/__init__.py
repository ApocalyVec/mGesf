# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from . import _moduleconnectorwrapper
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _moduleconnectorwrapper.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _moduleconnectorwrapper.SwigPyIterator_value(self)


    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _moduleconnectorwrapper.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _moduleconnectorwrapper.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _moduleconnectorwrapper.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _moduleconnectorwrapper.SwigPyIterator_equal(self, x)


    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.SwigPyIterator_copy(self)


    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _moduleconnectorwrapper.SwigPyIterator_next(self)


    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _moduleconnectorwrapper.SwigPyIterator___next__(self)


    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _moduleconnectorwrapper.SwigPyIterator_previous(self)


    def advance(self, n):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _moduleconnectorwrapper.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _moduleconnectorwrapper.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _moduleconnectorwrapper.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _moduleconnectorwrapper.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _moduleconnectorwrapper.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _moduleconnectorwrapper.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _moduleconnectorwrapper.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _moduleconnectorwrapper.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def new_uint32_t_ptr():
    """new_uint32_t_ptr() -> uint32_t *"""
    return _moduleconnectorwrapper.new_uint32_t_ptr()

def copy_uint32_t_ptr(value):
    """copy_uint32_t_ptr(uint32_t value) -> uint32_t *"""
    return _moduleconnectorwrapper.copy_uint32_t_ptr(value)

def delete_uint32_t_ptr(obj):
    """delete_uint32_t_ptr(uint32_t * obj)"""
    return _moduleconnectorwrapper.delete_uint32_t_ptr(obj)

def uint32_t_ptr_assign(obj, value):
    """uint32_t_ptr_assign(uint32_t * obj, uint32_t value)"""
    return _moduleconnectorwrapper.uint32_t_ptr_assign(obj, value)

def uint32_t_ptr_value(obj):
    """uint32_t_ptr_value(uint32_t * obj) -> uint32_t"""
    return _moduleconnectorwrapper.uint32_t_ptr_value(obj)

def new_uint8_t_ptr():
    """new_uint8_t_ptr() -> uint8_t *"""
    return _moduleconnectorwrapper.new_uint8_t_ptr()

def copy_uint8_t_ptr(value):
    """copy_uint8_t_ptr(uint8_t value) -> uint8_t *"""
    return _moduleconnectorwrapper.copy_uint8_t_ptr(value)

def delete_uint8_t_ptr(obj):
    """delete_uint8_t_ptr(uint8_t * obj)"""
    return _moduleconnectorwrapper.delete_uint8_t_ptr(obj)

def uint8_t_ptr_assign(obj, value):
    """uint8_t_ptr_assign(uint8_t * obj, uint8_t value)"""
    return _moduleconnectorwrapper.uint8_t_ptr_assign(obj, value)

def uint8_t_ptr_value(obj):
    """uint8_t_ptr_value(uint8_t * obj) -> uint8_t"""
    return _moduleconnectorwrapper.uint8_t_ptr_value(obj)

def new_float_ptr():
    """new_float_ptr() -> float *"""
    return _moduleconnectorwrapper.new_float_ptr()

def copy_float_ptr(value):
    """copy_float_ptr(float value) -> float *"""
    return _moduleconnectorwrapper.copy_float_ptr(value)

def delete_float_ptr(obj):
    """delete_float_ptr(float * obj)"""
    return _moduleconnectorwrapper.delete_float_ptr(obj)

def float_ptr_assign(obj, value):
    """float_ptr_assign(float * obj, float value)"""
    return _moduleconnectorwrapper.float_ptr_assign(obj, value)

def float_ptr_value(obj):
    """float_ptr_value(float * obj) -> float"""
    return _moduleconnectorwrapper.float_ptr_value(obj)

def new_string_ptr():
    """new_string_ptr() -> std::string *"""
    return _moduleconnectorwrapper.new_string_ptr()

def copy_string_ptr(value):
    """copy_string_ptr(std::string value) -> std::string *"""
    return _moduleconnectorwrapper.copy_string_ptr(value)

def delete_string_ptr(obj):
    """delete_string_ptr(std::string * obj)"""
    return _moduleconnectorwrapper.delete_string_ptr(obj)

def string_ptr_assign(obj, value):
    """string_ptr_assign(std::string * obj, std::string value)"""
    return _moduleconnectorwrapper.string_ptr_assign(obj, value)

def string_ptr_value(obj):
    """string_ptr_value(std::string * obj) -> std::string"""
    return _moduleconnectorwrapper.string_ptr_value(obj)
class uiVector(_object):
    """Proxy of C++ std::vector<(unsigned int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uiVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uiVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(uiVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.uiVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(uiVector self) -> bool"""
        return _moduleconnectorwrapper.uiVector___nonzero__(self)


    def __bool__(self):
        """__bool__(uiVector self) -> bool"""
        return _moduleconnectorwrapper.uiVector___bool__(self)


    def __len__(self):
        """__len__(uiVector self) -> std::vector< unsigned int >::size_type"""
        return _moduleconnectorwrapper.uiVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(uiVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> uiVector"""
        return _moduleconnectorwrapper.uiVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(uiVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        __setslice__(uiVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, uiVector v)
        """
        return _moduleconnectorwrapper.uiVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(uiVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _moduleconnectorwrapper.uiVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(uiVector self, std::vector< unsigned int >::difference_type i)
        __delitem__(uiVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.uiVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(uiVector self, PySliceObject * slice) -> uiVector
        __getitem__(uiVector self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _moduleconnectorwrapper.uiVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(uiVector self, PySliceObject * slice, uiVector v)
        __setitem__(uiVector self, PySliceObject * slice)
        __setitem__(uiVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _moduleconnectorwrapper.uiVector___setitem__(self, *args)


    def pop(self):
        """pop(uiVector self) -> std::vector< unsigned int >::value_type"""
        return _moduleconnectorwrapper.uiVector_pop(self)


    def append(self, x):
        """append(uiVector self, std::vector< unsigned int >::value_type const & x)"""
        return _moduleconnectorwrapper.uiVector_append(self, x)


    def empty(self):
        """empty(uiVector self) -> bool"""
        return _moduleconnectorwrapper.uiVector_empty(self)


    def size(self):
        """size(uiVector self) -> std::vector< unsigned int >::size_type"""
        return _moduleconnectorwrapper.uiVector_size(self)


    def swap(self, v):
        """swap(uiVector self, uiVector v)"""
        return _moduleconnectorwrapper.uiVector_swap(self, v)


    def begin(self):
        """begin(uiVector self) -> std::vector< unsigned int >::iterator"""
        return _moduleconnectorwrapper.uiVector_begin(self)


    def end(self):
        """end(uiVector self) -> std::vector< unsigned int >::iterator"""
        return _moduleconnectorwrapper.uiVector_end(self)


    def rbegin(self):
        """rbegin(uiVector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _moduleconnectorwrapper.uiVector_rbegin(self)


    def rend(self):
        """rend(uiVector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _moduleconnectorwrapper.uiVector_rend(self)


    def clear(self):
        """clear(uiVector self)"""
        return _moduleconnectorwrapper.uiVector_clear(self)


    def get_allocator(self):
        """get_allocator(uiVector self) -> std::vector< unsigned int >::allocator_type"""
        return _moduleconnectorwrapper.uiVector_get_allocator(self)


    def pop_back(self):
        """pop_back(uiVector self)"""
        return _moduleconnectorwrapper.uiVector_pop_back(self)


    def erase(self, *args):
        """
        erase(uiVector self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(uiVector self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _moduleconnectorwrapper.uiVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned int)> self) -> uiVector
        __init__(std::vector<(unsigned int)> self, uiVector arg2) -> uiVector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size) -> uiVector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> uiVector
        """
        this = _moduleconnectorwrapper.new_uiVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(uiVector self, std::vector< unsigned int >::value_type const & x)"""
        return _moduleconnectorwrapper.uiVector_push_back(self, x)


    def front(self):
        """front(uiVector self) -> std::vector< unsigned int >::value_type const &"""
        return _moduleconnectorwrapper.uiVector_front(self)


    def back(self):
        """back(uiVector self) -> std::vector< unsigned int >::value_type const &"""
        return _moduleconnectorwrapper.uiVector_back(self)


    def assign(self, n, x):
        """assign(uiVector self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _moduleconnectorwrapper.uiVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(uiVector self, std::vector< unsigned int >::size_type new_size)
        resize(uiVector self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _moduleconnectorwrapper.uiVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(uiVector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(uiVector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)
        """
        return _moduleconnectorwrapper.uiVector_insert(self, *args)


    def reserve(self, n):
        """reserve(uiVector self, std::vector< unsigned int >::size_type n)"""
        return _moduleconnectorwrapper.uiVector_reserve(self, n)


    def capacity(self):
        """capacity(uiVector self) -> std::vector< unsigned int >::size_type"""
        return _moduleconnectorwrapper.uiVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_uiVector
    __del__ = lambda self: None
uiVector_swigregister = _moduleconnectorwrapper.uiVector_swigregister
uiVector_swigregister(uiVector)

class iVector(_object):
    """Proxy of C++ std::vector<(int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, iVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, iVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(iVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.iVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(iVector self) -> bool"""
        return _moduleconnectorwrapper.iVector___nonzero__(self)


    def __bool__(self):
        """__bool__(iVector self) -> bool"""
        return _moduleconnectorwrapper.iVector___bool__(self)


    def __len__(self):
        """__len__(iVector self) -> std::vector< int >::size_type"""
        return _moduleconnectorwrapper.iVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(iVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> iVector"""
        return _moduleconnectorwrapper.iVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(iVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(iVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, iVector v)
        """
        return _moduleconnectorwrapper.iVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(iVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _moduleconnectorwrapper.iVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(iVector self, std::vector< int >::difference_type i)
        __delitem__(iVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.iVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(iVector self, PySliceObject * slice) -> iVector
        __getitem__(iVector self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _moduleconnectorwrapper.iVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(iVector self, PySliceObject * slice, iVector v)
        __setitem__(iVector self, PySliceObject * slice)
        __setitem__(iVector self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _moduleconnectorwrapper.iVector___setitem__(self, *args)


    def pop(self):
        """pop(iVector self) -> std::vector< int >::value_type"""
        return _moduleconnectorwrapper.iVector_pop(self)


    def append(self, x):
        """append(iVector self, std::vector< int >::value_type const & x)"""
        return _moduleconnectorwrapper.iVector_append(self, x)


    def empty(self):
        """empty(iVector self) -> bool"""
        return _moduleconnectorwrapper.iVector_empty(self)


    def size(self):
        """size(iVector self) -> std::vector< int >::size_type"""
        return _moduleconnectorwrapper.iVector_size(self)


    def swap(self, v):
        """swap(iVector self, iVector v)"""
        return _moduleconnectorwrapper.iVector_swap(self, v)


    def begin(self):
        """begin(iVector self) -> std::vector< int >::iterator"""
        return _moduleconnectorwrapper.iVector_begin(self)


    def end(self):
        """end(iVector self) -> std::vector< int >::iterator"""
        return _moduleconnectorwrapper.iVector_end(self)


    def rbegin(self):
        """rbegin(iVector self) -> std::vector< int >::reverse_iterator"""
        return _moduleconnectorwrapper.iVector_rbegin(self)


    def rend(self):
        """rend(iVector self) -> std::vector< int >::reverse_iterator"""
        return _moduleconnectorwrapper.iVector_rend(self)


    def clear(self):
        """clear(iVector self)"""
        return _moduleconnectorwrapper.iVector_clear(self)


    def get_allocator(self):
        """get_allocator(iVector self) -> std::vector< int >::allocator_type"""
        return _moduleconnectorwrapper.iVector_get_allocator(self)


    def pop_back(self):
        """pop_back(iVector self)"""
        return _moduleconnectorwrapper.iVector_pop_back(self)


    def erase(self, *args):
        """
        erase(iVector self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(iVector self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _moduleconnectorwrapper.iVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int)> self) -> iVector
        __init__(std::vector<(int)> self, iVector arg2) -> iVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> iVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> iVector
        """
        this = _moduleconnectorwrapper.new_iVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(iVector self, std::vector< int >::value_type const & x)"""
        return _moduleconnectorwrapper.iVector_push_back(self, x)


    def front(self):
        """front(iVector self) -> std::vector< int >::value_type const &"""
        return _moduleconnectorwrapper.iVector_front(self)


    def back(self):
        """back(iVector self) -> std::vector< int >::value_type const &"""
        return _moduleconnectorwrapper.iVector_back(self)


    def assign(self, n, x):
        """assign(iVector self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _moduleconnectorwrapper.iVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(iVector self, std::vector< int >::size_type new_size)
        resize(iVector self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _moduleconnectorwrapper.iVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(iVector self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(iVector self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _moduleconnectorwrapper.iVector_insert(self, *args)


    def reserve(self, n):
        """reserve(iVector self, std::vector< int >::size_type n)"""
        return _moduleconnectorwrapper.iVector_reserve(self, n)


    def capacity(self):
        """capacity(iVector self) -> std::vector< int >::size_type"""
        return _moduleconnectorwrapper.iVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_iVector
    __del__ = lambda self: None
iVector_swigregister = _moduleconnectorwrapper.iVector_swigregister
iVector_swigregister(iVector)

class DoubleVector(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(DoubleVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.DoubleVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(DoubleVector self) -> bool"""
        return _moduleconnectorwrapper.DoubleVector___nonzero__(self)


    def __bool__(self):
        """__bool__(DoubleVector self) -> bool"""
        return _moduleconnectorwrapper.DoubleVector___bool__(self)


    def __len__(self):
        """__len__(DoubleVector self) -> std::vector< double >::size_type"""
        return _moduleconnectorwrapper.DoubleVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> DoubleVector"""
        return _moduleconnectorwrapper.DoubleVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, DoubleVector v)
        """
        return _moduleconnectorwrapper.DoubleVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _moduleconnectorwrapper.DoubleVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(DoubleVector self, std::vector< double >::difference_type i)
        __delitem__(DoubleVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.DoubleVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(DoubleVector self, PySliceObject * slice) -> DoubleVector
        __getitem__(DoubleVector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _moduleconnectorwrapper.DoubleVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(DoubleVector self, PySliceObject * slice, DoubleVector v)
        __setitem__(DoubleVector self, PySliceObject * slice)
        __setitem__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _moduleconnectorwrapper.DoubleVector___setitem__(self, *args)


    def pop(self):
        """pop(DoubleVector self) -> std::vector< double >::value_type"""
        return _moduleconnectorwrapper.DoubleVector_pop(self)


    def append(self, x):
        """append(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _moduleconnectorwrapper.DoubleVector_append(self, x)


    def empty(self):
        """empty(DoubleVector self) -> bool"""
        return _moduleconnectorwrapper.DoubleVector_empty(self)


    def size(self):
        """size(DoubleVector self) -> std::vector< double >::size_type"""
        return _moduleconnectorwrapper.DoubleVector_size(self)


    def swap(self, v):
        """swap(DoubleVector self, DoubleVector v)"""
        return _moduleconnectorwrapper.DoubleVector_swap(self, v)


    def begin(self):
        """begin(DoubleVector self) -> std::vector< double >::iterator"""
        return _moduleconnectorwrapper.DoubleVector_begin(self)


    def end(self):
        """end(DoubleVector self) -> std::vector< double >::iterator"""
        return _moduleconnectorwrapper.DoubleVector_end(self)


    def rbegin(self):
        """rbegin(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _moduleconnectorwrapper.DoubleVector_rbegin(self)


    def rend(self):
        """rend(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _moduleconnectorwrapper.DoubleVector_rend(self)


    def clear(self):
        """clear(DoubleVector self)"""
        return _moduleconnectorwrapper.DoubleVector_clear(self)


    def get_allocator(self):
        """get_allocator(DoubleVector self) -> std::vector< double >::allocator_type"""
        return _moduleconnectorwrapper.DoubleVector_get_allocator(self)


    def pop_back(self):
        """pop_back(DoubleVector self)"""
        return _moduleconnectorwrapper.DoubleVector_pop_back(self)


    def erase(self, *args):
        """
        erase(DoubleVector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(DoubleVector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _moduleconnectorwrapper.DoubleVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> DoubleVector
        __init__(std::vector<(double)> self, DoubleVector arg2) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> DoubleVector
        """
        this = _moduleconnectorwrapper.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _moduleconnectorwrapper.DoubleVector_push_back(self, x)


    def front(self):
        """front(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _moduleconnectorwrapper.DoubleVector_front(self)


    def back(self):
        """back(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _moduleconnectorwrapper.DoubleVector_back(self)


    def assign(self, n, x):
        """assign(DoubleVector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _moduleconnectorwrapper.DoubleVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(DoubleVector self, std::vector< double >::size_type new_size)
        resize(DoubleVector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _moduleconnectorwrapper.DoubleVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _moduleconnectorwrapper.DoubleVector_insert(self, *args)


    def reserve(self, n):
        """reserve(DoubleVector self, std::vector< double >::size_type n)"""
        return _moduleconnectorwrapper.DoubleVector_reserve(self, n)


    def capacity(self):
        """capacity(DoubleVector self) -> std::vector< double >::size_type"""
        return _moduleconnectorwrapper.DoubleVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _moduleconnectorwrapper.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class FloatVector(_object):
    """Proxy of C++ std::vector<(float)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(FloatVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.FloatVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(FloatVector self) -> bool"""
        return _moduleconnectorwrapper.FloatVector___nonzero__(self)


    def __bool__(self):
        """__bool__(FloatVector self) -> bool"""
        return _moduleconnectorwrapper.FloatVector___bool__(self)


    def __len__(self):
        """__len__(FloatVector self) -> std::vector< float >::size_type"""
        return _moduleconnectorwrapper.FloatVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> FloatVector"""
        return _moduleconnectorwrapper.FloatVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        __setslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, FloatVector v)
        """
        return _moduleconnectorwrapper.FloatVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _moduleconnectorwrapper.FloatVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(FloatVector self, std::vector< float >::difference_type i)
        __delitem__(FloatVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.FloatVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(FloatVector self, PySliceObject * slice) -> FloatVector
        __getitem__(FloatVector self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _moduleconnectorwrapper.FloatVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(FloatVector self, PySliceObject * slice, FloatVector v)
        __setitem__(FloatVector self, PySliceObject * slice)
        __setitem__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _moduleconnectorwrapper.FloatVector___setitem__(self, *args)


    def pop(self):
        """pop(FloatVector self) -> std::vector< float >::value_type"""
        return _moduleconnectorwrapper.FloatVector_pop(self)


    def append(self, x):
        """append(FloatVector self, std::vector< float >::value_type const & x)"""
        return _moduleconnectorwrapper.FloatVector_append(self, x)


    def empty(self):
        """empty(FloatVector self) -> bool"""
        return _moduleconnectorwrapper.FloatVector_empty(self)


    def size(self):
        """size(FloatVector self) -> std::vector< float >::size_type"""
        return _moduleconnectorwrapper.FloatVector_size(self)


    def swap(self, v):
        """swap(FloatVector self, FloatVector v)"""
        return _moduleconnectorwrapper.FloatVector_swap(self, v)


    def begin(self):
        """begin(FloatVector self) -> std::vector< float >::iterator"""
        return _moduleconnectorwrapper.FloatVector_begin(self)


    def end(self):
        """end(FloatVector self) -> std::vector< float >::iterator"""
        return _moduleconnectorwrapper.FloatVector_end(self)


    def rbegin(self):
        """rbegin(FloatVector self) -> std::vector< float >::reverse_iterator"""
        return _moduleconnectorwrapper.FloatVector_rbegin(self)


    def rend(self):
        """rend(FloatVector self) -> std::vector< float >::reverse_iterator"""
        return _moduleconnectorwrapper.FloatVector_rend(self)


    def clear(self):
        """clear(FloatVector self)"""
        return _moduleconnectorwrapper.FloatVector_clear(self)


    def get_allocator(self):
        """get_allocator(FloatVector self) -> std::vector< float >::allocator_type"""
        return _moduleconnectorwrapper.FloatVector_get_allocator(self)


    def pop_back(self):
        """pop_back(FloatVector self)"""
        return _moduleconnectorwrapper.FloatVector_pop_back(self)


    def erase(self, *args):
        """
        erase(FloatVector self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(FloatVector self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _moduleconnectorwrapper.FloatVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(float)> self) -> FloatVector
        __init__(std::vector<(float)> self, FloatVector arg2) -> FloatVector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size) -> FloatVector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> FloatVector
        """
        this = _moduleconnectorwrapper.new_FloatVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(FloatVector self, std::vector< float >::value_type const & x)"""
        return _moduleconnectorwrapper.FloatVector_push_back(self, x)


    def front(self):
        """front(FloatVector self) -> std::vector< float >::value_type const &"""
        return _moduleconnectorwrapper.FloatVector_front(self)


    def back(self):
        """back(FloatVector self) -> std::vector< float >::value_type const &"""
        return _moduleconnectorwrapper.FloatVector_back(self)


    def assign(self, n, x):
        """assign(FloatVector self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _moduleconnectorwrapper.FloatVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(FloatVector self, std::vector< float >::size_type new_size)
        resize(FloatVector self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _moduleconnectorwrapper.FloatVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(FloatVector self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(FloatVector self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _moduleconnectorwrapper.FloatVector_insert(self, *args)


    def reserve(self, n):
        """reserve(FloatVector self, std::vector< float >::size_type n)"""
        return _moduleconnectorwrapper.FloatVector_reserve(self, n)


    def capacity(self):
        """capacity(FloatVector self) -> std::vector< float >::size_type"""
        return _moduleconnectorwrapper.FloatVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_FloatVector
    __del__ = lambda self: None
FloatVector_swigregister = _moduleconnectorwrapper.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

class sVector(_object):
    """Proxy of C++ std::vector<(int16_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(sVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.sVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(sVector self) -> bool"""
        return _moduleconnectorwrapper.sVector___nonzero__(self)


    def __bool__(self):
        """__bool__(sVector self) -> bool"""
        return _moduleconnectorwrapper.sVector___bool__(self)


    def __len__(self):
        """__len__(sVector self) -> std::vector< short >::size_type"""
        return _moduleconnectorwrapper.sVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(sVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j) -> sVector"""
        return _moduleconnectorwrapper.sVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(sVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j)
        __setslice__(sVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j, sVector v)
        """
        return _moduleconnectorwrapper.sVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(sVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j)"""
        return _moduleconnectorwrapper.sVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(sVector self, std::vector< short >::difference_type i)
        __delitem__(sVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.sVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(sVector self, PySliceObject * slice) -> sVector
        __getitem__(sVector self, std::vector< short >::difference_type i) -> std::vector< short >::value_type const &
        """
        return _moduleconnectorwrapper.sVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(sVector self, PySliceObject * slice, sVector v)
        __setitem__(sVector self, PySliceObject * slice)
        __setitem__(sVector self, std::vector< short >::difference_type i, std::vector< short >::value_type const & x)
        """
        return _moduleconnectorwrapper.sVector___setitem__(self, *args)


    def pop(self):
        """pop(sVector self) -> std::vector< short >::value_type"""
        return _moduleconnectorwrapper.sVector_pop(self)


    def append(self, x):
        """append(sVector self, std::vector< short >::value_type const & x)"""
        return _moduleconnectorwrapper.sVector_append(self, x)


    def empty(self):
        """empty(sVector self) -> bool"""
        return _moduleconnectorwrapper.sVector_empty(self)


    def size(self):
        """size(sVector self) -> std::vector< short >::size_type"""
        return _moduleconnectorwrapper.sVector_size(self)


    def swap(self, v):
        """swap(sVector self, sVector v)"""
        return _moduleconnectorwrapper.sVector_swap(self, v)


    def begin(self):
        """begin(sVector self) -> std::vector< short >::iterator"""
        return _moduleconnectorwrapper.sVector_begin(self)


    def end(self):
        """end(sVector self) -> std::vector< short >::iterator"""
        return _moduleconnectorwrapper.sVector_end(self)


    def rbegin(self):
        """rbegin(sVector self) -> std::vector< short >::reverse_iterator"""
        return _moduleconnectorwrapper.sVector_rbegin(self)


    def rend(self):
        """rend(sVector self) -> std::vector< short >::reverse_iterator"""
        return _moduleconnectorwrapper.sVector_rend(self)


    def clear(self):
        """clear(sVector self)"""
        return _moduleconnectorwrapper.sVector_clear(self)


    def get_allocator(self):
        """get_allocator(sVector self) -> std::vector< short >::allocator_type"""
        return _moduleconnectorwrapper.sVector_get_allocator(self)


    def pop_back(self):
        """pop_back(sVector self)"""
        return _moduleconnectorwrapper.sVector_pop_back(self)


    def erase(self, *args):
        """
        erase(sVector self, std::vector< short >::iterator pos) -> std::vector< short >::iterator
        erase(sVector self, std::vector< short >::iterator first, std::vector< short >::iterator last) -> std::vector< short >::iterator
        """
        return _moduleconnectorwrapper.sVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int16_t)> self) -> sVector
        __init__(std::vector<(int16_t)> self, sVector arg2) -> sVector
        __init__(std::vector<(int16_t)> self, std::vector< short >::size_type size) -> sVector
        __init__(std::vector<(int16_t)> self, std::vector< short >::size_type size, std::vector< short >::value_type const & value) -> sVector
        """
        this = _moduleconnectorwrapper.new_sVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(sVector self, std::vector< short >::value_type const & x)"""
        return _moduleconnectorwrapper.sVector_push_back(self, x)


    def front(self):
        """front(sVector self) -> std::vector< short >::value_type const &"""
        return _moduleconnectorwrapper.sVector_front(self)


    def back(self):
        """back(sVector self) -> std::vector< short >::value_type const &"""
        return _moduleconnectorwrapper.sVector_back(self)


    def assign(self, n, x):
        """assign(sVector self, std::vector< short >::size_type n, std::vector< short >::value_type const & x)"""
        return _moduleconnectorwrapper.sVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(sVector self, std::vector< short >::size_type new_size)
        resize(sVector self, std::vector< short >::size_type new_size, std::vector< short >::value_type const & x)
        """
        return _moduleconnectorwrapper.sVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(sVector self, std::vector< short >::iterator pos, std::vector< short >::value_type const & x) -> std::vector< short >::iterator
        insert(sVector self, std::vector< short >::iterator pos, std::vector< short >::size_type n, std::vector< short >::value_type const & x)
        """
        return _moduleconnectorwrapper.sVector_insert(self, *args)


    def reserve(self, n):
        """reserve(sVector self, std::vector< short >::size_type n)"""
        return _moduleconnectorwrapper.sVector_reserve(self, n)


    def capacity(self):
        """capacity(sVector self) -> std::vector< short >::size_type"""
        return _moduleconnectorwrapper.sVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_sVector
    __del__ = lambda self: None
sVector_swigregister = _moduleconnectorwrapper.sVector_swigregister
sVector_swigregister(sVector)

class ucVector(_object):
    """Proxy of C++ std::vector<(unsigned char)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ucVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ucVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(ucVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.ucVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(ucVector self) -> bool"""
        return _moduleconnectorwrapper.ucVector___nonzero__(self)


    def __bool__(self):
        """__bool__(ucVector self) -> bool"""
        return _moduleconnectorwrapper.ucVector___bool__(self)


    def __len__(self):
        """__len__(ucVector self) -> std::vector< unsigned char >::size_type"""
        return _moduleconnectorwrapper.ucVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(ucVector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j) -> ucVector"""
        return _moduleconnectorwrapper.ucVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(ucVector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)
        __setslice__(ucVector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j, ucVector v)
        """
        return _moduleconnectorwrapper.ucVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(ucVector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)"""
        return _moduleconnectorwrapper.ucVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(ucVector self, std::vector< unsigned char >::difference_type i)
        __delitem__(ucVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.ucVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(ucVector self, PySliceObject * slice) -> ucVector
        __getitem__(ucVector self, std::vector< unsigned char >::difference_type i) -> std::vector< unsigned char >::value_type const &
        """
        return _moduleconnectorwrapper.ucVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(ucVector self, PySliceObject * slice, ucVector v)
        __setitem__(ucVector self, PySliceObject * slice)
        __setitem__(ucVector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::value_type const & x)
        """
        return _moduleconnectorwrapper.ucVector___setitem__(self, *args)


    def pop(self):
        """pop(ucVector self) -> std::vector< unsigned char >::value_type"""
        return _moduleconnectorwrapper.ucVector_pop(self)


    def append(self, x):
        """append(ucVector self, std::vector< unsigned char >::value_type const & x)"""
        return _moduleconnectorwrapper.ucVector_append(self, x)


    def empty(self):
        """empty(ucVector self) -> bool"""
        return _moduleconnectorwrapper.ucVector_empty(self)


    def size(self):
        """size(ucVector self) -> std::vector< unsigned char >::size_type"""
        return _moduleconnectorwrapper.ucVector_size(self)


    def swap(self, v):
        """swap(ucVector self, ucVector v)"""
        return _moduleconnectorwrapper.ucVector_swap(self, v)


    def begin(self):
        """begin(ucVector self) -> std::vector< unsigned char >::iterator"""
        return _moduleconnectorwrapper.ucVector_begin(self)


    def end(self):
        """end(ucVector self) -> std::vector< unsigned char >::iterator"""
        return _moduleconnectorwrapper.ucVector_end(self)


    def rbegin(self):
        """rbegin(ucVector self) -> std::vector< unsigned char >::reverse_iterator"""
        return _moduleconnectorwrapper.ucVector_rbegin(self)


    def rend(self):
        """rend(ucVector self) -> std::vector< unsigned char >::reverse_iterator"""
        return _moduleconnectorwrapper.ucVector_rend(self)


    def clear(self):
        """clear(ucVector self)"""
        return _moduleconnectorwrapper.ucVector_clear(self)


    def get_allocator(self):
        """get_allocator(ucVector self) -> std::vector< unsigned char >::allocator_type"""
        return _moduleconnectorwrapper.ucVector_get_allocator(self)


    def pop_back(self):
        """pop_back(ucVector self)"""
        return _moduleconnectorwrapper.ucVector_pop_back(self)


    def erase(self, *args):
        """
        erase(ucVector self, std::vector< unsigned char >::iterator pos) -> std::vector< unsigned char >::iterator
        erase(ucVector self, std::vector< unsigned char >::iterator first, std::vector< unsigned char >::iterator last) -> std::vector< unsigned char >::iterator
        """
        return _moduleconnectorwrapper.ucVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned char)> self) -> ucVector
        __init__(std::vector<(unsigned char)> self, ucVector arg2) -> ucVector
        __init__(std::vector<(unsigned char)> self, std::vector< unsigned char >::size_type size) -> ucVector
        __init__(std::vector<(unsigned char)> self, std::vector< unsigned char >::size_type size, std::vector< unsigned char >::value_type const & value) -> ucVector
        """
        this = _moduleconnectorwrapper.new_ucVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(ucVector self, std::vector< unsigned char >::value_type const & x)"""
        return _moduleconnectorwrapper.ucVector_push_back(self, x)


    def front(self):
        """front(ucVector self) -> std::vector< unsigned char >::value_type const &"""
        return _moduleconnectorwrapper.ucVector_front(self)


    def back(self):
        """back(ucVector self) -> std::vector< unsigned char >::value_type const &"""
        return _moduleconnectorwrapper.ucVector_back(self)


    def assign(self, n, x):
        """assign(ucVector self, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)"""
        return _moduleconnectorwrapper.ucVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(ucVector self, std::vector< unsigned char >::size_type new_size)
        resize(ucVector self, std::vector< unsigned char >::size_type new_size, std::vector< unsigned char >::value_type const & x)
        """
        return _moduleconnectorwrapper.ucVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(ucVector self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::value_type const & x) -> std::vector< unsigned char >::iterator
        insert(ucVector self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)
        """
        return _moduleconnectorwrapper.ucVector_insert(self, *args)


    def reserve(self, n):
        """reserve(ucVector self, std::vector< unsigned char >::size_type n)"""
        return _moduleconnectorwrapper.ucVector_reserve(self, n)


    def capacity(self):
        """capacity(ucVector self) -> std::vector< unsigned char >::size_type"""
        return _moduleconnectorwrapper.ucVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_ucVector
    __del__ = lambda self: None
ucVector_swigregister = _moduleconnectorwrapper.ucVector_swigregister
ucVector_swigregister(ucVector)

class vVector(_object):
    """Proxy of C++ std::vector<(std::vector<(unsigned char)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vVector self) -> SwigPyIterator"""
        return _moduleconnectorwrapper.vVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vVector self) -> bool"""
        return _moduleconnectorwrapper.vVector___nonzero__(self)


    def __bool__(self):
        """__bool__(vVector self) -> bool"""
        return _moduleconnectorwrapper.vVector___bool__(self)


    def __len__(self):
        """__len__(vVector self) -> std::vector< std::vector< unsigned char > >::size_type"""
        return _moduleconnectorwrapper.vVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i, std::vector< std::vector< unsigned char > >::difference_type j) -> vVector"""
        return _moduleconnectorwrapper.vVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i, std::vector< std::vector< unsigned char > >::difference_type j)
        __setslice__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i, std::vector< std::vector< unsigned char > >::difference_type j, vVector v)
        """
        return _moduleconnectorwrapper.vVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i, std::vector< std::vector< unsigned char > >::difference_type j)"""
        return _moduleconnectorwrapper.vVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i)
        __delitem__(vVector self, PySliceObject * slice)
        """
        return _moduleconnectorwrapper.vVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vVector self, PySliceObject * slice) -> vVector
        __getitem__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i) -> ucVector
        """
        return _moduleconnectorwrapper.vVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vVector self, PySliceObject * slice, vVector v)
        __setitem__(vVector self, PySliceObject * slice)
        __setitem__(vVector self, std::vector< std::vector< unsigned char > >::difference_type i, ucVector x)
        """
        return _moduleconnectorwrapper.vVector___setitem__(self, *args)


    def pop(self):
        """pop(vVector self) -> ucVector"""
        return _moduleconnectorwrapper.vVector_pop(self)


    def append(self, x):
        """append(vVector self, ucVector x)"""
        return _moduleconnectorwrapper.vVector_append(self, x)


    def empty(self):
        """empty(vVector self) -> bool"""
        return _moduleconnectorwrapper.vVector_empty(self)


    def size(self):
        """size(vVector self) -> std::vector< std::vector< unsigned char > >::size_type"""
        return _moduleconnectorwrapper.vVector_size(self)


    def swap(self, v):
        """swap(vVector self, vVector v)"""
        return _moduleconnectorwrapper.vVector_swap(self, v)


    def begin(self):
        """begin(vVector self) -> std::vector< std::vector< unsigned char > >::iterator"""
        return _moduleconnectorwrapper.vVector_begin(self)


    def end(self):
        """end(vVector self) -> std::vector< std::vector< unsigned char > >::iterator"""
        return _moduleconnectorwrapper.vVector_end(self)


    def rbegin(self):
        """rbegin(vVector self) -> std::vector< std::vector< unsigned char > >::reverse_iterator"""
        return _moduleconnectorwrapper.vVector_rbegin(self)


    def rend(self):
        """rend(vVector self) -> std::vector< std::vector< unsigned char > >::reverse_iterator"""
        return _moduleconnectorwrapper.vVector_rend(self)


    def clear(self):
        """clear(vVector self)"""
        return _moduleconnectorwrapper.vVector_clear(self)


    def get_allocator(self):
        """get_allocator(vVector self) -> std::vector< std::vector< unsigned char > >::allocator_type"""
        return _moduleconnectorwrapper.vVector_get_allocator(self)


    def pop_back(self):
        """pop_back(vVector self)"""
        return _moduleconnectorwrapper.vVector_pop_back(self)


    def erase(self, *args):
        """
        erase(vVector self, std::vector< std::vector< unsigned char > >::iterator pos) -> std::vector< std::vector< unsigned char > >::iterator
        erase(vVector self, std::vector< std::vector< unsigned char > >::iterator first, std::vector< std::vector< unsigned char > >::iterator last) -> std::vector< std::vector< unsigned char > >::iterator
        """
        return _moduleconnectorwrapper.vVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(unsigned char)>)> self) -> vVector
        __init__(std::vector<(std::vector<(unsigned char)>)> self, vVector arg2) -> vVector
        __init__(std::vector<(std::vector<(unsigned char)>)> self, std::vector< std::vector< unsigned char > >::size_type size) -> vVector
        __init__(std::vector<(std::vector<(unsigned char)>)> self, std::vector< std::vector< unsigned char > >::size_type size, ucVector value) -> vVector
        """
        this = _moduleconnectorwrapper.new_vVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vVector self, ucVector x)"""
        return _moduleconnectorwrapper.vVector_push_back(self, x)


    def front(self):
        """front(vVector self) -> ucVector"""
        return _moduleconnectorwrapper.vVector_front(self)


    def back(self):
        """back(vVector self) -> ucVector"""
        return _moduleconnectorwrapper.vVector_back(self)


    def assign(self, n, x):
        """assign(vVector self, std::vector< std::vector< unsigned char > >::size_type n, ucVector x)"""
        return _moduleconnectorwrapper.vVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vVector self, std::vector< std::vector< unsigned char > >::size_type new_size)
        resize(vVector self, std::vector< std::vector< unsigned char > >::size_type new_size, ucVector x)
        """
        return _moduleconnectorwrapper.vVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(vVector self, std::vector< std::vector< unsigned char > >::iterator pos, ucVector x) -> std::vector< std::vector< unsigned char > >::iterator
        insert(vVector self, std::vector< std::vector< unsigned char > >::iterator pos, std::vector< std::vector< unsigned char > >::size_type n, ucVector x)
        """
        return _moduleconnectorwrapper.vVector_insert(self, *args)


    def reserve(self, n):
        """reserve(vVector self, std::vector< std::vector< unsigned char > >::size_type n)"""
        return _moduleconnectorwrapper.vVector_reserve(self, n)


    def capacity(self):
        """capacity(vVector self) -> std::vector< std::vector< unsigned char > >::size_type"""
        return _moduleconnectorwrapper.vVector_capacity(self)

    __swig_destroy__ = _moduleconnectorwrapper.delete_vVector
    __del__ = lambda self: None
vVector_swigregister = _moduleconnectorwrapper.vVector_swigregister
vVector_swigregister(vVector)

class DataType(_object):
    """Proxy of C++ XeThru::DataType class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType, name)
    __repr__ = _swig_repr
    BasebandApDataType = _moduleconnectorwrapper.DataType_BasebandApDataType
    BasebandIqDataType = _moduleconnectorwrapper.DataType_BasebandIqDataType
    SleepDataType = _moduleconnectorwrapper.DataType_SleepDataType
    RespirationDataType = _moduleconnectorwrapper.DataType_RespirationDataType
    PerformanceStatusType = _moduleconnectorwrapper.DataType_PerformanceStatusType
    StringDataType = _moduleconnectorwrapper.DataType_StringDataType
    PulseDopplerFloatDataType = _moduleconnectorwrapper.DataType_PulseDopplerFloatDataType
    PulseDopplerByteDataType = _moduleconnectorwrapper.DataType_PulseDopplerByteDataType
    NoiseMapFloatDataType = _moduleconnectorwrapper.DataType_NoiseMapFloatDataType
    NoiseMapByteDataType = _moduleconnectorwrapper.DataType_NoiseMapByteDataType
    FloatDataType = _moduleconnectorwrapper.DataType_FloatDataType
    ByteDataType = _moduleconnectorwrapper.DataType_ByteDataType
    PresenceSingleDataType = _moduleconnectorwrapper.DataType_PresenceSingleDataType
    PresenceMovingListDataType = _moduleconnectorwrapper.DataType_PresenceMovingListDataType
    RespirationDetectionListDataType = _moduleconnectorwrapper.DataType_RespirationDetectionListDataType
    RespirationMovingListDataType = _moduleconnectorwrapper.DataType_RespirationMovingListDataType
    VitalSignsDataType = _moduleconnectorwrapper.DataType_VitalSignsDataType
    SleepStageDataType = _moduleconnectorwrapper.DataType_SleepStageDataType
    RespirationNormalizedMovementListDataType = _moduleconnectorwrapper.DataType_RespirationNormalizedMovementListDataType
    RadarRfDataType = _moduleconnectorwrapper.DataType_RadarRfDataType
    RadarRfNormalizedDataType = _moduleconnectorwrapper.DataType_RadarRfNormalizedDataType
    RadarBasebandFloatDataType = _moduleconnectorwrapper.DataType_RadarBasebandFloatDataType
    RadarBasebandQ15DataType = _moduleconnectorwrapper.DataType_RadarBasebandQ15DataType

    def __init__(self):
        """__init__(XeThru::DataType self) -> DataType"""
        this = _moduleconnectorwrapper.new_DataType()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_DataType
    __del__ = lambda self: None
DataType_swigregister = _moduleconnectorwrapper.DataType_swigregister
DataType_swigregister(DataType)

class RawNormalizedData(_object):
    """Proxy of C++ XeThru::RawNormalizedData class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RawNormalizedData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RawNormalizedData, name)
    __repr__ = _swig_repr

    def get_frame_counter(self):
        """get_frame_counter(RawNormalizedData self) -> uint32_t"""
        return _moduleconnectorwrapper.RawNormalizedData_get_frame_counter(self)


    def get_data(self):
        """get_data(RawNormalizedData self) -> FloatVector"""
        return _moduleconnectorwrapper.RawNormalizedData_get_data(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RawNormalizedData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RawNormalizedData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RawNormalizedData_frame_counter_get, _moduleconnectorwrapper.RawNormalizedData_frame_counter_set)
    __swig_setmethods__["data"] = _moduleconnectorwrapper.RawNormalizedData_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.RawNormalizedData_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.RawNormalizedData_data_get, _moduleconnectorwrapper.RawNormalizedData_data_set)

    def __init__(self):
        """__init__(XeThru::RawNormalizedData self) -> RawNormalizedData"""
        this = _moduleconnectorwrapper.new_RawNormalizedData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RawNormalizedData
    __del__ = lambda self: None
RawNormalizedData_swigregister = _moduleconnectorwrapper.RawNormalizedData_swigregister
RawNormalizedData_swigregister(RawNormalizedData)
cvar = _moduleconnectorwrapper.cvar
InvalidDataType = cvar.InvalidDataType
AllDataTypes = cvar.AllDataTypes

class DetectionZoneLimits(_object):
    """


    Is an aggrgation of parameters used to represent the detection zone limits.  

    Parameters
    ----------
    * `start` :  
        the start of the detection zone.  
    * `end` :  
        the end of the detection zone.  
    * `step` :  
        the steps in the detection zone.  

    Attributes
    ----------
    * `start` : `float`  

    * `end` : `float`  

    * `step` : `float`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DetectionZoneLimits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DetectionZoneLimits, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _moduleconnectorwrapper.DetectionZoneLimits_start_set
    __swig_getmethods__["start"] = _moduleconnectorwrapper.DetectionZoneLimits_start_get
    if _newclass:
        start = _swig_property(_moduleconnectorwrapper.DetectionZoneLimits_start_get, _moduleconnectorwrapper.DetectionZoneLimits_start_set)
    __swig_setmethods__["end"] = _moduleconnectorwrapper.DetectionZoneLimits_end_set
    __swig_getmethods__["end"] = _moduleconnectorwrapper.DetectionZoneLimits_end_get
    if _newclass:
        end = _swig_property(_moduleconnectorwrapper.DetectionZoneLimits_end_get, _moduleconnectorwrapper.DetectionZoneLimits_end_set)
    __swig_setmethods__["step"] = _moduleconnectorwrapper.DetectionZoneLimits_step_set
    __swig_getmethods__["step"] = _moduleconnectorwrapper.DetectionZoneLimits_step_get
    if _newclass:
        step = _swig_property(_moduleconnectorwrapper.DetectionZoneLimits_step_get, _moduleconnectorwrapper.DetectionZoneLimits_step_set)

    def __init__(self):
        """__init__(XeThru::DetectionZoneLimits self) -> DetectionZoneLimits"""
        this = _moduleconnectorwrapper.new_DetectionZoneLimits()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_DetectionZoneLimits
    __del__ = lambda self: None
DetectionZoneLimits_swigregister = _moduleconnectorwrapper.DetectionZoneLimits_swigregister
DetectionZoneLimits_swigregister(DetectionZoneLimits)

class DataFloat(_object):
    """


    Encapulates a vector of float elements, for example baseband data.  

    This package can be retrieved from the module with the use of
    read_message_data_float in the XEP interface.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Parameters
    ----------
    * `content_id` :  
        id that tells what the content is.  
    * `info` :  
        this might be some generic information, but usually it is the frame counter
        value.  
    * `data` :  
        the vector of float elements.  

    Attributes
    ----------
    * `content_id` : `uint32_t`  

    * `info` : `uint32_t`  

    * `data` : `std::vector< float >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataFloat, name)
    __repr__ = _swig_repr
    __swig_setmethods__["content_id"] = _moduleconnectorwrapper.DataFloat_content_id_set
    __swig_getmethods__["content_id"] = _moduleconnectorwrapper.DataFloat_content_id_get
    if _newclass:
        content_id = _swig_property(_moduleconnectorwrapper.DataFloat_content_id_get, _moduleconnectorwrapper.DataFloat_content_id_set)
    __swig_setmethods__["info"] = _moduleconnectorwrapper.DataFloat_info_set
    __swig_getmethods__["info"] = _moduleconnectorwrapper.DataFloat_info_get
    if _newclass:
        info = _swig_property(_moduleconnectorwrapper.DataFloat_info_get, _moduleconnectorwrapper.DataFloat_info_set)

    def get_data(self):
        """
        get_data(DataFloat self) -> FloatVector



        """
        return _moduleconnectorwrapper.DataFloat_get_data(self)


    def get_copy(self):
        """
        get_copy(DataFloat self) -> FloatVector



        """
        return _moduleconnectorwrapper.DataFloat_get_copy(self)

    __swig_setmethods__["data"] = _moduleconnectorwrapper.DataFloat_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.DataFloat_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.DataFloat_data_get, _moduleconnectorwrapper.DataFloat_data_set)

    def __init__(self):
        """__init__(XeThru::DataFloat self) -> DataFloat"""
        this = _moduleconnectorwrapper.new_DataFloat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_DataFloat
    __del__ = lambda self: None
DataFloat_swigregister = _moduleconnectorwrapper.DataFloat_swigregister
DataFloat_swigregister(DataFloat)

class FrameArea(_object):
    """


    Parameters
    ----------
    * `start` :  
        the start of the frame area.  
    * `end` :  
        the end of the frame area.  

    Attributes
    ----------
    * `start` : `float`  

    * `end` : `float`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameArea, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FrameArea, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _moduleconnectorwrapper.FrameArea_start_set
    __swig_getmethods__["start"] = _moduleconnectorwrapper.FrameArea_start_get
    if _newclass:
        start = _swig_property(_moduleconnectorwrapper.FrameArea_start_get, _moduleconnectorwrapper.FrameArea_start_set)
    __swig_setmethods__["end"] = _moduleconnectorwrapper.FrameArea_end_set
    __swig_getmethods__["end"] = _moduleconnectorwrapper.FrameArea_end_get
    if _newclass:
        end = _swig_property(_moduleconnectorwrapper.FrameArea_end_get, _moduleconnectorwrapper.FrameArea_end_set)

    def __init__(self):
        """__init__(XeThru::FrameArea self) -> FrameArea"""
        this = _moduleconnectorwrapper.new_FrameArea()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_FrameArea
    __del__ = lambda self: None
FrameArea_swigregister = _moduleconnectorwrapper.FrameArea_swigregister
FrameArea_swigregister(FrameArea)

class DetectionZone(_object):
    """


    Representation of the detection zone.  

    Attributes
    ----------
    * `start` : `float`  
        Start of detection zone in meters from the radar module.  

    * `end` : `float`  
        End of detection zone in meters from the radar module.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DetectionZone, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DetectionZone, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _moduleconnectorwrapper.DetectionZone_start_set
    __swig_getmethods__["start"] = _moduleconnectorwrapper.DetectionZone_start_get
    if _newclass:
        start = _swig_property(_moduleconnectorwrapper.DetectionZone_start_get, _moduleconnectorwrapper.DetectionZone_start_set)
    __swig_setmethods__["end"] = _moduleconnectorwrapper.DetectionZone_end_set
    __swig_getmethods__["end"] = _moduleconnectorwrapper.DetectionZone_end_get
    if _newclass:
        end = _swig_property(_moduleconnectorwrapper.DetectionZone_end_get, _moduleconnectorwrapper.DetectionZone_end_set)

    def __init__(self):
        """__init__(XeThru::DetectionZone self) -> DetectionZone"""
        this = _moduleconnectorwrapper.new_DetectionZone()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_DetectionZone
    __del__ = lambda self: None
DetectionZone_swigregister = _moduleconnectorwrapper.DetectionZone_swigregister
DetectionZone_swigregister(DetectionZone)

class PeriodicNoisemapStore(_object):
    """


    Representation of periodic noisemap store parameters.  

    Attributes
    ----------
    * `interval_minutes` : `uint32_t`  

    * `reserved` : `uint32_t`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PeriodicNoisemapStore, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PeriodicNoisemapStore, name)
    __repr__ = _swig_repr
    __swig_setmethods__["interval_minutes"] = _moduleconnectorwrapper.PeriodicNoisemapStore_interval_minutes_set
    __swig_getmethods__["interval_minutes"] = _moduleconnectorwrapper.PeriodicNoisemapStore_interval_minutes_get
    if _newclass:
        interval_minutes = _swig_property(_moduleconnectorwrapper.PeriodicNoisemapStore_interval_minutes_get, _moduleconnectorwrapper.PeriodicNoisemapStore_interval_minutes_set)
    __swig_setmethods__["reserved"] = _moduleconnectorwrapper.PeriodicNoisemapStore_reserved_set
    __swig_getmethods__["reserved"] = _moduleconnectorwrapper.PeriodicNoisemapStore_reserved_get
    if _newclass:
        reserved = _swig_property(_moduleconnectorwrapper.PeriodicNoisemapStore_reserved_get, _moduleconnectorwrapper.PeriodicNoisemapStore_reserved_set)

    def __init__(self):
        """__init__(XeThru::PeriodicNoisemapStore self) -> PeriodicNoisemapStore"""
        this = _moduleconnectorwrapper.new_PeriodicNoisemapStore()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PeriodicNoisemapStore
    __del__ = lambda self: None
PeriodicNoisemapStore_swigregister = _moduleconnectorwrapper.PeriodicNoisemapStore_swigregister
PeriodicNoisemapStore_swigregister(PeriodicNoisemapStore)

class IoPinControl(_object):
    """


    Representation of io pin control configuration.  

    Attributes
    ----------
    * `setup` : `uint32_t`  

    * `feature` : `uint32_t`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IoPinControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IoPinControl, name)
    __repr__ = _swig_repr
    __swig_setmethods__["setup"] = _moduleconnectorwrapper.IoPinControl_setup_set
    __swig_getmethods__["setup"] = _moduleconnectorwrapper.IoPinControl_setup_get
    if _newclass:
        setup = _swig_property(_moduleconnectorwrapper.IoPinControl_setup_get, _moduleconnectorwrapper.IoPinControl_setup_set)
    __swig_setmethods__["feature"] = _moduleconnectorwrapper.IoPinControl_feature_set
    __swig_getmethods__["feature"] = _moduleconnectorwrapper.IoPinControl_feature_get
    if _newclass:
        feature = _swig_property(_moduleconnectorwrapper.IoPinControl_feature_get, _moduleconnectorwrapper.IoPinControl_feature_set)

    def __init__(self):
        """__init__(XeThru::IoPinControl self) -> IoPinControl"""
        this = _moduleconnectorwrapper.new_IoPinControl()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_IoPinControl
    __del__ = lambda self: None
IoPinControl_swigregister = _moduleconnectorwrapper.IoPinControl_swigregister
IoPinControl_swigregister(IoPinControl)

class RespirationData(_object):
    """


    Represents the respiration status data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `sensor_state` : `uint32_t`  
        This represent the steady state of the sensor module.  

    * `respiration_rate` : `uint32_t`  
        Respiration rate (respirations per minute / RPM).  

        Valid when SensorState is Breathing.  

    * `distance` : `float`  
        The distance from the sensor to the subject (which the sensor is currently
        locked on to).  

    * `movement` : `float`  
        Breathing pattern of closest breathing target: Detected respiratory movement
        in mm perpendicular to the sensor.  

    * `signal_quality` : `uint32_t`  
        Quality measure of the signal quality, describing the signal-to-noise ratio
        of the current respiration lock.  

        Value from 0 to 10, 0=low -> 10=high.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RespirationData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RespirationData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RespirationData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RespirationData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RespirationData_frame_counter_get, _moduleconnectorwrapper.RespirationData_frame_counter_set)
    __swig_setmethods__["sensor_state"] = _moduleconnectorwrapper.RespirationData_sensor_state_set
    __swig_getmethods__["sensor_state"] = _moduleconnectorwrapper.RespirationData_sensor_state_get
    if _newclass:
        sensor_state = _swig_property(_moduleconnectorwrapper.RespirationData_sensor_state_get, _moduleconnectorwrapper.RespirationData_sensor_state_set)
    __swig_setmethods__["respiration_rate"] = _moduleconnectorwrapper.RespirationData_respiration_rate_set
    __swig_getmethods__["respiration_rate"] = _moduleconnectorwrapper.RespirationData_respiration_rate_get
    if _newclass:
        respiration_rate = _swig_property(_moduleconnectorwrapper.RespirationData_respiration_rate_get, _moduleconnectorwrapper.RespirationData_respiration_rate_set)
    __swig_setmethods__["distance"] = _moduleconnectorwrapper.RespirationData_distance_set
    __swig_getmethods__["distance"] = _moduleconnectorwrapper.RespirationData_distance_get
    if _newclass:
        distance = _swig_property(_moduleconnectorwrapper.RespirationData_distance_get, _moduleconnectorwrapper.RespirationData_distance_set)
    __swig_setmethods__["movement"] = _moduleconnectorwrapper.RespirationData_movement_set
    __swig_getmethods__["movement"] = _moduleconnectorwrapper.RespirationData_movement_get
    if _newclass:
        movement = _swig_property(_moduleconnectorwrapper.RespirationData_movement_get, _moduleconnectorwrapper.RespirationData_movement_set)
    __swig_setmethods__["signal_quality"] = _moduleconnectorwrapper.RespirationData_signal_quality_set
    __swig_getmethods__["signal_quality"] = _moduleconnectorwrapper.RespirationData_signal_quality_get
    if _newclass:
        signal_quality = _swig_property(_moduleconnectorwrapper.RespirationData_signal_quality_get, _moduleconnectorwrapper.RespirationData_signal_quality_set)

    def __init__(self):
        """__init__(XeThru::RespirationData self) -> RespirationData"""
        this = _moduleconnectorwrapper.new_RespirationData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RespirationData
    __del__ = lambda self: None
RespirationData_swigregister = _moduleconnectorwrapper.RespirationData_swigregister
RespirationData_swigregister(RespirationData)

class SleepData(_object):
    """


    Represents the sleep status data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `sensor_state` : `uint32_t`  
        This represent the steady state of the sensor module.  

    * `respiration_rate` : `float`  
        Respiration rate (respirations per minute / RPM).  

        Valid when SensorState is Breathing.  

    * `distance` : `float`  
        Is the distance from the sensorto the subject (which the sensor is currently
        locked on to).  

    * `signal_quality` : `uint32_t`  
        Quality measure of the signal quality, describing the signal-to-noise ratio
        of the current respiration lock.  

        Value from 0 to 10, 0=low -> 10=high.  

    * `movement_slow` : `float`  
        First movement metric which captures the larger movements.  

        It is given as a percentage(0-100). Higher the percentage larger the
        movement.  

    * `movement_fast` : `float`  
        Second movement metric which also captures the larger movements.  

        It is represented as a percentage (0-100). Higher the percentage larger the
        movement. This metric is more responsive than the MovementSlow. It captures
        the movements faster than the former.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SleepData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SleepData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.SleepData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.SleepData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.SleepData_frame_counter_get, _moduleconnectorwrapper.SleepData_frame_counter_set)
    __swig_setmethods__["sensor_state"] = _moduleconnectorwrapper.SleepData_sensor_state_set
    __swig_getmethods__["sensor_state"] = _moduleconnectorwrapper.SleepData_sensor_state_get
    if _newclass:
        sensor_state = _swig_property(_moduleconnectorwrapper.SleepData_sensor_state_get, _moduleconnectorwrapper.SleepData_sensor_state_set)
    __swig_setmethods__["respiration_rate"] = _moduleconnectorwrapper.SleepData_respiration_rate_set
    __swig_getmethods__["respiration_rate"] = _moduleconnectorwrapper.SleepData_respiration_rate_get
    if _newclass:
        respiration_rate = _swig_property(_moduleconnectorwrapper.SleepData_respiration_rate_get, _moduleconnectorwrapper.SleepData_respiration_rate_set)
    __swig_setmethods__["distance"] = _moduleconnectorwrapper.SleepData_distance_set
    __swig_getmethods__["distance"] = _moduleconnectorwrapper.SleepData_distance_get
    if _newclass:
        distance = _swig_property(_moduleconnectorwrapper.SleepData_distance_get, _moduleconnectorwrapper.SleepData_distance_set)
    __swig_setmethods__["signal_quality"] = _moduleconnectorwrapper.SleepData_signal_quality_set
    __swig_getmethods__["signal_quality"] = _moduleconnectorwrapper.SleepData_signal_quality_get
    if _newclass:
        signal_quality = _swig_property(_moduleconnectorwrapper.SleepData_signal_quality_get, _moduleconnectorwrapper.SleepData_signal_quality_set)
    __swig_setmethods__["movement_slow"] = _moduleconnectorwrapper.SleepData_movement_slow_set
    __swig_getmethods__["movement_slow"] = _moduleconnectorwrapper.SleepData_movement_slow_get
    if _newclass:
        movement_slow = _swig_property(_moduleconnectorwrapper.SleepData_movement_slow_get, _moduleconnectorwrapper.SleepData_movement_slow_set)
    __swig_setmethods__["movement_fast"] = _moduleconnectorwrapper.SleepData_movement_fast_set
    __swig_getmethods__["movement_fast"] = _moduleconnectorwrapper.SleepData_movement_fast_get
    if _newclass:
        movement_fast = _swig_property(_moduleconnectorwrapper.SleepData_movement_fast_get, _moduleconnectorwrapper.SleepData_movement_fast_set)

    def __init__(self):
        """__init__(XeThru::SleepData self) -> SleepData"""
        this = _moduleconnectorwrapper.new_SleepData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_SleepData
    __del__ = lambda self: None
SleepData_swigregister = _moduleconnectorwrapper.SleepData_swigregister
SleepData_swigregister(SleepData)

class BasebandApData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents amplitude phase baseband data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `amplitude` : `std::vector< float >`  
        Vector of NumOfBins float values of the signal power.  

    * `phase` : `std::vector< float >`  
        Vector of NumOfBins float values of the signal phase.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BasebandApData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BasebandApData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::BasebandApData self) -> BasebandApData
        __init__(XeThru::BasebandApData self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float range_offset, float const * amplitude, float const * phase) -> BasebandApData



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_BasebandApData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_amplitude(self):
        """
        get_amplitude(BasebandApData self) -> FloatVector



        Returns a reference to the amplitude vector.  

        """
        return _moduleconnectorwrapper.BasebandApData_get_amplitude(self)


    def get_phase(self):
        """
        get_phase(BasebandApData self) -> FloatVector



        Returns a reference to the phase vector.  

        """
        return _moduleconnectorwrapper.BasebandApData_get_phase(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.BasebandApData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.BasebandApData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.BasebandApData_frame_counter_get, _moduleconnectorwrapper.BasebandApData_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.BasebandApData_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.BasebandApData_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.BasebandApData_num_bins_get, _moduleconnectorwrapper.BasebandApData_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.BasebandApData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.BasebandApData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.BasebandApData_bin_length_get, _moduleconnectorwrapper.BasebandApData_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.BasebandApData_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.BasebandApData_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.BasebandApData_sample_frequency_get, _moduleconnectorwrapper.BasebandApData_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.BasebandApData_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.BasebandApData_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.BasebandApData_carrier_frequency_get, _moduleconnectorwrapper.BasebandApData_carrier_frequency_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.BasebandApData_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.BasebandApData_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.BasebandApData_range_offset_get, _moduleconnectorwrapper.BasebandApData_range_offset_set)
    __swig_setmethods__["amplitude"] = _moduleconnectorwrapper.BasebandApData_amplitude_set
    __swig_getmethods__["amplitude"] = _moduleconnectorwrapper.BasebandApData_amplitude_get
    if _newclass:
        amplitude = _swig_property(_moduleconnectorwrapper.BasebandApData_amplitude_get, _moduleconnectorwrapper.BasebandApData_amplitude_set)
    __swig_setmethods__["phase"] = _moduleconnectorwrapper.BasebandApData_phase_set
    __swig_getmethods__["phase"] = _moduleconnectorwrapper.BasebandApData_phase_get
    if _newclass:
        phase = _swig_property(_moduleconnectorwrapper.BasebandApData_phase_get, _moduleconnectorwrapper.BasebandApData_phase_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_BasebandApData
    __del__ = lambda self: None
BasebandApData_swigregister = _moduleconnectorwrapper.BasebandApData_swigregister
BasebandApData_swigregister(BasebandApData)

class BasebandIqData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents I/Q baseband data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `i_data` : `std::vector< float >`  
        Vector of NumOfBins float values of the inphase signal.  

    * `q_data` : `std::vector< float >`  
        Vector of NumOfBins float values of the quadrature phase signal.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BasebandIqData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BasebandIqData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::BasebandIqData self) -> BasebandIqData
        __init__(XeThru::BasebandIqData self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float range_offset, float const * i, float const * q) -> BasebandIqData



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_BasebandIqData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_I(self):
        """
        get_I(BasebandIqData self) -> FloatVector



        Returns a reference to the in phase vector.  

        """
        return _moduleconnectorwrapper.BasebandIqData_get_I(self)


    def get_Q(self):
        """
        get_Q(BasebandIqData self) -> FloatVector



        Returns a reference to the in quadrature phase vector.  

        """
        return _moduleconnectorwrapper.BasebandIqData_get_Q(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.BasebandIqData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.BasebandIqData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.BasebandIqData_frame_counter_get, _moduleconnectorwrapper.BasebandIqData_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.BasebandIqData_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.BasebandIqData_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.BasebandIqData_num_bins_get, _moduleconnectorwrapper.BasebandIqData_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.BasebandIqData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.BasebandIqData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.BasebandIqData_bin_length_get, _moduleconnectorwrapper.BasebandIqData_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.BasebandIqData_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.BasebandIqData_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.BasebandIqData_sample_frequency_get, _moduleconnectorwrapper.BasebandIqData_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.BasebandIqData_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.BasebandIqData_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.BasebandIqData_carrier_frequency_get, _moduleconnectorwrapper.BasebandIqData_carrier_frequency_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.BasebandIqData_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.BasebandIqData_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.BasebandIqData_range_offset_get, _moduleconnectorwrapper.BasebandIqData_range_offset_set)
    __swig_setmethods__["i_data"] = _moduleconnectorwrapper.BasebandIqData_i_data_set
    __swig_getmethods__["i_data"] = _moduleconnectorwrapper.BasebandIqData_i_data_get
    if _newclass:
        i_data = _swig_property(_moduleconnectorwrapper.BasebandIqData_i_data_get, _moduleconnectorwrapper.BasebandIqData_i_data_set)
    __swig_setmethods__["q_data"] = _moduleconnectorwrapper.BasebandIqData_q_data_set
    __swig_getmethods__["q_data"] = _moduleconnectorwrapper.BasebandIqData_q_data_get
    if _newclass:
        q_data = _swig_property(_moduleconnectorwrapper.BasebandIqData_q_data_get, _moduleconnectorwrapper.BasebandIqData_q_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_BasebandIqData
    __del__ = lambda self: None
BasebandIqData_swigregister = _moduleconnectorwrapper.BasebandIqData_swigregister
BasebandIqData_swigregister(BasebandIqData)

class RadarRfData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents Radar RF data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `frames_per_second` : `float`  
        Chip frames per second in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `data` : `std::vector< uint32_t >`  
        Vector of NumOfBins float values of the signal.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadarRfData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadarRfData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::RadarRfData self) -> RadarRfData
        __init__(XeThru::RadarRfData self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float frames_per_second, float range_offset, uint32_t const * data) -> RadarRfData



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_RadarRfData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_data(self):
        """
        get_data(RadarRfData self) -> uiVector



        Returns a reference to the data vector.  

        """
        return _moduleconnectorwrapper.RadarRfData_get_data(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RadarRfData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RadarRfData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RadarRfData_frame_counter_get, _moduleconnectorwrapper.RadarRfData_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.RadarRfData_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.RadarRfData_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.RadarRfData_num_bins_get, _moduleconnectorwrapper.RadarRfData_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.RadarRfData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.RadarRfData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.RadarRfData_bin_length_get, _moduleconnectorwrapper.RadarRfData_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarRfData_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarRfData_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.RadarRfData_sample_frequency_get, _moduleconnectorwrapper.RadarRfData_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarRfData_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarRfData_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.RadarRfData_carrier_frequency_get, _moduleconnectorwrapper.RadarRfData_carrier_frequency_set)
    __swig_setmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarRfData_frames_per_second_set
    __swig_getmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarRfData_frames_per_second_get
    if _newclass:
        frames_per_second = _swig_property(_moduleconnectorwrapper.RadarRfData_frames_per_second_get, _moduleconnectorwrapper.RadarRfData_frames_per_second_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.RadarRfData_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.RadarRfData_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.RadarRfData_range_offset_get, _moduleconnectorwrapper.RadarRfData_range_offset_set)
    __swig_setmethods__["data"] = _moduleconnectorwrapper.RadarRfData_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.RadarRfData_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.RadarRfData_data_get, _moduleconnectorwrapper.RadarRfData_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_RadarRfData
    __del__ = lambda self: None
RadarRfData_swigregister = _moduleconnectorwrapper.RadarRfData_swigregister
RadarRfData_swigregister(RadarRfData)

class RadarRfNormalizedData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents Radar RF Normalized data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `frames_per_second` : `float`  
        Chip frames per second in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `data` : `std::vector< float >`  
        Vector of NumOfBins float values of the signal.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadarRfNormalizedData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadarRfNormalizedData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::RadarRfNormalizedData self) -> RadarRfNormalizedData
        __init__(XeThru::RadarRfNormalizedData self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float frames_per_second, float range_offset, float const * data) -> RadarRfNormalizedData



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_RadarRfNormalizedData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_data(self):
        """
        get_data(RadarRfNormalizedData self) -> FloatVector



        Returns a reference to the data vector.  

        """
        return _moduleconnectorwrapper.RadarRfNormalizedData_get_data(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RadarRfNormalizedData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RadarRfNormalizedData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_frame_counter_get, _moduleconnectorwrapper.RadarRfNormalizedData_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.RadarRfNormalizedData_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.RadarRfNormalizedData_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_num_bins_get, _moduleconnectorwrapper.RadarRfNormalizedData_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.RadarRfNormalizedData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.RadarRfNormalizedData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_bin_length_get, _moduleconnectorwrapper.RadarRfNormalizedData_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarRfNormalizedData_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarRfNormalizedData_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_sample_frequency_get, _moduleconnectorwrapper.RadarRfNormalizedData_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarRfNormalizedData_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarRfNormalizedData_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_carrier_frequency_get, _moduleconnectorwrapper.RadarRfNormalizedData_carrier_frequency_set)
    __swig_setmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarRfNormalizedData_frames_per_second_set
    __swig_getmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarRfNormalizedData_frames_per_second_get
    if _newclass:
        frames_per_second = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_frames_per_second_get, _moduleconnectorwrapper.RadarRfNormalizedData_frames_per_second_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.RadarRfNormalizedData_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.RadarRfNormalizedData_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_range_offset_get, _moduleconnectorwrapper.RadarRfNormalizedData_range_offset_set)
    __swig_setmethods__["data"] = _moduleconnectorwrapper.RadarRfNormalizedData_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.RadarRfNormalizedData_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.RadarRfNormalizedData_data_get, _moduleconnectorwrapper.RadarRfNormalizedData_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_RadarRfNormalizedData
    __del__ = lambda self: None
RadarRfNormalizedData_swigregister = _moduleconnectorwrapper.RadarRfNormalizedData_swigregister
RadarRfNormalizedData_swigregister(RadarRfNormalizedData)

class RadarBasebandFloatData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents Radar Baseband Float data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `frames_per_second` : `float`  
        Chip frames per second in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `decimation_factor` : `uint32_t`  
        Decimation factor for signal.  

    * `correction_bin` : `uint32_t`  
        Bin used for phase noise correction.  

    * `correction_i` : `float`  
        Phase noise correction inphase.  

    * `correction_q` : `float`  
        Phase noise correction quadrature.  

    * `i_data` : `std::vector< float >`  
        Vector of NumOfBins float values of the inphase signal.  

    * `q_data` : `std::vector< float >`  
        Vector of NumOfBins float values of the quadrature phase signal.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadarBasebandFloatData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadarBasebandFloatData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::RadarBasebandFloatData self) -> RadarBasebandFloatData
        __init__(XeThru::RadarBasebandFloatData self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float frames_per_second, float range_offset, uint32_t decimation_factor, uint32_t correction_bin, float correction_i, float correction_q, float const * i, float const * q) -> RadarBasebandFloatData



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_RadarBasebandFloatData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_I(self):
        """
        get_I(RadarBasebandFloatData self) -> FloatVector



        Returns a reference to the in phase vector.  

        """
        return _moduleconnectorwrapper.RadarBasebandFloatData_get_I(self)


    def get_Q(self):
        """
        get_Q(RadarBasebandFloatData self) -> FloatVector



        Returns a reference to the in quadrature phase vector.  

        """
        return _moduleconnectorwrapper.RadarBasebandFloatData_get_Q(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RadarBasebandFloatData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RadarBasebandFloatData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_frame_counter_get, _moduleconnectorwrapper.RadarBasebandFloatData_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.RadarBasebandFloatData_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.RadarBasebandFloatData_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_num_bins_get, _moduleconnectorwrapper.RadarBasebandFloatData_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.RadarBasebandFloatData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.RadarBasebandFloatData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_bin_length_get, _moduleconnectorwrapper.RadarBasebandFloatData_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarBasebandFloatData_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarBasebandFloatData_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_sample_frequency_get, _moduleconnectorwrapper.RadarBasebandFloatData_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarBasebandFloatData_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarBasebandFloatData_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_carrier_frequency_get, _moduleconnectorwrapper.RadarBasebandFloatData_carrier_frequency_set)
    __swig_setmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarBasebandFloatData_frames_per_second_set
    __swig_getmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarBasebandFloatData_frames_per_second_get
    if _newclass:
        frames_per_second = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_frames_per_second_get, _moduleconnectorwrapper.RadarBasebandFloatData_frames_per_second_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.RadarBasebandFloatData_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.RadarBasebandFloatData_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_range_offset_get, _moduleconnectorwrapper.RadarBasebandFloatData_range_offset_set)
    __swig_setmethods__["decimation_factor"] = _moduleconnectorwrapper.RadarBasebandFloatData_decimation_factor_set
    __swig_getmethods__["decimation_factor"] = _moduleconnectorwrapper.RadarBasebandFloatData_decimation_factor_get
    if _newclass:
        decimation_factor = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_decimation_factor_get, _moduleconnectorwrapper.RadarBasebandFloatData_decimation_factor_set)
    __swig_setmethods__["correction_bin"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_bin_set
    __swig_getmethods__["correction_bin"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_bin_get
    if _newclass:
        correction_bin = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_correction_bin_get, _moduleconnectorwrapper.RadarBasebandFloatData_correction_bin_set)
    __swig_setmethods__["correction_i"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_i_set
    __swig_getmethods__["correction_i"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_i_get
    if _newclass:
        correction_i = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_correction_i_get, _moduleconnectorwrapper.RadarBasebandFloatData_correction_i_set)
    __swig_setmethods__["correction_q"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_q_set
    __swig_getmethods__["correction_q"] = _moduleconnectorwrapper.RadarBasebandFloatData_correction_q_get
    if _newclass:
        correction_q = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_correction_q_get, _moduleconnectorwrapper.RadarBasebandFloatData_correction_q_set)
    __swig_setmethods__["i_data"] = _moduleconnectorwrapper.RadarBasebandFloatData_i_data_set
    __swig_getmethods__["i_data"] = _moduleconnectorwrapper.RadarBasebandFloatData_i_data_get
    if _newclass:
        i_data = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_i_data_get, _moduleconnectorwrapper.RadarBasebandFloatData_i_data_set)
    __swig_setmethods__["q_data"] = _moduleconnectorwrapper.RadarBasebandFloatData_q_data_set
    __swig_getmethods__["q_data"] = _moduleconnectorwrapper.RadarBasebandFloatData_q_data_get
    if _newclass:
        q_data = _swig_property(_moduleconnectorwrapper.RadarBasebandFloatData_q_data_get, _moduleconnectorwrapper.RadarBasebandFloatData_q_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_RadarBasebandFloatData
    __del__ = lambda self: None
RadarBasebandFloatData_swigregister = _moduleconnectorwrapper.RadarBasebandFloatData_swigregister
RadarBasebandFloatData_swigregister(RadarBasebandFloatData)

class RadarBasebandQ15Data(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Represents Radar Baseband Q15 data coming from the module.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        A sequential counter from the radar data.  

        Incremented for each captured frame.  

    * `num_bins` : `uint32_t`  
        Number of bins in dataset.  

    * `bin_length` : `float`  
        Length in meters between each bin.  

    * `sample_frequency` : `float`  
        Chip sampling frequency in Hz.  

    * `carrier_frequency` : `float`  
        Chip carrier frequency in Hz.  

    * `frames_per_second` : `float`  
        Chip frames per second in Hz.  

    * `range_offset` : `float`  
        First range bin start in meters.  

    * `decimation_factor` : `uint32_t`  
        Decimation factor for signal.  

    * `correction_bin` : `uint32_t`  
        Bin used for phase noise correction.  

    * `correction_i` : `float`  
        Phase noise correction inphase.  

    * `correction_q` : `float`  
        Phase noise correction quadrature.  

    * `scaling_factor` : `float`  
        Scaling factor for float to Q15 data.  

    * `i_data` : `std::vector< int16_t >`  
        Vector of NumOfBins float values of the inphase signal.  

    * `q_data` : `std::vector< int16_t >`  
        Vector of NumOfBins float values of the quadrature phase signal.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadarBasebandQ15Data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadarBasebandQ15Data, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::RadarBasebandQ15Data self) -> RadarBasebandQ15Data
        __init__(XeThru::RadarBasebandQ15Data self, uint32_t frame_counter, uint32_t num_bins, float bin_length, float sample_frequency, float carrier_frequency, float frames_per_second, float range_offset, uint32_t decimation_factor, uint32_t correction_bin, float correction_i, float correction_q, float scaling_factor, int16_t const * i, int16_t const * q) -> RadarBasebandQ15Data



        Constructor.  

        """
        this = _moduleconnectorwrapper.new_RadarBasebandQ15Data(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_I(self):
        """
        get_I(RadarBasebandQ15Data self) -> sVector



        Returns a reference to the in phase vector.  

        """
        return _moduleconnectorwrapper.RadarBasebandQ15Data_get_I(self)


    def get_Q(self):
        """
        get_Q(RadarBasebandQ15Data self) -> sVector



        Returns a reference to the in quadrature phase vector.  

        """
        return _moduleconnectorwrapper.RadarBasebandQ15Data_get_Q(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RadarBasebandQ15Data_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RadarBasebandQ15Data_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_frame_counter_get, _moduleconnectorwrapper.RadarBasebandQ15Data_frame_counter_set)
    __swig_setmethods__["num_bins"] = _moduleconnectorwrapper.RadarBasebandQ15Data_num_bins_set
    __swig_getmethods__["num_bins"] = _moduleconnectorwrapper.RadarBasebandQ15Data_num_bins_get
    if _newclass:
        num_bins = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_num_bins_get, _moduleconnectorwrapper.RadarBasebandQ15Data_num_bins_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.RadarBasebandQ15Data_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.RadarBasebandQ15Data_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_bin_length_get, _moduleconnectorwrapper.RadarBasebandQ15Data_bin_length_set)
    __swig_setmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarBasebandQ15Data_sample_frequency_set
    __swig_getmethods__["sample_frequency"] = _moduleconnectorwrapper.RadarBasebandQ15Data_sample_frequency_get
    if _newclass:
        sample_frequency = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_sample_frequency_get, _moduleconnectorwrapper.RadarBasebandQ15Data_sample_frequency_set)
    __swig_setmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarBasebandQ15Data_carrier_frequency_set
    __swig_getmethods__["carrier_frequency"] = _moduleconnectorwrapper.RadarBasebandQ15Data_carrier_frequency_get
    if _newclass:
        carrier_frequency = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_carrier_frequency_get, _moduleconnectorwrapper.RadarBasebandQ15Data_carrier_frequency_set)
    __swig_setmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarBasebandQ15Data_frames_per_second_set
    __swig_getmethods__["frames_per_second"] = _moduleconnectorwrapper.RadarBasebandQ15Data_frames_per_second_get
    if _newclass:
        frames_per_second = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_frames_per_second_get, _moduleconnectorwrapper.RadarBasebandQ15Data_frames_per_second_set)
    __swig_setmethods__["range_offset"] = _moduleconnectorwrapper.RadarBasebandQ15Data_range_offset_set
    __swig_getmethods__["range_offset"] = _moduleconnectorwrapper.RadarBasebandQ15Data_range_offset_get
    if _newclass:
        range_offset = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_range_offset_get, _moduleconnectorwrapper.RadarBasebandQ15Data_range_offset_set)
    __swig_setmethods__["decimation_factor"] = _moduleconnectorwrapper.RadarBasebandQ15Data_decimation_factor_set
    __swig_getmethods__["decimation_factor"] = _moduleconnectorwrapper.RadarBasebandQ15Data_decimation_factor_get
    if _newclass:
        decimation_factor = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_decimation_factor_get, _moduleconnectorwrapper.RadarBasebandQ15Data_decimation_factor_set)
    __swig_setmethods__["correction_bin"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_bin_set
    __swig_getmethods__["correction_bin"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_bin_get
    if _newclass:
        correction_bin = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_correction_bin_get, _moduleconnectorwrapper.RadarBasebandQ15Data_correction_bin_set)
    __swig_setmethods__["correction_i"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_i_set
    __swig_getmethods__["correction_i"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_i_get
    if _newclass:
        correction_i = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_correction_i_get, _moduleconnectorwrapper.RadarBasebandQ15Data_correction_i_set)
    __swig_setmethods__["correction_q"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_q_set
    __swig_getmethods__["correction_q"] = _moduleconnectorwrapper.RadarBasebandQ15Data_correction_q_get
    if _newclass:
        correction_q = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_correction_q_get, _moduleconnectorwrapper.RadarBasebandQ15Data_correction_q_set)
    __swig_setmethods__["scaling_factor"] = _moduleconnectorwrapper.RadarBasebandQ15Data_scaling_factor_set
    __swig_getmethods__["scaling_factor"] = _moduleconnectorwrapper.RadarBasebandQ15Data_scaling_factor_get
    if _newclass:
        scaling_factor = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_scaling_factor_get, _moduleconnectorwrapper.RadarBasebandQ15Data_scaling_factor_set)
    __swig_setmethods__["i_data"] = _moduleconnectorwrapper.RadarBasebandQ15Data_i_data_set
    __swig_getmethods__["i_data"] = _moduleconnectorwrapper.RadarBasebandQ15Data_i_data_get
    if _newclass:
        i_data = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_i_data_get, _moduleconnectorwrapper.RadarBasebandQ15Data_i_data_set)
    __swig_setmethods__["q_data"] = _moduleconnectorwrapper.RadarBasebandQ15Data_q_data_set
    __swig_getmethods__["q_data"] = _moduleconnectorwrapper.RadarBasebandQ15Data_q_data_get
    if _newclass:
        q_data = _swig_property(_moduleconnectorwrapper.RadarBasebandQ15Data_q_data_get, _moduleconnectorwrapper.RadarBasebandQ15Data_q_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_RadarBasebandQ15Data
    __del__ = lambda self: None
RadarBasebandQ15Data_swigregister = _moduleconnectorwrapper.RadarBasebandQ15Data_swigregister
RadarBasebandQ15Data_swigregister(RadarBasebandQ15Data)

class PresenceSingleData(_object):
    """


    Encapsulates and aggregates true presenece data coming from the Xethru X4M300
    module.  

    Parameters
    ----------
    * `frame_counter` :  
        The frame counter  
    * `presence_state` :  
        Presence state output. See xtid.h for values.  
    * `distance` :  
        Distance in meters from sensor to presence detected.  
    * `direction` :  
        Movement direction of detected object.  
    * `signal_quality` :  
        signal quality  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  

    * `presence_state` : `uint32_t`  

    * `distance` : `float`  

    * `direction` : `uint8_t`  

    * `signal_quality` : `uint32_t`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PresenceSingleData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PresenceSingleData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.PresenceSingleData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.PresenceSingleData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.PresenceSingleData_frame_counter_get, _moduleconnectorwrapper.PresenceSingleData_frame_counter_set)
    __swig_setmethods__["presence_state"] = _moduleconnectorwrapper.PresenceSingleData_presence_state_set
    __swig_getmethods__["presence_state"] = _moduleconnectorwrapper.PresenceSingleData_presence_state_get
    if _newclass:
        presence_state = _swig_property(_moduleconnectorwrapper.PresenceSingleData_presence_state_get, _moduleconnectorwrapper.PresenceSingleData_presence_state_set)
    __swig_setmethods__["distance"] = _moduleconnectorwrapper.PresenceSingleData_distance_set
    __swig_getmethods__["distance"] = _moduleconnectorwrapper.PresenceSingleData_distance_get
    if _newclass:
        distance = _swig_property(_moduleconnectorwrapper.PresenceSingleData_distance_get, _moduleconnectorwrapper.PresenceSingleData_distance_set)
    __swig_setmethods__["direction"] = _moduleconnectorwrapper.PresenceSingleData_direction_set
    __swig_getmethods__["direction"] = _moduleconnectorwrapper.PresenceSingleData_direction_get
    if _newclass:
        direction = _swig_property(_moduleconnectorwrapper.PresenceSingleData_direction_get, _moduleconnectorwrapper.PresenceSingleData_direction_set)
    __swig_setmethods__["signal_quality"] = _moduleconnectorwrapper.PresenceSingleData_signal_quality_set
    __swig_getmethods__["signal_quality"] = _moduleconnectorwrapper.PresenceSingleData_signal_quality_get
    if _newclass:
        signal_quality = _swig_property(_moduleconnectorwrapper.PresenceSingleData_signal_quality_get, _moduleconnectorwrapper.PresenceSingleData_signal_quality_set)

    def __init__(self):
        """__init__(XeThru::PresenceSingleData self) -> PresenceSingleData"""
        this = _moduleconnectorwrapper.new_PresenceSingleData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PresenceSingleData
    __del__ = lambda self: None
PresenceSingleData_swigregister = _moduleconnectorwrapper.PresenceSingleData_swigregister
PresenceSingleData_swigregister(PresenceSingleData)

class PresenceMovingListData(_object):
    """


    Encapsulates and aggregates presence data coming from the Xethru X4M300 module.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Parameters
    ----------
    * `frame_counter` :  
        The frame counter  
    * `presence_state` :  
        Presence state output. See xtid.h for values.  
    * `movement_slow_items` :  
        List of movement metrics split into sections of the detection zone. Longer
        integration time. First element is a global metric.  
    * `movement_fast_items` :  
        List of movement metrics split into sections of the detection zone. Shorter
        integration time. First element is a global metric.  
    * `detection_distance_items` :  
        Not implemented.  
    * `radar_cross_section_items` :  
        Not implemented.  
    * `detection_velocity_items` :  
        Not implemented.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  

    * `presence_state` : `uint32_t`  

    * `movement_slow_items` : `std::vector< float >`  

    * `movement_fast_items` : `std::vector< float >`  

    * `detection_distance_items` : `std::vector< float >`  

    * `radar_cross_section_items` : `std::vector< float >`  

    * `detection_velocity_items` : `std::vector< float >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PresenceMovingListData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PresenceMovingListData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.PresenceMovingListData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.PresenceMovingListData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_frame_counter_get, _moduleconnectorwrapper.PresenceMovingListData_frame_counter_set)
    __swig_setmethods__["presence_state"] = _moduleconnectorwrapper.PresenceMovingListData_presence_state_set
    __swig_getmethods__["presence_state"] = _moduleconnectorwrapper.PresenceMovingListData_presence_state_get
    if _newclass:
        presence_state = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_presence_state_get, _moduleconnectorwrapper.PresenceMovingListData_presence_state_set)
    __swig_setmethods__["movement_slow_items"] = _moduleconnectorwrapper.PresenceMovingListData_movement_slow_items_set
    __swig_getmethods__["movement_slow_items"] = _moduleconnectorwrapper.PresenceMovingListData_movement_slow_items_get
    if _newclass:
        movement_slow_items = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_movement_slow_items_get, _moduleconnectorwrapper.PresenceMovingListData_movement_slow_items_set)
    __swig_setmethods__["movement_fast_items"] = _moduleconnectorwrapper.PresenceMovingListData_movement_fast_items_set
    __swig_getmethods__["movement_fast_items"] = _moduleconnectorwrapper.PresenceMovingListData_movement_fast_items_get
    if _newclass:
        movement_fast_items = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_movement_fast_items_get, _moduleconnectorwrapper.PresenceMovingListData_movement_fast_items_set)
    __swig_setmethods__["detection_distance_items"] = _moduleconnectorwrapper.PresenceMovingListData_detection_distance_items_set
    __swig_getmethods__["detection_distance_items"] = _moduleconnectorwrapper.PresenceMovingListData_detection_distance_items_get
    if _newclass:
        detection_distance_items = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_detection_distance_items_get, _moduleconnectorwrapper.PresenceMovingListData_detection_distance_items_set)
    __swig_setmethods__["radar_cross_section_items"] = _moduleconnectorwrapper.PresenceMovingListData_radar_cross_section_items_set
    __swig_getmethods__["radar_cross_section_items"] = _moduleconnectorwrapper.PresenceMovingListData_radar_cross_section_items_get
    if _newclass:
        radar_cross_section_items = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_radar_cross_section_items_get, _moduleconnectorwrapper.PresenceMovingListData_radar_cross_section_items_set)
    __swig_setmethods__["detection_velocity_items"] = _moduleconnectorwrapper.PresenceMovingListData_detection_velocity_items_set
    __swig_getmethods__["detection_velocity_items"] = _moduleconnectorwrapper.PresenceMovingListData_detection_velocity_items_get
    if _newclass:
        detection_velocity_items = _swig_property(_moduleconnectorwrapper.PresenceMovingListData_detection_velocity_items_get, _moduleconnectorwrapper.PresenceMovingListData_detection_velocity_items_set)

    def get_movement_slow_items(self):
        """
        get_movement_slow_items(PresenceMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.PresenceMovingListData_get_movement_slow_items(self)


    def get_movement_fast_items(self):
        """
        get_movement_fast_items(PresenceMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.PresenceMovingListData_get_movement_fast_items(self)


    def get_detection_distance_items(self):
        """
        get_detection_distance_items(PresenceMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.PresenceMovingListData_get_detection_distance_items(self)


    def get_radar_cross_section(self):
        """
        get_radar_cross_section(PresenceMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.PresenceMovingListData_get_radar_cross_section(self)


    def get_detection_velocity_items(self):
        """
        get_detection_velocity_items(PresenceMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.PresenceMovingListData_get_detection_velocity_items(self)


    def __init__(self):
        """__init__(XeThru::PresenceMovingListData self) -> PresenceMovingListData"""
        this = _moduleconnectorwrapper.new_PresenceMovingListData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PresenceMovingListData
    __del__ = lambda self: None
PresenceMovingListData_swigregister = _moduleconnectorwrapper.PresenceMovingListData_swigregister
PresenceMovingListData_swigregister(PresenceMovingListData)

class RespirationMovingListData(_object):
    """


    Movement is a percentage of Doppler bins above threshold.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Parameters
    ----------
    * `counter` :  
        Frame counter.  
    * `movement_slow_items` :  
        Percentage of Doppler bins above threshold per range bin, slow integration.
        First element is a global metric.  
    * `movement_fast_items` :  
        Percentage of Doppler bins above threshold per range bin, fast integration.
        First element is a global metric.  

    Attributes
    ----------
    * `counter` : `uint32_t`  

    * `movement_slow_items` : `std::vector< float >`  

    * `movement_fast_items` : `std::vector< float >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RespirationMovingListData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RespirationMovingListData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["counter"] = _moduleconnectorwrapper.RespirationMovingListData_counter_set
    __swig_getmethods__["counter"] = _moduleconnectorwrapper.RespirationMovingListData_counter_get
    if _newclass:
        counter = _swig_property(_moduleconnectorwrapper.RespirationMovingListData_counter_get, _moduleconnectorwrapper.RespirationMovingListData_counter_set)
    __swig_setmethods__["movement_slow_items"] = _moduleconnectorwrapper.RespirationMovingListData_movement_slow_items_set
    __swig_getmethods__["movement_slow_items"] = _moduleconnectorwrapper.RespirationMovingListData_movement_slow_items_get
    if _newclass:
        movement_slow_items = _swig_property(_moduleconnectorwrapper.RespirationMovingListData_movement_slow_items_get, _moduleconnectorwrapper.RespirationMovingListData_movement_slow_items_set)
    __swig_setmethods__["movement_fast_items"] = _moduleconnectorwrapper.RespirationMovingListData_movement_fast_items_set
    __swig_getmethods__["movement_fast_items"] = _moduleconnectorwrapper.RespirationMovingListData_movement_fast_items_get
    if _newclass:
        movement_fast_items = _swig_property(_moduleconnectorwrapper.RespirationMovingListData_movement_fast_items_get, _moduleconnectorwrapper.RespirationMovingListData_movement_fast_items_set)

    def get_movement_slow_items(self):
        """
        get_movement_slow_items(RespirationMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.RespirationMovingListData_get_movement_slow_items(self)


    def get_movement_fast_items(self):
        """
        get_movement_fast_items(RespirationMovingListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.RespirationMovingListData_get_movement_fast_items(self)


    def __init__(self):
        """__init__(XeThru::RespirationMovingListData self) -> RespirationMovingListData"""
        this = _moduleconnectorwrapper.new_RespirationMovingListData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RespirationMovingListData
    __del__ = lambda self: None
RespirationMovingListData_swigregister = _moduleconnectorwrapper.RespirationMovingListData_swigregister
RespirationMovingListData_swigregister(RespirationMovingListData)

class RespirationDetectionListData(_object):
    """


    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected.  

    Use accessor methods for a workaround.  

    Parameters
    ----------
    * `counter` :  
        Frame counter.  
    * `detection_count` :  
        Number of detections.  
    * `detection_distance_items` :  
        Distance per detection.  
    * `detection_radar_cross_section_items` :  
        RCS per detection.  
    * `detection_velocity_items` :  
        Velocity per detection.  

    Attributes
    ----------
    * `counter` : `uint32_t`  

    * `detection_count` : `uint32_t`  

    * `detection_distance_items` : `std::vector< float >`  

    * `detection_radar_cross_section_items` : `std::vector< float >`  

    * `detection_velocity_items` : `std::vector< float >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RespirationDetectionListData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RespirationDetectionListData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["counter"] = _moduleconnectorwrapper.RespirationDetectionListData_counter_set
    __swig_getmethods__["counter"] = _moduleconnectorwrapper.RespirationDetectionListData_counter_get
    if _newclass:
        counter = _swig_property(_moduleconnectorwrapper.RespirationDetectionListData_counter_get, _moduleconnectorwrapper.RespirationDetectionListData_counter_set)
    __swig_setmethods__["detection_count"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_count_set
    __swig_getmethods__["detection_count"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_count_get
    if _newclass:
        detection_count = _swig_property(_moduleconnectorwrapper.RespirationDetectionListData_detection_count_get, _moduleconnectorwrapper.RespirationDetectionListData_detection_count_set)
    __swig_setmethods__["detection_distance_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_distance_items_set
    __swig_getmethods__["detection_distance_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_distance_items_get
    if _newclass:
        detection_distance_items = _swig_property(_moduleconnectorwrapper.RespirationDetectionListData_detection_distance_items_get, _moduleconnectorwrapper.RespirationDetectionListData_detection_distance_items_set)
    __swig_setmethods__["detection_radar_cross_section_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_radar_cross_section_items_set
    __swig_getmethods__["detection_radar_cross_section_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_radar_cross_section_items_get
    if _newclass:
        detection_radar_cross_section_items = _swig_property(_moduleconnectorwrapper.RespirationDetectionListData_detection_radar_cross_section_items_get, _moduleconnectorwrapper.RespirationDetectionListData_detection_radar_cross_section_items_set)
    __swig_setmethods__["detection_velocity_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_velocity_items_set
    __swig_getmethods__["detection_velocity_items"] = _moduleconnectorwrapper.RespirationDetectionListData_detection_velocity_items_get
    if _newclass:
        detection_velocity_items = _swig_property(_moduleconnectorwrapper.RespirationDetectionListData_detection_velocity_items_get, _moduleconnectorwrapper.RespirationDetectionListData_detection_velocity_items_set)

    def get_detection_distance_items(self):
        """
        get_detection_distance_items(RespirationDetectionListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.RespirationDetectionListData_get_detection_distance_items(self)


    def get_detection_radar_cross_section_items(self):
        """
        get_detection_radar_cross_section_items(RespirationDetectionListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.RespirationDetectionListData_get_detection_radar_cross_section_items(self)


    def get_detection_velocity_items(self):
        """
        get_detection_velocity_items(RespirationDetectionListData self) -> FloatVector



        """
        return _moduleconnectorwrapper.RespirationDetectionListData_get_detection_velocity_items(self)


    def __init__(self):
        """__init__(XeThru::RespirationDetectionListData self) -> RespirationDetectionListData"""
        this = _moduleconnectorwrapper.new_RespirationDetectionListData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RespirationDetectionListData
    __del__ = lambda self: None
RespirationDetectionListData_swigregister = _moduleconnectorwrapper.RespirationDetectionListData_swigregister
RespirationDetectionListData_swigregister(RespirationDetectionListData)

class RespirationNormalizedMovementListData(_object):
    """


    Movement in absolute terms, sum of power per Doppler bin over threshold
    compensated for range.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Parameters
    ----------
    * `frame_counter` :  
        Frame counter.  
    * `start` :  
        Distance to first range bin in meters.  
    * `bin_length` :  
        Length of one bin in meters.  
    * `count` :  
        Number of range bins.  
    * `normalized_movement_slow_items` :  
        Movement per range bin, slow integration. First element is first rangebin,
        NOT a global metric.  
    * `normalized_movement_fast_items` :  
        Movement per range bin, fast integration. First element is first rangebin,
        NOT a global metric.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  

    * `start` : `float`  

    * `bin_length` : `float`  

    * `count` : `uint32_t`  

    * `normalized_movement_slow_items` : `std::vector< float >`  

    * `normalized_movement_fast_items` : `std::vector< float >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RespirationNormalizedMovementListData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RespirationNormalizedMovementListData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_frame_counter_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_frame_counter_set)
    __swig_setmethods__["start"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_start_set
    __swig_getmethods__["start"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_start_get
    if _newclass:
        start = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_start_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_start_set)
    __swig_setmethods__["bin_length"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_bin_length_set
    __swig_getmethods__["bin_length"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_bin_length_get
    if _newclass:
        bin_length = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_bin_length_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_bin_length_set)
    __swig_setmethods__["count"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_count_set
    __swig_getmethods__["count"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_count_get
    if _newclass:
        count = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_count_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_count_set)
    __swig_setmethods__["normalized_movement_slow_items"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_slow_items_set
    __swig_getmethods__["normalized_movement_slow_items"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_slow_items_get
    if _newclass:
        normalized_movement_slow_items = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_slow_items_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_slow_items_set)
    __swig_setmethods__["normalized_movement_fast_items"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_fast_items_set
    __swig_getmethods__["normalized_movement_fast_items"] = _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_fast_items_get
    if _newclass:
        normalized_movement_fast_items = _swig_property(_moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_fast_items_get, _moduleconnectorwrapper.RespirationNormalizedMovementListData_normalized_movement_fast_items_set)

    def __init__(self):
        """__init__(XeThru::RespirationNormalizedMovementListData self) -> RespirationNormalizedMovementListData"""
        this = _moduleconnectorwrapper.new_RespirationNormalizedMovementListData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RespirationNormalizedMovementListData
    __del__ = lambda self: None
RespirationNormalizedMovementListData_swigregister = _moduleconnectorwrapper.RespirationNormalizedMovementListData_swigregister
RespirationNormalizedMovementListData_swigregister(RespirationNormalizedMovementListData)

class VitalSignsData(_object):
    """


    Various vital signs.  

    Parameters
    ----------
    * `frame_counter` :  
        Frame counter.  
    * `sensor_state` :  
        See XTS_VAL_RESP_STATE_* in xtid.h for meaning.  
    * `respiration_rate` :  
        Respirations per minute  
    * `respiration_distance` :  
        Distance to breather.  
    * `respiration_confidence` :  
        Confidence. Not yet used.  
    * `heart_rate` :  
        Beats per minute. Not yet used.  
    * `heart_distance` :  
        Distance to target with pulse. Not yet used.  
    * `heart_confidence` :  
        Confidence. Not yet used.  
    * `normalized_movement_slow` :  
        Sum of movement within a fixed range from the target, slow integration.  
    * `normalized_movement_fast` :  
        Sum of movement within a fixed range from the target, fast integration.  
    * `normalized_movement_start` :  
        Start of the range to sum.  
    * `normalized_movement_end` :  
        End of the range to sum.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  

    * `sensor_state` : `uint32_t`  

    * `respiration_rate` : `float`  

    * `respiration_distance` : `float`  

    * `respiration_confidence` : `float`  

    * `heart_rate` : `float`  

    * `heart_distance` : `float`  

    * `heart_confidence` : `float`  

    * `normalized_movement_slow` : `float`  

    * `normalized_movement_fast` : `float`  

    * `normalized_movement_start` : `float`  

    * `normalized_movement_end` : `float`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VitalSignsData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VitalSignsData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.VitalSignsData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.VitalSignsData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.VitalSignsData_frame_counter_get, _moduleconnectorwrapper.VitalSignsData_frame_counter_set)
    __swig_setmethods__["sensor_state"] = _moduleconnectorwrapper.VitalSignsData_sensor_state_set
    __swig_getmethods__["sensor_state"] = _moduleconnectorwrapper.VitalSignsData_sensor_state_get
    if _newclass:
        sensor_state = _swig_property(_moduleconnectorwrapper.VitalSignsData_sensor_state_get, _moduleconnectorwrapper.VitalSignsData_sensor_state_set)
    __swig_setmethods__["respiration_rate"] = _moduleconnectorwrapper.VitalSignsData_respiration_rate_set
    __swig_getmethods__["respiration_rate"] = _moduleconnectorwrapper.VitalSignsData_respiration_rate_get
    if _newclass:
        respiration_rate = _swig_property(_moduleconnectorwrapper.VitalSignsData_respiration_rate_get, _moduleconnectorwrapper.VitalSignsData_respiration_rate_set)
    __swig_setmethods__["respiration_distance"] = _moduleconnectorwrapper.VitalSignsData_respiration_distance_set
    __swig_getmethods__["respiration_distance"] = _moduleconnectorwrapper.VitalSignsData_respiration_distance_get
    if _newclass:
        respiration_distance = _swig_property(_moduleconnectorwrapper.VitalSignsData_respiration_distance_get, _moduleconnectorwrapper.VitalSignsData_respiration_distance_set)
    __swig_setmethods__["respiration_confidence"] = _moduleconnectorwrapper.VitalSignsData_respiration_confidence_set
    __swig_getmethods__["respiration_confidence"] = _moduleconnectorwrapper.VitalSignsData_respiration_confidence_get
    if _newclass:
        respiration_confidence = _swig_property(_moduleconnectorwrapper.VitalSignsData_respiration_confidence_get, _moduleconnectorwrapper.VitalSignsData_respiration_confidence_set)
    __swig_setmethods__["heart_rate"] = _moduleconnectorwrapper.VitalSignsData_heart_rate_set
    __swig_getmethods__["heart_rate"] = _moduleconnectorwrapper.VitalSignsData_heart_rate_get
    if _newclass:
        heart_rate = _swig_property(_moduleconnectorwrapper.VitalSignsData_heart_rate_get, _moduleconnectorwrapper.VitalSignsData_heart_rate_set)
    __swig_setmethods__["heart_distance"] = _moduleconnectorwrapper.VitalSignsData_heart_distance_set
    __swig_getmethods__["heart_distance"] = _moduleconnectorwrapper.VitalSignsData_heart_distance_get
    if _newclass:
        heart_distance = _swig_property(_moduleconnectorwrapper.VitalSignsData_heart_distance_get, _moduleconnectorwrapper.VitalSignsData_heart_distance_set)
    __swig_setmethods__["heart_confidence"] = _moduleconnectorwrapper.VitalSignsData_heart_confidence_set
    __swig_getmethods__["heart_confidence"] = _moduleconnectorwrapper.VitalSignsData_heart_confidence_get
    if _newclass:
        heart_confidence = _swig_property(_moduleconnectorwrapper.VitalSignsData_heart_confidence_get, _moduleconnectorwrapper.VitalSignsData_heart_confidence_set)
    __swig_setmethods__["normalized_movement_slow"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_slow_set
    __swig_getmethods__["normalized_movement_slow"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_slow_get
    if _newclass:
        normalized_movement_slow = _swig_property(_moduleconnectorwrapper.VitalSignsData_normalized_movement_slow_get, _moduleconnectorwrapper.VitalSignsData_normalized_movement_slow_set)
    __swig_setmethods__["normalized_movement_fast"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_fast_set
    __swig_getmethods__["normalized_movement_fast"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_fast_get
    if _newclass:
        normalized_movement_fast = _swig_property(_moduleconnectorwrapper.VitalSignsData_normalized_movement_fast_get, _moduleconnectorwrapper.VitalSignsData_normalized_movement_fast_set)
    __swig_setmethods__["normalized_movement_start"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_start_set
    __swig_getmethods__["normalized_movement_start"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_start_get
    if _newclass:
        normalized_movement_start = _swig_property(_moduleconnectorwrapper.VitalSignsData_normalized_movement_start_get, _moduleconnectorwrapper.VitalSignsData_normalized_movement_start_set)
    __swig_setmethods__["normalized_movement_end"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_end_set
    __swig_getmethods__["normalized_movement_end"] = _moduleconnectorwrapper.VitalSignsData_normalized_movement_end_get
    if _newclass:
        normalized_movement_end = _swig_property(_moduleconnectorwrapper.VitalSignsData_normalized_movement_end_get, _moduleconnectorwrapper.VitalSignsData_normalized_movement_end_set)

    def __init__(self):
        """__init__(XeThru::VitalSignsData self) -> VitalSignsData"""
        this = _moduleconnectorwrapper.new_VitalSignsData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_VitalSignsData
    __del__ = lambda self: None
VitalSignsData_swigregister = _moduleconnectorwrapper.VitalSignsData_swigregister
VitalSignsData_swigregister(VitalSignsData)

class SleepStageData(_object):
    """


    Attributes
    ----------
    * `frame_counter` : `uint32_t`  

    * `sleepstage` : `uint32_t`  

    * `confidence` : `uint32_t`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SleepStageData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SleepStageData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.SleepStageData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.SleepStageData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.SleepStageData_frame_counter_get, _moduleconnectorwrapper.SleepStageData_frame_counter_set)
    __swig_setmethods__["sleepstage"] = _moduleconnectorwrapper.SleepStageData_sleepstage_set
    __swig_getmethods__["sleepstage"] = _moduleconnectorwrapper.SleepStageData_sleepstage_get
    if _newclass:
        sleepstage = _swig_property(_moduleconnectorwrapper.SleepStageData_sleepstage_get, _moduleconnectorwrapper.SleepStageData_sleepstage_set)
    __swig_setmethods__["confidence"] = _moduleconnectorwrapper.SleepStageData_confidence_set
    __swig_getmethods__["confidence"] = _moduleconnectorwrapper.SleepStageData_confidence_get
    if _newclass:
        confidence = _swig_property(_moduleconnectorwrapper.SleepStageData_confidence_get, _moduleconnectorwrapper.SleepStageData_confidence_set)

    def __init__(self):
        """__init__(XeThru::SleepStageData self) -> SleepStageData"""
        this = _moduleconnectorwrapper.new_SleepStageData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_SleepStageData
    __del__ = lambda self: None
SleepStageData_swigregister = _moduleconnectorwrapper.SleepStageData_swigregister
SleepStageData_swigregister(SleepStageData)

class Files(_object):
    """


    Attributes
    ----------
    * `file_type_items` : `std::vector< int32_t >`  

    * `file_identifier_items` : `std::vector< int32_t >`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Files, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Files, name)
    __repr__ = _swig_repr
    __swig_setmethods__["file_type_items"] = _moduleconnectorwrapper.Files_file_type_items_set
    __swig_getmethods__["file_type_items"] = _moduleconnectorwrapper.Files_file_type_items_get
    if _newclass:
        file_type_items = _swig_property(_moduleconnectorwrapper.Files_file_type_items_get, _moduleconnectorwrapper.Files_file_type_items_set)
    __swig_setmethods__["file_identifier_items"] = _moduleconnectorwrapper.Files_file_identifier_items_set
    __swig_getmethods__["file_identifier_items"] = _moduleconnectorwrapper.Files_file_identifier_items_get
    if _newclass:
        file_identifier_items = _swig_property(_moduleconnectorwrapper.Files_file_identifier_items_get, _moduleconnectorwrapper.Files_file_identifier_items_set)

    def get_file_type_items(self):
        """
        get_file_type_items(Files self) -> iVector



        """
        return _moduleconnectorwrapper.Files_get_file_type_items(self)


    def get_file_identifier_items(self):
        """
        get_file_identifier_items(Files self) -> iVector



        """
        return _moduleconnectorwrapper.Files_get_file_identifier_items(self)


    def __init__(self):
        """__init__(XeThru::Files self) -> Files"""
        this = _moduleconnectorwrapper.new_Files()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_Files
    __del__ = lambda self: None
Files_swigregister = _moduleconnectorwrapper.Files_swigregister
Files_swigregister(Files)

class PulseDopplerFloatData(_object):
    """


    Represents one half or one range bin of pulse-Doppler in float format.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        Frame counter generated from chip data rate.  

    * `matrix_counter` : `uint32_t`  
        Incremental matrix counter.  

    * `range_idx` : `uint32_t`  
        Range bin index of current Doppler vector.  

    * `range_bins` : `uint32_t`  
        Number of total range bins in the pulse-Doppler output matrix.  

    * `frequency_count` : `uint32_t`  
        Number of points in frequency axis.  

    * `pulsedoppler_instance` : `uint32_t`  
        Selected pulse-Doppler type from [0..N-1] where N is number of PDs.  

    * `fps` : `float`  
        Output chip framerate (frames per second)  

    * `fps_decimated` : `float`  
        Input FPS of this pulse-Doppler instance.  

    * `frequency_start` : `float`  
        Frequency of first value.  

    * `frequency_step` : `float`  
        Difference between each frequency bin.  

    * `range` : `float`  
        Absolute range of current frequency array.  

    * `data` : `std::vector< float >`  
        Power of pulse-Doppler bins.  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PulseDopplerFloatData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PulseDopplerFloatData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::PulseDopplerFloatData self) -> PulseDopplerFloatData
        __init__(XeThru::PulseDopplerFloatData self, uint32_t frame_counter, uint32_t matrix_counter, uint32_t range_idx, uint32_t range_bins, uint32_t frequency_count, uint32_t pulsedoppler_instance, float fps, float fps_decimated, float frequency_start, float frequency_step, float range, float const * data) -> PulseDopplerFloatData



        """
        this = _moduleconnectorwrapper.new_PulseDopplerFloatData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_data(self):
        """
        get_data(PulseDopplerFloatData self) -> FloatVector



        Returns a reference to the data.  

        """
        return _moduleconnectorwrapper.PulseDopplerFloatData_get_data(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.PulseDopplerFloatData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.PulseDopplerFloatData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_frame_counter_get, _moduleconnectorwrapper.PulseDopplerFloatData_frame_counter_set)
    __swig_setmethods__["matrix_counter"] = _moduleconnectorwrapper.PulseDopplerFloatData_matrix_counter_set
    __swig_getmethods__["matrix_counter"] = _moduleconnectorwrapper.PulseDopplerFloatData_matrix_counter_get
    if _newclass:
        matrix_counter = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_matrix_counter_get, _moduleconnectorwrapper.PulseDopplerFloatData_matrix_counter_set)
    __swig_setmethods__["range_idx"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_idx_set
    __swig_getmethods__["range_idx"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_idx_get
    if _newclass:
        range_idx = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_range_idx_get, _moduleconnectorwrapper.PulseDopplerFloatData_range_idx_set)
    __swig_setmethods__["range_bins"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_bins_set
    __swig_getmethods__["range_bins"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_bins_get
    if _newclass:
        range_bins = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_range_bins_get, _moduleconnectorwrapper.PulseDopplerFloatData_range_bins_set)
    __swig_setmethods__["frequency_count"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_count_set
    __swig_getmethods__["frequency_count"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_count_get
    if _newclass:
        frequency_count = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_frequency_count_get, _moduleconnectorwrapper.PulseDopplerFloatData_frequency_count_set)
    __swig_setmethods__["pulsedoppler_instance"] = _moduleconnectorwrapper.PulseDopplerFloatData_pulsedoppler_instance_set
    __swig_getmethods__["pulsedoppler_instance"] = _moduleconnectorwrapper.PulseDopplerFloatData_pulsedoppler_instance_get
    if _newclass:
        pulsedoppler_instance = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_pulsedoppler_instance_get, _moduleconnectorwrapper.PulseDopplerFloatData_pulsedoppler_instance_set)
    __swig_setmethods__["fps"] = _moduleconnectorwrapper.PulseDopplerFloatData_fps_set
    __swig_getmethods__["fps"] = _moduleconnectorwrapper.PulseDopplerFloatData_fps_get
    if _newclass:
        fps = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_fps_get, _moduleconnectorwrapper.PulseDopplerFloatData_fps_set)
    __swig_setmethods__["fps_decimated"] = _moduleconnectorwrapper.PulseDopplerFloatData_fps_decimated_set
    __swig_getmethods__["fps_decimated"] = _moduleconnectorwrapper.PulseDopplerFloatData_fps_decimated_get
    if _newclass:
        fps_decimated = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_fps_decimated_get, _moduleconnectorwrapper.PulseDopplerFloatData_fps_decimated_set)
    __swig_setmethods__["frequency_start"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_start_set
    __swig_getmethods__["frequency_start"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_start_get
    if _newclass:
        frequency_start = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_frequency_start_get, _moduleconnectorwrapper.PulseDopplerFloatData_frequency_start_set)
    __swig_setmethods__["frequency_step"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_step_set
    __swig_getmethods__["frequency_step"] = _moduleconnectorwrapper.PulseDopplerFloatData_frequency_step_get
    if _newclass:
        frequency_step = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_frequency_step_get, _moduleconnectorwrapper.PulseDopplerFloatData_frequency_step_set)
    __swig_setmethods__["range"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_set
    __swig_getmethods__["range"] = _moduleconnectorwrapper.PulseDopplerFloatData_range_get
    if _newclass:
        range = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_range_get, _moduleconnectorwrapper.PulseDopplerFloatData_range_set)
    __swig_setmethods__["data"] = _moduleconnectorwrapper.PulseDopplerFloatData_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.PulseDopplerFloatData_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.PulseDopplerFloatData_data_get, _moduleconnectorwrapper.PulseDopplerFloatData_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_PulseDopplerFloatData
    __del__ = lambda self: None
PulseDopplerFloatData_swigregister = _moduleconnectorwrapper.PulseDopplerFloatData_swigregister
PulseDopplerFloatData_swigregister(PulseDopplerFloatData)

class PulseDopplerByteData(_object):
    """


    Represents one half or one range bin of pulse-Doppler in byte format.  

    Python warning: Accessing vectors directly can cause memory corruption if the
    parent object goes out of scope and is garbage collected. Use accessor methods
    for a workaround.  

    Attributes
    ----------
    * `frame_counter` : `uint32_t`  
        Frame counter generated from chip data rate.  

    * `matrix_counter` : `uint32_t`  
        Incremental matrix counter.  

    * `range_idx` : `uint32_t`  
        Range bin index of current Doppler vector.  

    * `range_bins` : `uint32_t`  
        Number of total range bins in the pulse-Doppler output matrix.  

    * `frequency_count` : `uint32_t`  
        Number of points in frequency axis.  

    * `pulsedoppler_instance` : `uint32_t`  
        Selected pulse-Doppler type from [0..N-1] where N is number of PDs.  

    * `byte_step_start` : `float`  
        Start of dB-compression range.  

    * `byte_step_size` : `float`  
        Size of one step in dB.  

    * `fps` : `float`  
        Output chip framerate (frames per second)  

    * `fps_decimated` : `float`  
        Input FPS of this pulse-Doppler instance.  

    * `frequency_start` : `float`  
        Frequency of first value.  

    * `frequency_step` : `float`  
        Difference between each frequency bin.  

    * `range` : `float`  
        Absolute range of current frequency array.  

    * `data` : `Bytes`  
        Power of pulse-Doppler bins.  

        \[ float = 10^{(byte * byte\_step\_size + byte\_step\_start)/10} \]  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PulseDopplerByteData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PulseDopplerByteData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::PulseDopplerByteData self) -> PulseDopplerByteData
        __init__(XeThru::PulseDopplerByteData self, uint32_t frame_counter, uint32_t matrix_counter, uint32_t range_idx, uint32_t range_bins, uint32_t frequency_count, uint32_t pulsedoppler_instance, float byte_step_start, float byte_step_size, float fps, float fps_decimated, float frequency_start, float frequency_step, float range, unsigned char const * data) -> PulseDopplerByteData



        """
        this = _moduleconnectorwrapper.new_PulseDopplerByteData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_data(self):
        """
        get_data(PulseDopplerByteData self) -> ucVector



        Returns a reference to the data.  

        """
        return _moduleconnectorwrapper.PulseDopplerByteData_get_data(self)

    __swig_setmethods__["frame_counter"] = _moduleconnectorwrapper.PulseDopplerByteData_frame_counter_set
    __swig_getmethods__["frame_counter"] = _moduleconnectorwrapper.PulseDopplerByteData_frame_counter_get
    if _newclass:
        frame_counter = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_frame_counter_get, _moduleconnectorwrapper.PulseDopplerByteData_frame_counter_set)
    __swig_setmethods__["matrix_counter"] = _moduleconnectorwrapper.PulseDopplerByteData_matrix_counter_set
    __swig_getmethods__["matrix_counter"] = _moduleconnectorwrapper.PulseDopplerByteData_matrix_counter_get
    if _newclass:
        matrix_counter = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_matrix_counter_get, _moduleconnectorwrapper.PulseDopplerByteData_matrix_counter_set)
    __swig_setmethods__["range_idx"] = _moduleconnectorwrapper.PulseDopplerByteData_range_idx_set
    __swig_getmethods__["range_idx"] = _moduleconnectorwrapper.PulseDopplerByteData_range_idx_get
    if _newclass:
        range_idx = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_range_idx_get, _moduleconnectorwrapper.PulseDopplerByteData_range_idx_set)
    __swig_setmethods__["range_bins"] = _moduleconnectorwrapper.PulseDopplerByteData_range_bins_set
    __swig_getmethods__["range_bins"] = _moduleconnectorwrapper.PulseDopplerByteData_range_bins_get
    if _newclass:
        range_bins = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_range_bins_get, _moduleconnectorwrapper.PulseDopplerByteData_range_bins_set)
    __swig_setmethods__["frequency_count"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_count_set
    __swig_getmethods__["frequency_count"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_count_get
    if _newclass:
        frequency_count = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_frequency_count_get, _moduleconnectorwrapper.PulseDopplerByteData_frequency_count_set)
    __swig_setmethods__["pulsedoppler_instance"] = _moduleconnectorwrapper.PulseDopplerByteData_pulsedoppler_instance_set
    __swig_getmethods__["pulsedoppler_instance"] = _moduleconnectorwrapper.PulseDopplerByteData_pulsedoppler_instance_get
    if _newclass:
        pulsedoppler_instance = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_pulsedoppler_instance_get, _moduleconnectorwrapper.PulseDopplerByteData_pulsedoppler_instance_set)
    __swig_setmethods__["byte_step_start"] = _moduleconnectorwrapper.PulseDopplerByteData_byte_step_start_set
    __swig_getmethods__["byte_step_start"] = _moduleconnectorwrapper.PulseDopplerByteData_byte_step_start_get
    if _newclass:
        byte_step_start = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_byte_step_start_get, _moduleconnectorwrapper.PulseDopplerByteData_byte_step_start_set)
    __swig_setmethods__["byte_step_size"] = _moduleconnectorwrapper.PulseDopplerByteData_byte_step_size_set
    __swig_getmethods__["byte_step_size"] = _moduleconnectorwrapper.PulseDopplerByteData_byte_step_size_get
    if _newclass:
        byte_step_size = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_byte_step_size_get, _moduleconnectorwrapper.PulseDopplerByteData_byte_step_size_set)
    __swig_setmethods__["fps"] = _moduleconnectorwrapper.PulseDopplerByteData_fps_set
    __swig_getmethods__["fps"] = _moduleconnectorwrapper.PulseDopplerByteData_fps_get
    if _newclass:
        fps = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_fps_get, _moduleconnectorwrapper.PulseDopplerByteData_fps_set)
    __swig_setmethods__["fps_decimated"] = _moduleconnectorwrapper.PulseDopplerByteData_fps_decimated_set
    __swig_getmethods__["fps_decimated"] = _moduleconnectorwrapper.PulseDopplerByteData_fps_decimated_get
    if _newclass:
        fps_decimated = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_fps_decimated_get, _moduleconnectorwrapper.PulseDopplerByteData_fps_decimated_set)
    __swig_setmethods__["frequency_start"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_start_set
    __swig_getmethods__["frequency_start"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_start_get
    if _newclass:
        frequency_start = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_frequency_start_get, _moduleconnectorwrapper.PulseDopplerByteData_frequency_start_set)
    __swig_setmethods__["frequency_step"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_step_set
    __swig_getmethods__["frequency_step"] = _moduleconnectorwrapper.PulseDopplerByteData_frequency_step_get
    if _newclass:
        frequency_step = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_frequency_step_get, _moduleconnectorwrapper.PulseDopplerByteData_frequency_step_set)
    __swig_setmethods__["range"] = _moduleconnectorwrapper.PulseDopplerByteData_range_set
    __swig_getmethods__["range"] = _moduleconnectorwrapper.PulseDopplerByteData_range_get
    if _newclass:
        range = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_range_get, _moduleconnectorwrapper.PulseDopplerByteData_range_set)
    __swig_setmethods__["data"] = _moduleconnectorwrapper.PulseDopplerByteData_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.PulseDopplerByteData_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.PulseDopplerByteData_data_get, _moduleconnectorwrapper.PulseDopplerByteData_data_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_PulseDopplerByteData
    __del__ = lambda self: None
PulseDopplerByteData_swigregister = _moduleconnectorwrapper.PulseDopplerByteData_swigregister
PulseDopplerByteData_swigregister(PulseDopplerByteData)

class DataRecord(_object):
    """


    Encapsulates data and information about one data record on disk.  

    One record is a collection of fields as specified by the Xethru File Formats doc
    for the given data type.  

    note: Data and information is valid only if is_valid is true.  

    Parameters
    ----------
    * `data` :  
        contains bytes as specified by Xethru File Formats doc if is_user_header is
        false. Otherwise contains custom user header as supplied by the user (see
        *RecordingOptions::set_user_header*).  
    * `data_type` :  
        Specifies the data type for the record (see DataType).  
    * `epoch` :  
        Specifies the date/time the record was written to disk as number of
        milliseconds since 1970.01.01.  
    * `is_valid` :  
        Specifies whether the fields in this struct is valid.  
    * `is_user_header` :  
        Specifies whether the data contains custom user header.  

    Attributes
    ----------
    * `data` : `Bytes`  

    * `data_type` : `uint32_t`  

    * `epoch` : `int64_t`  

    * `is_valid` : `bool`  

    * `is_user_header` : `bool`  

    * `meta_version` : `uint32_t`  

    C++ includes: Data.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataRecord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataRecord, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(XeThru::DataRecord self) -> DataRecord



        """
        this = _moduleconnectorwrapper.new_DataRecord()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_data(self):
        """
        get_data(DataRecord self) -> ucVector



        Const reference accessor to data.  

        In particular useful from Python to avoid unecessary overhead when read-only
        access to data is needed.  

        Returns
        -------
        a const reference to the data.  

        """
        return _moduleconnectorwrapper.DataRecord_get_data(self)


    def is_csv_header(self):
        """
        is_csv_header(DataRecord self) -> bool



        """
        return _moduleconnectorwrapper.DataRecord_is_csv_header(self)


    def to_binary_packet(self, ok=None):
        """
        to_binary_packet(DataRecord self, bool * ok=None) -> ucVector
        to_binary_packet(DataRecord self) -> ucVector



        """
        return _moduleconnectorwrapper.DataRecord_to_binary_packet(self, ok)


    def to_sleep_data(self, ok=None):
        """
        to_sleep_data(DataRecord self, bool * ok=None) -> SleepData
        to_sleep_data(DataRecord self) -> SleepData



        """
        return _moduleconnectorwrapper.DataRecord_to_sleep_data(self, ok)


    def to_vitalsigns_data(self, ok=None):
        """
        to_vitalsigns_data(DataRecord self, bool * ok=None) -> VitalSignsData
        to_vitalsigns_data(DataRecord self) -> VitalSignsData



        """
        return _moduleconnectorwrapper.DataRecord_to_vitalsigns_data(self, ok)

    __swig_setmethods__["data"] = _moduleconnectorwrapper.DataRecord_data_set
    __swig_getmethods__["data"] = _moduleconnectorwrapper.DataRecord_data_get
    if _newclass:
        data = _swig_property(_moduleconnectorwrapper.DataRecord_data_get, _moduleconnectorwrapper.DataRecord_data_set)
    __swig_setmethods__["data_type"] = _moduleconnectorwrapper.DataRecord_data_type_set
    __swig_getmethods__["data_type"] = _moduleconnectorwrapper.DataRecord_data_type_get
    if _newclass:
        data_type = _swig_property(_moduleconnectorwrapper.DataRecord_data_type_get, _moduleconnectorwrapper.DataRecord_data_type_set)
    __swig_setmethods__["epoch"] = _moduleconnectorwrapper.DataRecord_epoch_set
    __swig_getmethods__["epoch"] = _moduleconnectorwrapper.DataRecord_epoch_get
    if _newclass:
        epoch = _swig_property(_moduleconnectorwrapper.DataRecord_epoch_get, _moduleconnectorwrapper.DataRecord_epoch_set)
    __swig_setmethods__["is_valid"] = _moduleconnectorwrapper.DataRecord_is_valid_set
    __swig_getmethods__["is_valid"] = _moduleconnectorwrapper.DataRecord_is_valid_get
    if _newclass:
        is_valid = _swig_property(_moduleconnectorwrapper.DataRecord_is_valid_get, _moduleconnectorwrapper.DataRecord_is_valid_set)
    __swig_setmethods__["is_user_header"] = _moduleconnectorwrapper.DataRecord_is_user_header_set
    __swig_getmethods__["is_user_header"] = _moduleconnectorwrapper.DataRecord_is_user_header_get
    if _newclass:
        is_user_header = _swig_property(_moduleconnectorwrapper.DataRecord_is_user_header_get, _moduleconnectorwrapper.DataRecord_is_user_header_set)
    __swig_setmethods__["meta_version"] = _moduleconnectorwrapper.DataRecord_meta_version_set
    __swig_getmethods__["meta_version"] = _moduleconnectorwrapper.DataRecord_meta_version_get
    if _newclass:
        meta_version = _swig_property(_moduleconnectorwrapper.DataRecord_meta_version_get, _moduleconnectorwrapper.DataRecord_meta_version_set)
    __swig_destroy__ = _moduleconnectorwrapper.delete_DataRecord
    __del__ = lambda self: None
DataRecord_swigregister = _moduleconnectorwrapper.DataRecord_swigregister
DataRecord_swigregister(DataRecord)

class PreferredSplitSize(_object):
    """


    The PreferredSplitSize class allows specifying a split size.  

    The PreferredSplitSize class contains functions to define a preferred split size
    for files and directories specified in either duration (seconds) or as number of
    bytes. Specifying both is not supported; the last specified type will rule.  

    note: As the class name indicates, the size is only a *preferred* size. There is
        no guarantee that the actual size will match 100%.  

    See also: DataRecorder, RecordingOptions  

    C++ includes: PreferredSplitSize.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PreferredSplitSize, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PreferredSplitSize, name)
    __repr__ = _swig_repr
    DurationType = _moduleconnectorwrapper.PreferredSplitSize_DurationType
    ByteCountType = _moduleconnectorwrapper.PreferredSplitSize_ByteCountType
    FixedDailyHour = _moduleconnectorwrapper.PreferredSplitSize_FixedDailyHour
    InvalidType = _moduleconnectorwrapper.PreferredSplitSize_InvalidType

    def __init__(self, *args):
        """
        __init__(XeThru::PreferredSplitSize self) -> PreferredSplitSize
        __init__(XeThru::PreferredSplitSize self, PreferredSplitSize other) -> PreferredSplitSize
        __init__(XeThru::PreferredSplitSize self, PreferredSplitSize other) -> PreferredSplitSize



        Move constructor.  

        """
        this = _moduleconnectorwrapper.new_PreferredSplitSize(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PreferredSplitSize
    __del__ = lambda self: None

    def get_duration(self):
        """
        get_duration(PreferredSplitSize self) -> int



        Returns
        -------
        the preferred split size in seconds if set, otherwise -1.  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_get_duration(self)


    def set_duration(self, seconds):
        """
        set_duration(PreferredSplitSize self, int seconds)



        Sets the preferred split size specified in seconds.  

        Parameters
        ----------
        * `seconds` :  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_set_duration(self, seconds)


    def get_byte_count(self):
        """
        get_byte_count(PreferredSplitSize self) -> int64_t



        Returns
        -------
        the preferred file size as number of bytes if set, otherwise -1.  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_get_byte_count(self)


    def set_byte_count(self, count):
        """
        set_byte_count(PreferredSplitSize self, int64_t count)



        Sets the preferred split size specified as number of bytes.  

        Parameters
        ----------
        * `count` :  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_set_byte_count(self, count)


    def get_fixed_daily_hour(self):
        """
        get_fixed_daily_hour(PreferredSplitSize self) -> int



        Returns
        -------
        the fixed daily hour if set (0-23), otherwise returns -1.  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_get_fixed_daily_hour(self)


    def set_fixed_daily_hour(self, hour):
        """
        set_fixed_daily_hour(PreferredSplitSize self, int hour)



        Sets the preferred split size to a fixed daily hour.  

        Range is 24 hour clock (0-23). For example, if splitting every day at 2pm is
        desired, the parameter to this function would be 14. By default, no fixed daily
        hour is set.  

        Parameters
        ----------
        * `hour` :  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_set_fixed_daily_hour(self, hour)


    def get_type(self):
        """
        get_type(PreferredSplitSize self) -> XeThru::PreferredSplitSize::SizeType



        The value reflects the last specified type, e.g.  

        if calling set_duration(15 * 60) this function returns DurationType.  

        Returns
        -------
        the type of the preferred size.  

        See also: SizeType  

        """
        return _moduleconnectorwrapper.PreferredSplitSize_get_type(self)

PreferredSplitSize_swigregister = _moduleconnectorwrapper.PreferredSplitSize_swigregister
PreferredSplitSize_swigregister(PreferredSplitSize)

class RecordingOptions(_object):
    """


    The RecordingOptions class allows specifying options for recording.  

    The RecordingOptions class contains more advance options for recording. It can
    be used to specify things like splitting of files and directories.  

    See also: DataRecorder  

    C++ includes: RecordingOptions.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RecordingOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RecordingOptions, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::RecordingOptions self) -> RecordingOptions
        __init__(XeThru::RecordingOptions self, RecordingOptions other) -> RecordingOptions
        __init__(XeThru::RecordingOptions self, RecordingOptions other) -> RecordingOptions



        Move constructor.  

        """
        this = _moduleconnectorwrapper.new_RecordingOptions(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_RecordingOptions
    __del__ = lambda self: None

    def set_session_id(self, id):
        """
        set_session_id(RecordingOptions self, std::string const & id)



        Sets the session id as specified, overriding the default constructed value which
        is an universally unique identifier (UUID).  

        Parameters
        ----------
        * `id` :  
            Specifies the new id  

        See also: get_session_id  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_session_id(self, id)


    def get_session_id(self):
        """
        get_session_id(RecordingOptions self) -> std::string



        By default, this function returns an universally unique identifier (UUID) if no
        custom id is set.  

        Returns
        -------
        the session id  

        See also: set_session_id  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_session_id(self)


    def set_file_split_size(self, size):
        """
        set_file_split_size(RecordingOptions self, PreferredSplitSize size)



        Sets the preferred file split size as specified.  

        Parameters
        ----------
        * `size` :  
            Specifies the preferred split size  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_file_split_size(self, size)


    def get_file_split_size(self):
        """
        get_file_split_size(RecordingOptions self) -> PreferredSplitSize



        By default, this function returns a default constructed value (no file split
        size) if no custom size is set.  

        Returns
        -------
        the preferred file split size  

        See also: PreferredSplitSize  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_file_split_size(self)


    def set_directory_split_size(self, size):
        """
        set_directory_split_size(RecordingOptions self, PreferredSplitSize size)



        Sets the preferred directory split size as specified.  

        Parameters
        ----------
        * `size` :  
            Specifies the preferred split size  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_directory_split_size(self, size)


    def get_directory_split_size(self):
        """
        get_directory_split_size(RecordingOptions self) -> PreferredSplitSize



        By default, this function returns a default constructed value (no directory
        split size) if no custom size is set.  

        Returns
        -------
        the preferred directory split size  

        See also: PreferredSplitSize  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_directory_split_size(self)


    def set_data_rate_limit(self, limit):
        """
        set_data_rate_limit(RecordingOptions self, int limit)



        Sets the data rate (ms) the recorder will read data from the module.  

        A value of 1000 ms means data is read every second. Data in between is
        discarded. By default, this parameter is -1 (no data rate limit).  

        Parameters
        ----------
        * `limit` :  
            Specifies the data rate limit  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_data_rate_limit(self, limit)


    def get_data_rate_limit(self):
        """
        get_data_rate_limit(RecordingOptions self) -> int



        Returns
        -------
        the data rate (ms) the recorder will read data from the module if set, otherwise
        returns -1 (no data rate limit). A value of 1000 ms means data is read every
        second. Data in between is discarded.  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_data_rate_limit(self)


    def set_user_header(self, header):
        """
        set_user_header(RecordingOptions self, ucVector header)



        Sets a custom header applied to the beginning of the recorded file.  

        By default, this parameter is Bytes() (no custom header).  

        Parameters
        ----------
        * `header` :  
            Specifies the header  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_user_header(self, header)


    def get_user_header(self):
        """
        get_user_header(RecordingOptions self) -> ucVector



        Returns
        -------
        the custom user header. By default, this parameter is Bytes() (no custom
        header).  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_user_header(self)


    def set_flush_on_write(self, do_flush):
        """
        set_flush_on_write(RecordingOptions self, bool do_flush)



        Specify whether to flush on every write.  

        Note that this will impact the performance and should only be used for debugging
        purposes. The default is false.  

        Parameters
        ----------
        * `do_flush` :  
            If true, recording files are flushed after every write.  

        """
        return _moduleconnectorwrapper.RecordingOptions_set_flush_on_write(self, do_flush)


    def get_flush_on_write(self):
        """
        get_flush_on_write(RecordingOptions self) -> bool



        Returns
        -------
        Whether flushing for every write to file is enabled.  

        """
        return _moduleconnectorwrapper.RecordingOptions_get_flush_on_write(self)

RecordingOptions_swigregister = _moduleconnectorwrapper.RecordingOptions_swigregister
RecordingOptions_swigregister(RecordingOptions)

class PythonModuleConnector(_object):
    """


    This class is responsible for establishing contact with the XeThru module.  

    Use one of the get_XXX methods to access the module-specific functionality.  

    C++ includes: PythonModuleConnector.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonModuleConnector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonModuleConnector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::PythonModuleConnector self, int log_level) -> PythonModuleConnector
        __init__(XeThru::PythonModuleConnector self, std::string const & device_name, int log_level) -> PythonModuleConnector
        __init__(XeThru::PythonModuleConnector self, PyDataPlayer player, int log_level) -> PythonModuleConnector
        __init__(XeThru::PythonModuleConnector self, in_addr_t ip, in_port_t port, int log_level) -> PythonModuleConnector



        Constructor.  

        The constructor will open the address and port given using TCP/IP.  

        XXX: The open/close mechanisms will give undefined behaviour if started this
        way.  

        Parameters
        ----------
        * `ip` :  
            The IP to connect to  
        * `port` :  
            The TCP port to connect to  
        * `log_level` :  
            The log level to use during operation  

        """
        this = _moduleconnectorwrapper.new_PythonModuleConnector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PythonModuleConnector
    __del__ = lambda self: None

    def git_sha(self):
        """
        git_sha(PythonModuleConnector self) -> std::string



        Provides the git sha of the ModuleConnector repository.  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_git_sha(self)


    def open(self, device):
        """
        open(PythonModuleConnector self, std::string const device)



        Opens a new connection to a module via some serial device.  

        Parameters
        ----------
        * `device` :  
            Name of the device file for example /dev/ttyACM0 or COM4  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_open(self, device)


    def close(self):
        """
        close(PythonModuleConnector self)



        Close an open connection to the module.  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_close(self)


    def set_log_level(self, new_log_level):
        """
        set_log_level(PythonModuleConnector self, int new_log_level)



        Set log level during ModuleConnector operation.  

        Parameters
        ----------
        * `new_log_level` :  
            The new log level to use  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_set_log_level(self, new_log_level)


    def set_default_timeout(self, new_default_timeout):
        """
        set_default_timeout(PythonModuleConnector self, unsigned int new_default_timeout)



        Set default timeout for commands sent to the module.  

        Parameters
        ----------
        * `new_default_timeout` :  
            New timeout to use  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_set_default_timeout(self, new_default_timeout)


    def get_data_recorder(self):
        """
        get_data_recorder(PythonModuleConnector self) -> PyDataRecorder



        Returns a reference to the PyDataRecorder application interface.  

        Returns
        -------
        The reference to the PyDataRecorder interface  

        See also: pymoduleconnector.moduleconnectorwrapper.PyDataRecorder  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_data_recorder(self)


    def get_transport(self):
        """
        get_transport(PythonModuleConnector self) -> Transport



        Not supported.  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_transport(self)


    def get_x2m200(self):
        """
        get_x2m200(PythonModuleConnector self) -> PyX2M200



        Returns a reference to the X2M200 module application interface.  

        Returns
        -------
        The reference to the X2M200 interface.  

        See also: pymoduleconnector.moduleconnectorwrapper.PyX2M200  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_x2m200(self)


    def get_x2(self):
        """
        get_x2(PythonModuleConnector self) -> X2



        Not supported.  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_x2(self)


    def get_xep(self):
        """
        get_xep(PythonModuleConnector self) -> PyXEP



        Returns a reference to the low level XEP interface.  

        Returns
        -------
        The reference to the XEP interface.  

        See also: pymoduleconnector.moduleconnectorwrapper.PyXEP  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_xep(self)


    def get_x4m300(self):
        """
        get_x4m300(PythonModuleConnector self) -> PyX4M300



        Returns a reference to the X4M300 module application interface.  

        Returns
        -------
        The reference to the X4M300 interface.  

        See also: pymoduleconnector.moduleconnectorwrapper.PyX4M300  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_x4m300(self)


    def get_x4m200(self):
        """
        get_x4m200(PythonModuleConnector self) -> PyX4M200



        Returns a reference to the X4M200 module application interface.  

        Returns
        -------
        The reference to the X4M200 interface.  

        See also: pymoduleconnector.moduleconnectorwrapper.PyX4M200  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_x4m200(self)


    def get_x4m210(self):
        """
        get_x4m210(PythonModuleConnector self) -> PyX4M210



        Returns a reference to the X4M210 module application interface.  

        Returns
        -------
        The reference to the X4M210 interface.  

        See also: pymoduleconnector.moduleconnectorwrapper.PyX4M210  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_x4m210(self)


    def get_not_supported(self):
        """
        get_not_supported(PythonModuleConnector self) -> NotSupported



        Not supported.  

        """
        return _moduleconnectorwrapper.PythonModuleConnector_get_not_supported(self)

PythonModuleConnector_swigregister = _moduleconnectorwrapper.PythonModuleConnector_swigregister
PythonModuleConnector_swigregister(PythonModuleConnector)

class Bootloader(_object):
    """Proxy of C++ XeThru::Bootloader class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Bootloader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Bootloader, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XeThru::Bootloader self, std::string const & device_name, bool log_to_stdout, bool log_to_file, unsigned int log_level) -> Bootloader
        __init__(XeThru::Bootloader self, std::string const & device_name, unsigned int log_level) -> Bootloader
        __init__(XeThru::Bootloader self, std::string const & device_name, unsigned int log_level, XeThru::AbstractLoggerIo * logger_io) -> Bootloader
        __init__(XeThru::Bootloader self, std::string const & device_name, Logger * logger) -> Bootloader
        __init__(XeThru::Bootloader self, in_addr_t ip, in_port_t port, int log_level, XeThru::AbstractLoggerIo * logger_io) -> Bootloader
        __init__(XeThru::Bootloader self, in_addr_t ip, in_port_t port) -> Bootloader
        __init__(XeThru::Bootloader self, in_addr_t ip, in_port_t port, int log_level) -> Bootloader
        """
        this = _moduleconnectorwrapper.new_Bootloader(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_Bootloader
    __del__ = lambda self: None

    def write_page(self, page_address, page_data):
        """write_page(Bootloader self, unsigned int page_address, ucVector page_data) -> int"""
        return _moduleconnectorwrapper.Bootloader_write_page(self, page_address, page_data)


    def start_application(self, *args):
        """
        start_application(Bootloader self) -> int
        start_application(Bootloader self, unsigned int timeout) -> int
        """
        return _moduleconnectorwrapper.Bootloader_start_application(self, *args)


    def get_bootloader_info(self):
        """get_bootloader_info(Bootloader self) -> std::string"""
        return _moduleconnectorwrapper.Bootloader_get_bootloader_info(self)

Bootloader_swigregister = _moduleconnectorwrapper.Bootloader_swigregister
Bootloader_swigregister(Bootloader)

class NotSupported(_object):
    """Proxy of C++ XeThru::NotSupported class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotSupported, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NotSupported, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface):
        """__init__(XeThru::NotSupported self, LockedRadarInterfacePtr & radar_interface) -> NotSupported"""
        this = _moduleconnectorwrapper.new_NotSupported(radar_interface)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_NotSupported
    __del__ = lambda self: None

    def get_x4_io_pin_value(self, pin):
        """get_x4_io_pin_value(NotSupported self, unsigned char pin) -> Byte"""
        return _moduleconnectorwrapper.NotSupported_get_x4_io_pin_value(self, pin)


    def set_x4_io_pin_value(self, pin, value):
        """set_x4_io_pin_value(NotSupported self, unsigned char pin, unsigned char value) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_io_pin_value(self, pin, value)


    def set_x4_io_pin_mode(self, pin, mode):
        """set_x4_io_pin_mode(NotSupported self, unsigned char const pin, unsigned char const mode) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_io_pin_mode(self, pin, mode)


    def set_x4_io_pin_dir(self, pin, direction):
        """set_x4_io_pin_dir(NotSupported self, unsigned char const pin, unsigned char const direction) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_io_pin_dir(self, pin, direction)


    def set_x4_io_pin_enable(self, pin):
        """set_x4_io_pin_enable(NotSupported self, unsigned char const pin) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_io_pin_enable(self, pin)


    def set_x4_io_pin_disable(self, pin):
        """set_x4_io_pin_disable(NotSupported self, unsigned char const pin) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_io_pin_disable(self, pin)


    def read_x4_spi(self, address):
        """read_x4_spi(NotSupported self, unsigned char const address) -> unsigned char"""
        return _moduleconnectorwrapper.NotSupported_read_x4_spi(self, address)


    def write_x4_spi(self, address, value):
        """write_x4_spi(NotSupported self, unsigned char address, unsigned char const value) -> int"""
        return _moduleconnectorwrapper.NotSupported_write_x4_spi(self, address, value)


    def set_x4_fps(self, fps):
        """set_x4_fps(NotSupported self, uint32_t const fps) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_x4_fps(self, fps)


    def subscribe_to_x4_desim(self, name):
        """subscribe_to_x4_desim(NotSupported self, std::string const & name) -> int"""
        return _moduleconnectorwrapper.NotSupported_subscribe_to_x4_desim(self, name)


    def get_x4_decim_frame(self, name, frame_counter, frame_data, max_length):
        """get_x4_decim_frame(NotSupported self, std::string const & name, uint32_t * frame_counter, double * frame_data, unsigned int max_length) -> int"""
        return _moduleconnectorwrapper.NotSupported_get_x4_decim_frame(self, name, frame_counter, frame_data, max_length)


    def subscribe_to_data_float(self, *args):
        """
        subscribe_to_data_float(NotSupported self, std::string const & name) -> int
        subscribe_to_data_float(NotSupported self, std::string const & name, std::function< bool (Bytes) > callback) -> int
        """
        return _moduleconnectorwrapper.NotSupported_subscribe_to_data_float(self, *args)


    def peek_message_data_float(self, name):
        """peek_message_data_float(NotSupported self, std::string const & name) -> int"""
        return _moduleconnectorwrapper.NotSupported_peek_message_data_float(self, name)


    def read_message_data_float(self, data_float):
        """read_message_data_float(NotSupported self, DataFloat data_float) -> int"""
        return _moduleconnectorwrapper.NotSupported_read_message_data_float(self, data_float)


    def peek_message_pulsedoppler_float(self):
        """peek_message_pulsedoppler_float(NotSupported self) -> int"""
        return _moduleconnectorwrapper.NotSupported_peek_message_pulsedoppler_float(self)


    def read_message_pulsedoppler_float(self):
        """read_message_pulsedoppler_float(NotSupported self) -> ucVector"""
        return _moduleconnectorwrapper.NotSupported_read_message_pulsedoppler_float(self)


    def peek_message_noisemap_float(self):
        """peek_message_noisemap_float(NotSupported self) -> int"""
        return _moduleconnectorwrapper.NotSupported_peek_message_noisemap_float(self)


    def read_message_noisemap_float(self):
        """read_message_noisemap_float(NotSupported self) -> ucVector"""
        return _moduleconnectorwrapper.NotSupported_read_message_noisemap_float(self)


    def peek_message_pulsedoppler_byte(self):
        """peek_message_pulsedoppler_byte(NotSupported self) -> int"""
        return _moduleconnectorwrapper.NotSupported_peek_message_pulsedoppler_byte(self)


    def read_message_pulsedoppler_byte(self):
        """read_message_pulsedoppler_byte(NotSupported self) -> ucVector"""
        return _moduleconnectorwrapper.NotSupported_read_message_pulsedoppler_byte(self)


    def peek_message_noisemap_byte(self):
        """peek_message_noisemap_byte(NotSupported self) -> int"""
        return _moduleconnectorwrapper.NotSupported_peek_message_noisemap_byte(self)


    def read_message_noisemap_byte(self):
        """read_message_noisemap_byte(NotSupported self) -> ucVector"""
        return _moduleconnectorwrapper.NotSupported_read_message_noisemap_byte(self)


    def get_application_user_zone(self, start, end):
        """get_application_user_zone(NotSupported self, float * start, float * end) -> int"""
        return _moduleconnectorwrapper.NotSupported_get_application_user_zone(self, start, end)


    def set_application_user_zone(self, start, end):
        """set_application_user_zone(NotSupported self, float start, float end) -> int"""
        return _moduleconnectorwrapper.NotSupported_set_application_user_zone(self, start, end)


    def get_number_of_packets(self, name):
        """get_number_of_packets(NotSupported self, std::string const & name) -> unsigned int"""
        return _moduleconnectorwrapper.NotSupported_get_number_of_packets(self, name)


    def get_packet(self, name):
        """get_packet(NotSupported self, std::string const & name) -> ucVector"""
        return _moduleconnectorwrapper.NotSupported_get_packet(self, name)


    def clear(self, name):
        """clear(NotSupported self, std::string const & name)"""
        return _moduleconnectorwrapper.NotSupported_clear(self, name)


    def set_parameter_file(self, filename, data):
        """set_parameter_file(NotSupported self, std::string const & filename, std::string const & data)"""
        return _moduleconnectorwrapper.NotSupported_set_parameter_file(self, filename, data)


    def get_parameter_file(self, filename):
        """get_parameter_file(NotSupported self, std::string const & filename) -> std::string"""
        return _moduleconnectorwrapper.NotSupported_get_parameter_file(self, filename)


    def load_profile(self, profile_id):
        """load_profile(NotSupported self, uint32_t const profile_id)"""
        return _moduleconnectorwrapper.NotSupported_load_profile(self, profile_id)


    def subscribe_to_trace(self, name):
        """subscribe_to_trace(NotSupported self, std::string const & name) -> int"""
        return _moduleconnectorwrapper.NotSupported_subscribe_to_trace(self, name)


    def get_trace(self, name):
        """get_trace(NotSupported self, std::string const & name) -> std::string"""
        return _moduleconnectorwrapper.NotSupported_get_trace(self, name)


    def subscribe_to_data_byte(self, *args):
        """
        subscribe_to_data_byte(NotSupported self, std::string const & name) -> int
        subscribe_to_data_byte(NotSupported self, std::string const & name, std::function< bool (Bytes) > callback) -> int
        """
        return _moduleconnectorwrapper.NotSupported_subscribe_to_data_byte(self, *args)

NotSupported_swigregister = _moduleconnectorwrapper.NotSupported_swigregister
NotSupported_swigregister(NotSupported)

class Transport(_object):
    """Proxy of C++ XeThru::Transport class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Transport, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Transport, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface):
        """__init__(XeThru::Transport self, LockedRadarInterfacePtr & radar_interface) -> Transport"""
        this = _moduleconnectorwrapper.new_Transport(radar_interface)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_Transport
    __del__ = lambda self: None

    def send_command(self, command):
        """send_command(Transport self, ucVector command) -> int"""
        return _moduleconnectorwrapper.Transport_send_command(self, command)


    def send_command_single(self, command, comparator):
        """send_command_single(Transport self, ucVector command, ucVector comparator) -> ucVector"""
        return _moduleconnectorwrapper.Transport_send_command_single(self, command, comparator)


    def send_command_multi(self, command, comparator):
        """send_command_multi(Transport self, ucVector command, vVector comparator) -> ucVector"""
        return _moduleconnectorwrapper.Transport_send_command_multi(self, command, comparator)


    def unsubscribe(self, name):
        """unsubscribe(Transport self, std::string const & name)"""
        return _moduleconnectorwrapper.Transport_unsubscribe(self, name)


    def get_packet(self, name):
        """get_packet(Transport self, std::string const & name) -> ucVector"""
        return _moduleconnectorwrapper.Transport_get_packet(self, name)


    def get_number_of_packets(self, name):
        """get_number_of_packets(Transport self, std::string const & name) -> unsigned int"""
        return _moduleconnectorwrapper.Transport_get_number_of_packets(self, name)


    def clear(self, name):
        """clear(Transport self, std::string const & name)"""
        return _moduleconnectorwrapper.Transport_clear(self, name)


    def subscribe(self, *args):
        """
        subscribe(Transport self, std::string const & name, ucVector comparator) -> int
        subscribe(Transport self, std::string const & name, ucVector comparator, std::function< bool (Bytes) > callback) -> int
        subscribe(Transport self, std::string const & name, ucVector cmp, PyObject * callback) -> int
        """
        return _moduleconnectorwrapper.Transport_subscribe(self, *args)

Transport_swigregister = _moduleconnectorwrapper.Transport_swigregister
Transport_swigregister(Transport)

class X2(_object):
    """Proxy of C++ XeThru::X2 class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, X2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, X2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _moduleconnectorwrapper.delete_X2
    __del__ = lambda self: None

    def set_debug_level(self, level):
        """set_debug_level(X2 self, unsigned char level)"""
        return _moduleconnectorwrapper.X2_set_debug_level(self, level)


    def ping(self):
        """ping(X2 self) -> unsigned int"""
        return _moduleconnectorwrapper.X2_ping(self)


    def get_system_info(self, info_code):
        """get_system_info(X2 self, unsigned char info_code) -> std::string"""
        return _moduleconnectorwrapper.X2_get_system_info(self, info_code)


    def set_X2_float(self, id, value):
        """set_X2_float(X2 self, uint32_t id, float value) -> int"""
        return _moduleconnectorwrapper.X2_set_X2_float(self, id, value)


    def get_x2_float(self, id):
        """get_x2_float(X2 self, uint32_t id) -> float"""
        return _moduleconnectorwrapper.X2_get_x2_float(self, id)


    def set_X2_int(self, id, value):
        """set_X2_int(X2 self, uint32_t id, uint32_t value) -> int"""
        return _moduleconnectorwrapper.X2_set_X2_int(self, id, value)


    def get_x2_int(self, id):
        """get_x2_int(X2 self, uint32_t id) -> uint32_t"""
        return _moduleconnectorwrapper.X2_get_x2_int(self, id)


    def set_X2_register(self, id, value):
        """set_X2_register(X2 self, uint32_t id, uint32_t value) -> int"""
        return _moduleconnectorwrapper.X2_set_X2_register(self, id, value)


    def get_x2_register(self, register_id):
        """get_x2_register(X2 self, uint32_t register_id) -> uint32_t"""
        return _moduleconnectorwrapper.X2_get_x2_register(self, register_id)


    def run_timing_measurement(self):
        """run_timing_measurement(X2 self) -> int"""
        return _moduleconnectorwrapper.X2_run_timing_measurement(self)


    def set_fps(self, fps):
        """set_fps(X2 self, unsigned int fps) -> int"""
        return _moduleconnectorwrapper.X2_set_fps(self, fps)


    def capture_single_normalized_frame(self):
        """capture_single_normalized_frame(X2 self) -> RawNormalizedData"""
        return _moduleconnectorwrapper.X2_capture_single_normalized_frame(self)


    def set_sensor_mode(self, mode):
        """set_sensor_mode(X2 self, unsigned char mode)"""
        return _moduleconnectorwrapper.X2_set_sensor_mode(self, mode)


    def set_sensor_mode_and_submode(self, mode, submode):
        """set_sensor_mode_and_submode(X2 self, unsigned char const mode, unsigned char const submode)"""
        return _moduleconnectorwrapper.X2_set_sensor_mode_and_submode(self, mode, submode)


    def subscribe_to_raw_normalized(self, *args):
        """
        subscribe_to_raw_normalized(X2 self, std::string const & name) -> int
        subscribe_to_raw_normalized(X2 self, std::string const & name, std::function< bool (Bytes) > callback) -> int
        """
        return _moduleconnectorwrapper.X2_subscribe_to_raw_normalized(self, *args)


    def get_raw_normalized_frame(self, name):
        """get_raw_normalized_frame(X2 self, std::string const & name) -> RawNormalizedData"""
        return _moduleconnectorwrapper.X2_get_raw_normalized_frame(self, name)


    def unsubscribe(self, name):
        """unsubscribe(X2 self, std::string const & name)"""
        return _moduleconnectorwrapper.X2_unsubscribe(self, name)


    def get_number_of_packets(self, name):
        """get_number_of_packets(X2 self, std::string const & name) -> unsigned int"""
        return _moduleconnectorwrapper.X2_get_number_of_packets(self, name)


    def clear(self, name):
        """clear(X2 self, std::string const & name)"""
        return _moduleconnectorwrapper.X2_clear(self, name)


    def system_run_test(self, test_code):
        """system_run_test(X2 self, unsigned char test_code) -> int"""
        return _moduleconnectorwrapper.X2_system_run_test(self, test_code)

X2_swigregister = _moduleconnectorwrapper.X2_swigregister
X2_swigregister(X2)

class PyX2M200(_object):
    """


    Interface to the Xethru X2M200 Application module.  

    C++ includes: PyX2M200.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyX2M200, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyX2M200, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface):
        """
        __init__(XeThru::PyX2M200 self, LockedRadarInterfacePtr & radar_interface) -> PyX2M200



        Constructor.  

        Initialized by PythonModuleConnector::get_x2m200  

        Parameters
        ----------
        * `radar_interface` :  
            a reference to the internal radar interface  

        """
        this = _moduleconnectorwrapper.new_PyX2M200(radar_interface)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyX2M200
    __del__ = lambda self: None

    def set_debug_level(self, level):
        """
        set_debug_level(PyX2M200 self, unsigned char level)



        Set debug level on the Xethru module.  

        Parameters
        ----------
        * `level` :  
            New debug level. Legal range [0-9].  

        """
        return _moduleconnectorwrapper.PyX2M200_set_debug_level(self, level)


    def set_log_level(self, level):
        """
        set_log_level(PyX2M200 self, unsigned int level)



        Set log level of ModuleConnector.  

        Parameters
        ----------
        * `level` :  
            New debug level. Legal range [0-9].  

        Returns
        -------
        status (0==OK)  

        """
        return _moduleconnectorwrapper.PyX2M200_set_log_level(self, level)


    def ping(self):
        """
        ping(PyX2M200 self) -> unsigned int



        Send a ping message to the module.  

        This command is typically used to verify connectivity to the module.  

        Returns
        -------
        The response.  

        """
        return _moduleconnectorwrapper.PyX2M200_ping(self)


    def get_item_number(self):
        """
        get_item_number(PyX2M200 self) -> std::string



        Get the Novelda PCBA Item Number, including revision.  

        Returns
        -------
        PCBA item number and revision.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_item_number(self)


    def get_order_code(self):
        """
        get_order_code(PyX2M200 self) -> std::string



        Get Novelda PCBA Order Code.  

        Returns
        -------
        PCBA order code.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_order_code(self)


    def get_firmware_id(self):
        """
        get_firmware_id(PyX2M200 self) -> std::string



        Get the installed Firmware ID.  

        Returns
        -------
        Firmware ID.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_firmware_id(self)


    def get_firmware_version(self):
        """
        get_firmware_version(PyX2M200 self) -> std::string



        Get the installed Firmware version.  

        Returns
        -------
        Firmware version.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_firmware_version(self)


    def get_serial_number(self):
        """
        get_serial_number(PyX2M200 self) -> std::string



        Get the module serial number.  

        The serial number is unique for each module.  

        Returns
        -------
        Unique module serial number.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_serial_number(self)


    def get_build_info(self):
        """
        get_build_info(PyX2M200 self) -> std::string



        Get information of the SW build installed on the device.  

        Returns
        -------
        Build info description.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_build_info(self)


    def get_app_id_list(self):
        """
        get_app_id_list(PyX2M200 self) -> std::string



        Get a list of supported profiles.  

        Returns
        -------
        A list of supported profiles as a string.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_app_id_list(self)


    def reset(self):
        """
        reset(PyX2M200 self)



        Reset the module.  

        This method sends a reset command to the Xethru module. The module will try to
        reset and come back up again.  

        During this call the ModuleConnector will try multiple times to reconnect with
        the rebooted module.  

        """
        return _moduleconnectorwrapper.PyX2M200_reset(self)


    def start_bootloader(self):
        """
        start_bootloader(PyX2M200 self)



        Start the bootloader for FW upgrades.  

        All the Xethru modules have a bootloader. This method instructs the Xethru
        module to reboot into bootloader mode.  

        """
        return _moduleconnectorwrapper.PyX2M200_start_bootloader(self)


    def set_sensor_mode_run(self):
        """
        set_sensor_mode_run(PyX2M200 self)



        Set the sensor in run mode.  

        In run mode the sensor will send a stream of data back to the host. The data in
        the data stream depends on the current configuration.  

        """
        return _moduleconnectorwrapper.PyX2M200_set_sensor_mode_run(self)


    def set_sensor_mode_idle(self):
        """
        set_sensor_mode_idle(PyX2M200 self)



        Set the sensor in idle mode.  

        The sensor will stop sending data. The sensor can be put back in run mode with
        the set_sensor_mode_run().  

        """
        return _moduleconnectorwrapper.PyX2M200_set_sensor_mode_idle(self)


    def load_sleep_profile(self):
        """
        load_sleep_profile(PyX2M200 self)



        Load the sleep profile.  

        A profile is a preset configuration that makes the module behave in a certain
        way. The module will not start sending data until a set_sensor_mode_run command
        is executed.  

        """
        return _moduleconnectorwrapper.PyX2M200_load_sleep_profile(self)


    def load_respiration_profile(self):
        """
        load_respiration_profile(PyX2M200 self)



        Load the respiration profile.  

        A profile is a preset configuration that makes the module behave in a certain
        way. The module will not start sending data until a set_sensor_mode_run command
        is executed.  

        """
        return _moduleconnectorwrapper.PyX2M200_load_respiration_profile(self)


    def enable_baseband_ap(self):
        """
        enable_baseband_ap(PyX2M200 self)



        Enable amplitude/phase baseband output.  

        For all supported profiles it is possible to turn on Amplitude Phase baseband
        output.  

        """
        return _moduleconnectorwrapper.PyX2M200_enable_baseband_ap(self)


    def disable_baseband_ap(self):
        """
        disable_baseband_ap(PyX2M200 self)



        Disables amplitude/phase baseband output.  

        """
        return _moduleconnectorwrapper.PyX2M200_disable_baseband_ap(self)


    def enable_baseband_iq(self):
        """
        enable_baseband_iq(PyX2M200 self)



        Enable I/Q baseband output.  

        For all supported profiles it is possible to turn on IQ baseband output.  

        """
        return _moduleconnectorwrapper.PyX2M200_enable_baseband_iq(self)


    def disable_baseband_iq(self):
        """
        disable_baseband_iq(PyX2M200 self)



        Disables I/Q baseband output.  

        """
        return _moduleconnectorwrapper.PyX2M200_disable_baseband_iq(self)


    def set_detection_zone(self, start, end):
        """
        set_detection_zone(PyX2M200 self, float start, float end)



        Set the desired detection zone.  

        The sensor will detect movements within this area.  

        Parameters
        ----------
        * `start` :  
            Start of detection zone in meters from the radar  
        * `end` :  
            End of detection zone in meters from the radar  

        """
        return _moduleconnectorwrapper.PyX2M200_set_detection_zone(self, start, end)


    def set_sensitivity(self, new_sensitivity):
        """
        set_sensitivity(PyX2M200 self, uint32_t new_sensitivity)



        Set module sensitivity.  

        Parameters
        ----------
        * `new_sensitivity` :  
            Sensitivity level from 0 (low) to 9 (high)  

        """
        return _moduleconnectorwrapper.PyX2M200_set_sensitivity(self, new_sensitivity)


    def set_led_control(self, mode, intensity):
        """
        set_led_control(PyX2M200 self, uint8_t mode, uint8_t intensity)



        Configures the module LED mode.  

        The setting survives a power cycle.  

        Parameters
        ----------
        * `mode` :  
            0: Off, 1: Simple, 2: Full (default)  
        * `intensity` :  
            intensity of the led  

        """
        return _moduleconnectorwrapper.PyX2M200_set_led_control(self, mode, intensity)


    def subscribe_to_resp_status(self, name):
        """
        subscribe_to_resp_status(PyX2M200 self, std::string const & name) -> int



        Adds a subscription for respiration data packets.  

        Creates a queue/buffer for incoming respiration packet stream. The queue must be
        given a name.  

        Parameters
        ----------
        * `name` :  
            Name of the buffer  

        """
        return _moduleconnectorwrapper.PyX2M200_subscribe_to_resp_status(self, name)


    def subscribe_to_sleep_status(self, name):
        """
        subscribe_to_sleep_status(PyX2M200 self, std::string const & name) -> int



        Adds a subscription for sleep status data packets.  

        Creates a queue/buffer for incoming sleep packet stream. The queue must be given
        a name.  

        Parameters
        ----------
        * `name` :  
            Name of the queue/buffer  

        """
        return _moduleconnectorwrapper.PyX2M200_subscribe_to_sleep_status(self, name)


    def subscribe_to_baseband_ap(self, name):
        """
        subscribe_to_baseband_ap(PyX2M200 self, std::string const & name) -> int



        Adds a subscription for amplitude phase baseband data packets.  

        Creates a queue/buffer for incoming amplitude phase baseband packet stream. The
        queue must be given a name.  

        Parameters
        ----------
        * `name` :  
            Name of the queue/buffer  

        """
        return _moduleconnectorwrapper.PyX2M200_subscribe_to_baseband_ap(self, name)


    def subscribe_to_baseband_iq(self, name):
        """
        subscribe_to_baseband_iq(PyX2M200 self, std::string const & name) -> int



        Adds a subscription for IQ baseband data packets.  

        Creates a queue/buffer for incoming IQ baseband packet stream. The queue must be
        given a name.  

        Parameters
        ----------
        * `name` :  
            Name of the buffer/queue  

        """
        return _moduleconnectorwrapper.PyX2M200_subscribe_to_baseband_iq(self, name)


    def unsubscribe(self, name):
        """
        unsubscribe(PyX2M200 self, std::string const & name)



        Turns off a named subscription.  

        Parameters
        ----------
        * `name` :  
            Name of the subscription to disable  

        """
        return _moduleconnectorwrapper.PyX2M200_unsubscribe(self, name)


    def disable_resp_output(self):
        """
        disable_resp_output(PyX2M200 self)



        Turn off respiration status output from the Xethru X2M200 module.  

        """
        return _moduleconnectorwrapper.PyX2M200_disable_resp_output(self)


    def enable_resp_output(self):
        """
        enable_resp_output(PyX2M200 self)



        Turn on respiration status output from the Xethru X2M200 module.  

        """
        return _moduleconnectorwrapper.PyX2M200_enable_resp_output(self)


    def get_number_of_packets(self, name):
        """
        get_number_of_packets(PyX2M200 self, std::string const & name) -> unsigned int



        Get number of packets in a named subscription queue/buffer.  

        Parameters
        ----------
        * `name` :  
            Name of the subscription  

        """
        return _moduleconnectorwrapper.PyX2M200_get_number_of_packets(self, name)


    def get_packet(self, name):
        """
        get_packet(PyX2M200 self, std::string const & name) -> ucVector



        Get one packets of data.  

        Parameters
        ----------
        * `name` :  
            name of subscription given when during the subscribe.  

        Returns
        -------
        packet: the packet data as a vector of bytes.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_packet(self, name)


    def get_respiration_data(self, name):
        """
        get_respiration_data(PyX2M200 self, std::string const name) -> RespirationData



        Get one respiration data message from subscription queue.  

        Parameters
        ----------
        * `name` :  
            Name of subscription  

        Returns
        -------
        A data object holding the resulting respiration data.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_respiration_data(self, name)


    def get_sleep_data(self, name):
        """
        get_sleep_data(PyX2M200 self, std::string const name) -> SleepData



        Get one sleep data message from subscription queue.  

        Parameters
        ----------
        * `name` :  
            Name of subscription  

        Returns
        -------
        A data object holding the resulting sleep data.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_sleep_data(self, name)


    def get_baseband_ap_data(self, name):
        """
        get_baseband_ap_data(PyX2M200 self, std::string const name) -> BasebandApData



        Get one baseband data message from subscription queue.  

        Parameters
        ----------
        * `name` :  
            Name of subscription  

        Returns
        -------
        A data object holding the resulting amplitude/phase baseband data.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_baseband_ap_data(self, name)


    def get_baseband_iq_data(self, name):
        """
        get_baseband_iq_data(PyX2M200 self, std::string const name) -> BasebandIqData



        Get one baseband data message from subscription queue.  

        Parameters
        ----------
        * `name` :  
            Name of subscription  

        Returns
        -------
        A data object holding the resulting I/Q baseband data.  

        """
        return _moduleconnectorwrapper.PyX2M200_get_baseband_iq_data(self, name)


    def clear(self, name):
        """
        clear(PyX2M200 self, std::string const & name)



        Empty the buffer of the named data stream subscription.  

        Parameters
        ----------
        * `name` :  
            Name of subscription  

        """
        return _moduleconnectorwrapper.PyX2M200_clear(self, name)

PyX2M200_swigregister = _moduleconnectorwrapper.PyX2M200_swigregister
PyX2M200_swigregister(PyX2M200)

class PyXEP(_object):
    """


    C++ includes: PyXEP.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyXEP, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyXEP, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface):
        """
        __init__(XeThru::PyXEP self, LockedRadarInterfacePtr & radar_interface) -> PyXEP



        Constructor.  

        Initialized by PythonModuleConnector::get_xep  

        Parameters
        ----------
        * `radar_interface` :  
            a reference to the internal radar interface  

        """
        this = _moduleconnectorwrapper.new_PyXEP(radar_interface)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyXEP
    __del__ = lambda self: None

    def set_baudrate(self, baudrate):
        """
        set_baudrate(PyXEP self, uint32_t baudrate)



        Sets the baudrate to use for serial communication during ModuleConnector
        operation.  

        Parameters
        ----------
        * `baudrate` :  
            enum representing the baudrate, defined in xtid.h  

        """
        return _moduleconnectorwrapper.PyXEP_set_baudrate(self, baudrate)


    def module_reset(self):
        """
        module_reset(PyXEP self)



        Resets the module.  

        """
        return _moduleconnectorwrapper.PyXEP_module_reset(self)


    def get_system_info(self, info_code):
        """
        get_system_info(PyXEP self, uint8_t info_code) -> std::string



        Parameters
        ----------
        * `info_code` :  
            Specifies the info code.  

        Returns
        -------
        a string containing system information given by infocode: XTS_SSIC_FIRMWAREID =
        0x02 -> Returns the installed Firmware ID, "XEP" XTS_SSIC_VERSION = 0x03 ->
        Returns the installed Firmware Version. As viewed from the "highest" level of
        the software. XTS_SSIC_BUILD = 0x04 -> Returns information of the SW Build
        installed on the device XTS_SSIC_VERSIONLIST = 0x07 -> Returns ID and version of
        all components. Calls all components and compound a string. E.g.
        "XEP:2.3.4.5;X4C51:1.0.0.0"  

        """
        return _moduleconnectorwrapper.PyXEP_get_system_info(self, info_code)


    def ping(self):
        """
        ping(PyXEP self) -> uint32_t



        Send ping to module in order to validate that connection both ways is OK.  

        Returns
        -------
        the pong value  

        """
        return _moduleconnectorwrapper.PyXEP_ping(self)


    def set_normalization(self, normalization):
        """
        set_normalization(PyXEP self, uint8_t normalization)



        """
        return _moduleconnectorwrapper.PyXEP_set_normalization(self, normalization)


    def get_normalization(self):
        """
        get_normalization(PyXEP self) -> uint8_t



        """
        return _moduleconnectorwrapper.PyXEP_get_normalization(self)


    def set_phase_noise_correction(self, enable, correction_distance):
        """
        set_phase_noise_correction(PyXEP self, uint8_t enable, float correction_distance)



        """
        return _moduleconnectorwrapper.PyXEP_set_phase_noise_correction(self, enable, correction_distance)


    def get_phase_noise_correction(self):
        """
        get_phase_noise_correction(PyXEP self) -> float



        """
        return _moduleconnectorwrapper.PyXEP_get_phase_noise_correction(self)


    def set_decimation_factor(self, decimation_factor):
        """
        set_decimation_factor(PyXEP self, uint32_t decimation_factor)



        """
        return _moduleconnectorwrapper.PyXEP_set_decimation_factor(self, decimation_factor)


    def get_decimation_factor(self):
        """
        get_decimation_factor(PyXEP self) -> uint32_t



        """
        return _moduleconnectorwrapper.PyXEP_get_decimation_factor(self)


    def set_number_format(self, number_format):
        """
        set_number_format(PyXEP self, uint8_t number_format)



        """
        return _moduleconnectorwrapper.PyXEP_set_number_format(self, number_format)


    def get_number_format(self):
        """
        get_number_format(PyXEP self) -> uint8_t



        """
        return _moduleconnectorwrapper.PyXEP_get_number_format(self)


    def set_legacy_output(self, legacy_output):
        """
        set_legacy_output(PyXEP self, uint8_t legacy_output)



        """
        return _moduleconnectorwrapper.PyXEP_set_legacy_output(self, legacy_output)


    def get_legacy_output(self):
        """
        get_legacy_output(PyXEP self) -> uint8_t



        """
        return _moduleconnectorwrapper.PyXEP_get_legacy_output(self)


    def x4driver_set_fps(self, fps):
        """
        x4driver_set_fps(PyXEP self, float fps)



        Sets frame rate for frame streaming.  

        Parameters
        ----------
        * `fps` :  
            Specifies the fps  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_fps(self, fps)


    def x4driver_get_fps(self):
        """
        x4driver_get_fps(PyXEP self) -> float



        Returns
        -------
        the configured FPS  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_fps(self)


    def x4driver_set_enable(self, value):
        """
        x4driver_set_enable(PyXEP self, uint8_t value)



        Set enable for X4 enable pin.  

        Parameters
        ----------
        * `value` :  
            Specifies the value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_enable(self, value)


    def x4driver_init(self):
        """
        x4driver_init(PyXEP self)



        Ensures that enable is set, 8051 SRAM is programmed, ldos are enabled, and that
        the external oscillator has been enabled.  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_init(self)


    def x4driver_set_iterations(self, iterations):
        """
        x4driver_set_iterations(PyXEP self, uint32_t iterations)



        Sets Iterations.  

        Parameters
        ----------
        * `iterations` :  
            specifies the iterations value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_iterations(self, iterations)


    def x4driver_get_iterations(self):
        """
        x4driver_get_iterations(PyXEP self) -> uint32_t



        Gets Iterations.  

        Returns
        -------
        Iterations value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_iterations(self)


    def x4driver_set_pulses_per_step(self, pps):
        """
        x4driver_set_pulses_per_step(PyXEP self, uint32_t pps)



        Sets pulses per step.  

        Parameters
        ----------
        * `pps` :  
            Specifies the pulses per step value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_pulses_per_step(self, pps)


    def x4driver_get_pulses_per_step(self):
        """
        x4driver_get_pulses_per_step(PyXEP self) -> uint32_t



        Gets pulses per step.  

        Returns
        -------
        Pulses per step value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_pulses_per_step(self)


    def x4driver_set_dac_min(self, dac_min):
        """
        x4driver_set_dac_min(PyXEP self, uint32_t dac_min)



        Sets dac min.  

        Parameters
        ----------
        * `dac_min` :  
            Specifies the dac min value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_dac_min(self, dac_min)


    def x4driver_get_dac_min(self):
        """
        x4driver_get_dac_min(PyXEP self) -> uint32_t



        Gets dac min.  

        Returns
        -------
        Dac min value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_dac_min(self)


    def x4driver_set_dac_max(self, dac_max):
        """
        x4driver_set_dac_max(PyXEP self, uint32_t dac_max)



        Sets dac max.  

        Parameters
        ----------
        * `dac_max` :  
            Specifies the dac max value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_dac_max(self, dac_max)


    def x4driver_get_dac_max(self):
        """
        x4driver_get_dac_max(PyXEP self) -> uint32_t



        Gets dac max.  

        Returns
        -------
        Dac max value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_dac_max(self)


    def x4driver_set_tx_power(self, tx_power):
        """
        x4driver_set_tx_power(PyXEP self, uint8_t tx_power)



        Set the radar transmitter power.  

        0 = transmitter off. See datasheet for valid values.  

        Parameters
        ----------
        * `tx_power` :  
            Specifies the transmitter power  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_tx_power(self, tx_power)


    def x4driver_get_tx_power(self):
        """
        x4driver_get_tx_power(PyXEP self) -> uint8_t



        Get the radar transmitter power.  

        0 = transmitter off. See datasheet for valid values.  

        Returns
        -------
        tx_power Specifies the transmitter power  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_tx_power(self)


    def x4driver_set_downconversion(self, enable):
        """
        x4driver_set_downconversion(PyXEP self, uint8_t enable)



        Sets downconversion.  

        Parameters
        ----------
        * `enable` :  
            Specifies downconversion, 0=no downconversion, i.e. rf data.
            1=downconversion.  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_downconversion(self, enable)


    def x4driver_get_downconversion(self):
        """
        x4driver_get_downconversion(PyXEP self) -> uint8_t



        Gets downconversion.  

        Returns
        -------
        Downconversion, 0=no downconversion, i.e. rf data. 1=downconversion.  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_downconversion(self)


    def x4driver_get_frame_bin_count(self):
        """
        x4driver_get_frame_bin_count(PyXEP self) -> uint32_t



        Gets frame bin count.  

        Returns
        -------
        frame bin count  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_frame_bin_count(self)


    def x4driver_set_frame_area(self, start, end):
        """
        x4driver_set_frame_area(PyXEP self, float start, float end)



        Set frame area zone Assume air as transmitter medium.  

        Start and end in meter.  

        Parameters
        ----------
        * `start` :  
            Specifies the start  
        * `end` :  
            Specifies the end  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_frame_area(self, start, end)


    def x4driver_get_frame_area(self):
        """
        x4driver_get_frame_area(PyXEP self) -> FrameArea



        Get frame area zone.  

        Returns
        -------
        FrameArea  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_frame_area(self)


    def x4driver_set_frame_area_offset(self, offset):
        """
        x4driver_set_frame_area_offset(PyXEP self, float offset)



        Offset to adjust frame area reference depending on module product.  

        Parameters
        ----------
        * `offset` :  
            Specifies the offset  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_frame_area_offset(self, offset)


    def x4driver_get_frame_area_offset(self):
        """
        x4driver_get_frame_area_offset(PyXEP self) -> float



        Offset to adjust frame area reference depending on module product.  

        Returns
        -------
        the frame area offset  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_frame_area_offset(self)


    def x4driver_set_tx_center_frequency(self, tx_frequency):
        """
        x4driver_set_tx_center_frequency(PyXEP self, uint8_t tx_frequency)



        Set radar TX center frequency.  

        Parameters
        ----------
        * `tx_frequency` :  
            Specifies the frequency  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_tx_center_frequency(self, tx_frequency)


    def x4driver_get_tx_center_frequency(self):
        """
        x4driver_get_tx_center_frequency(PyXEP self) -> uint8_t



        Get radar TX center frequency.  

        Returns
        -------
        Center frequency  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_tx_center_frequency(self)


    def x4driver_set_spi_register(self, address, value):
        """
        x4driver_set_spi_register(PyXEP self, uint8_t address, uint8_t value)



        Set spi register on radar chip.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `value` :  
            Specifies the value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_spi_register(self, address, value)


    def x4driver_get_spi_register(self, address):
        """
        x4driver_get_spi_register(PyXEP self, uint8_t address) -> uint8_t



        Parameters
        ----------
        * `address` :  
            Specifies the address  

        Returns
        -------
        the SPI register at the specified address  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_spi_register(self, address)


    def x4driver_write_to_spi_register(self, address, values):
        """
        x4driver_write_to_spi_register(PyXEP self, uint8_t address, ucVector values)



        Write to a spi register on radar chip.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `values` :  
            Specifies the values  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_write_to_spi_register(self, address, values)


    def x4driver_read_from_spi_register(self, address, length):
        """
        x4driver_read_from_spi_register(PyXEP self, uint8_t address, uint32_t const length) -> ucVector



        Read from a spi register.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `length` :  
            Specifies how many bytes to read  

        Returns
        -------
        data from the SPI register at the specified address  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_read_from_spi_register(self, address, length)


    def x4driver_write_to_i2c_register(self, address, values):
        """
        x4driver_write_to_i2c_register(PyXEP self, uint8_t address, ucVector values)



        Write to a i2c register on radar chip.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `values` :  
            Specifies the values  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_write_to_i2c_register(self, address, values)


    def x4driver_read_from_i2c_register(self, length):
        """
        x4driver_read_from_i2c_register(PyXEP self, uint32_t const length) -> ucVector



        Read from a i2c register.  

        Parameters
        ----------
        * `length` :  
            Specifies how many bytes to read  

        Returns
        -------
        data from the SPI register at the specified address  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_read_from_i2c_register(self, length)


    def x4driver_set_pif_register(self, address, value):
        """
        x4driver_set_pif_register(PyXEP self, uint8_t address, uint8_t value)



        Sets PIF register value.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `value` :  
            Specifies the value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_pif_register(self, address, value)


    def x4driver_get_pif_register(self, address):
        """
        x4driver_get_pif_register(PyXEP self, uint8_t address) -> uint8_t



        Parameters
        ----------
        * `address` :  
            Specifies the address  

        Returns
        -------
        the PIF register at the specified address  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_pif_register(self, address)


    def x4driver_set_xif_register(self, address, value):
        """
        x4driver_set_xif_register(PyXEP self, uint8_t address, uint8_t value)



        Sets XIF register value.  

        Parameters
        ----------
        * `address` :  
            Specifies the address  
        * `value` :  
            Specifies the value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_xif_register(self, address, value)


    def x4driver_get_xif_register(self, address):
        """
        x4driver_get_xif_register(PyXEP self, uint8_t address) -> uint8_t



        Parameters
        ----------
        * `address` :  
            Specifies the address  

        Returns
        -------
        the XIF register value at the specified address  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_xif_register(self, address)


    def x4driver_set_prf_div(self, prf_div):
        """
        x4driver_set_prf_div(PyXEP self, uint8_t prf_div)



        Sets Pulse Repetition Frequency(PRF) divider.  

        Parameters
        ----------
        * `prf_div` :  
            Specifies the PRF  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_set_prf_div(self, prf_div)


    def x4driver_get_prf_div(self):
        """
        x4driver_get_prf_div(PyXEP self) -> uint8_t



        Gets Pulse Repetition Frequency(PRF) divider.  

        Returns
        -------
        register: register value  

        """
        return _moduleconnectorwrapper.PyXEP_x4driver_get_prf_div(self)


    def set_iopin_control(self, pin_id, pin_setup, pin_feature):
        """
        set_iopin_control(PyXEP self, uint32_t pin_id, uint32_t pin_setup, uint32_t pin_feature)



        Enable or disable GPIO feature.  

        pin_id = 0 : all pins pin_id != 0 : designated pin pin_feature = 0 : disabled -
        pin tri-stated / input (TBD) pin_feature = 1 : default pin_feature > 1 :
        designated feature Pin setup: 0 = input 1 = output Pin feature: 0 = Disable all
        iopin features (not available, will return error) 1 = Configure according to
        datasheet default (not available, will return error) 2 = Passive - Set and get
        iopin level from host  

        """
        return _moduleconnectorwrapper.PyXEP_set_iopin_control(self, pin_id, pin_setup, pin_feature)


    def set_iopin_value(self, pin_id, pin_value):
        """
        set_iopin_value(PyXEP self, uint32_t pin_id, uint32_t pin_value)



        If IO pin control is used to set pin_id as output, the pin level or value will
        be set to pin_value.  

        """
        return _moduleconnectorwrapper.PyXEP_set_iopin_value(self, pin_id, pin_value)


    def get_iopin_value(self, pin_id):
        """
        get_iopin_value(PyXEP self, uint32_t pin_id) -> uint32_t



        Read IO pin level or value.  

        Returns
        -------
        value: io pin value  

        """
        return _moduleconnectorwrapper.PyXEP_get_iopin_value(self, pin_id)


    def peek_message_data_float(self):
        """
        peek_message_data_float(PyXEP self) -> int



        Returns number of data float packets in internal queue.  

        Returns
        -------
        Returns number of data float packets in internal queue  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_data_float(self)


    def read_message_data_float(self):
        """
        read_message_data_float(PyXEP self) -> DataFloat



        Reads a single data float message from internal queue.  

        Returns
        -------
        the data float message  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_data_float(self)


    def peek_message_radar_rf(self):
        """
        peek_message_radar_rf(PyXEP self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_radar_rf(self)


    def read_message_radar_rf(self):
        """
        read_message_radar_rf(PyXEP self) -> RadarRfData



        Read a single RadarRfData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        RadarRfData:  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_radar_rf(self)


    def peek_message_radar_rf_normalized(self):
        """
        peek_message_radar_rf_normalized(PyXEP self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_radar_rf_normalized(self)


    def read_message_radar_rf_normalized(self):
        """
        read_message_radar_rf_normalized(PyXEP self) -> RadarRfNormalizedData



        Read a single RadarRfNormalizedData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        RadarRfNormalizedData:  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_radar_rf_normalized(self)


    def peek_message_radar_baseband_float(self):
        """
        peek_message_radar_baseband_float(PyXEP self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_radar_baseband_float(self)


    def read_message_radar_baseband_float(self):
        """
        read_message_radar_baseband_float(PyXEP self) -> RadarBasebandFloatData



        Read a single RadarBasebandFloatData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        RadarBasebandFloatData:  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_radar_baseband_float(self)


    def peek_message_radar_baseband_q15(self):
        """
        peek_message_radar_baseband_q15(PyXEP self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_radar_baseband_q15(self)


    def read_message_radar_baseband_q15(self):
        """
        read_message_radar_baseband_q15(PyXEP self) -> RadarBasebandQ15Data



        Read a single RadarBasebandQ15Data item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        RadarBasebandQ15Data:  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_radar_baseband_q15(self)


    def peek_message_data_string(self):
        """
        peek_message_data_string(PyXEP self) -> int



        Returns number of data string packets in internal queue.  

        Returns
        -------
        the number of data string packets in internal queue.  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_data_string(self)


    def read_message_data_string(self, content_id, info, data):
        """
        read_message_data_string(PyXEP self, uint32_t * content_id, uint32_t * info, std::string * data) -> int



        Reads a single data string message from internal queue.  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_data_string(self, content_id, info, data)


    def peek_message_data_byte(self):
        """
        peek_message_data_byte(PyXEP self) -> int



        Returns number of data byte packets in internal queue.  

        Returns
        -------
        the number of data byte packets in internal queue.  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_data_byte(self)


    def read_message_data_byte(self, content_id, info, data):
        """
        read_message_data_byte(PyXEP self, uint32_t * content_id, uint32_t * info, ucVector data) -> int



        Reads a single data byte message from internal queue.  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_data_byte(self, content_id, info, data)


    def peek_message_system(self):
        """
        peek_message_system(PyXEP self) -> int



        Sets max number of messages to store in internal data float queue.  

        Returns
        -------
        the number of system packets in internal queue  

        """
        return _moduleconnectorwrapper.PyXEP_peek_message_system(self)


    def read_message_system(self):
        """
        read_message_system(PyXEP self) -> uint32_t



        Reads a single data system message from internal queue.  

        Returns
        -------
        system package  

        """
        return _moduleconnectorwrapper.PyXEP_read_message_system(self)


    def search_for_file_by_type(self, type):
        """
        search_for_file_by_type(PyXEP self, uint32_t type) -> iVector



        Searches for and returns a list of identifiers for all files of the specified
        type.  

        Parameters
        ----------
        * `type` :  
            The type of file.  

        Returns
        -------
        vector of file identifiers are copied here as result.  

        """
        return _moduleconnectorwrapper.PyXEP_search_for_file_by_type(self, type)


    def find_all_files(self):
        """
        find_all_files(PyXEP self) -> Files



        Finds all files and stores the type and identifier of each file in the given
        buffers.  

        Returns
        -------
        The result from the search. A map of file (type identifiers)  

        """
        return _moduleconnectorwrapper.PyXEP_find_all_files(self)


    def create_file(self, file_type, identifier, length):
        """
        create_file(PyXEP self, uint32_t file_type, uint32_t identifier, uint32_t length)



        Creates and opens a new file with given type, identifiers and length.  

        Parameters
        ----------
        * `file_type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  
        * `length` :  
            length of the file to create  

        """
        return _moduleconnectorwrapper.PyXEP_create_file(self, file_type, identifier, length)


    def open_file(self, file_type, identifier):
        """
        open_file(PyXEP self, uint32_t file_type, uint32_t identifier)



        Opens a file with given type and identifiers.  

        Parameters
        ----------
        * `file_type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  
        * `length` :  
            length of the file to create  

        """
        return _moduleconnectorwrapper.PyXEP_open_file(self, file_type, identifier)


    def set_file_data(self, type, identifier, offset, data):
        """
        set_file_data(PyXEP self, uint32_t type, uint32_t identifier, uint32_t offset, ucVector data)



        Writes data at offset to the file.  

        Parameters
        ----------
        * `type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  
        * `offset` :  
            Offset where to write the data to.  
        * `data` :  
            The data to write.  

        """
        return _moduleconnectorwrapper.PyXEP_set_file_data(self, type, identifier, offset, data)


    def close_file(self, type, identifier, commit):
        """
        close_file(PyXEP self, uint32_t type, uint32_t identifier, bool commit)



        Close the file.  

        Parameters
        ----------
        * `type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  
        * `commit` :  
            wether to commit changes to the file to close  

        """
        return _moduleconnectorwrapper.PyXEP_close_file(self, type, identifier, commit)


    def get_file_length(self, type, identifier):
        """
        get_file_length(PyXEP self, uint32_t type, uint32_t identifier) -> uint32_t



        Gets the length of a file.  

        Parameters
        ----------
        * `type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  

        Returns
        -------
        The length of the file.  

        """
        return _moduleconnectorwrapper.PyXEP_get_file_length(self, type, identifier)


    def delete_file(self, type, identifier):
        """
        delete_file(PyXEP self, uint32_t type, uint32_t identifier)



        Deletes a file.  

        Parameters
        ----------
        * `type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  

        """
        return _moduleconnectorwrapper.PyXEP_delete_file(self, type, identifier)


    def format_filesystem(self, key):
        """
        format_filesystem(PyXEP self, uint32_t key)



        """
        return _moduleconnectorwrapper.PyXEP_format_filesystem(self, key)


    def get_file_data(self, type, identifier, offset, length):
        """
        get_file_data(PyXEP self, uint32_t type, uint32_t identifier, uint32_t offset, uint32_t length) -> ucVector



        Reads length number of bytes of the file from the offset.  

        Parameters
        ----------
        * `type` :  
            The type of file.  
        * `identifier` :  
            The identifer of the file.  
        * `offset` :  
            The offset to read from.  
        * `length` :  
            Number of bytes to read.  

        Returns
        -------
        The result as a vector of bytes.  

        """
        return _moduleconnectorwrapper.PyXEP_get_file_data(self, type, identifier, offset, length)


    def set_file(self, type, identifier, data):
        """
        set_file(PyXEP self, uint32_t type, uint32_t identifier, ucVector data)



        """
        return _moduleconnectorwrapper.PyXEP_set_file(self, type, identifier, data)


    def get_file(self, type, identifier):
        """
        get_file(PyXEP self, uint32_t type, uint32_t identifier) -> ucVector



        """
        return _moduleconnectorwrapper.PyXEP_get_file(self, type, identifier)

PyXEP_swigregister = _moduleconnectorwrapper.PyXEP_swigregister
PyXEP_swigregister(PyXEP)

class PyX4M200(_object):
    """


    C++ includes: PyX4M200.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyX4M200, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyX4M200, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface):
        """
        __init__(XeThru::PyX4M200 self, LockedRadarInterfacePtr & radar_interface) -> PyX4M200



        """
        this = _moduleconnectorwrapper.new_PyX4M200(radar_interface)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyX4M200
    __del__ = lambda self: None

    def set_baudrate(self, baudrate):
        """
        set_baudrate(PyX4M200 self, uint32_t baudrate)



        Set baudrate for serial communication during ModuleConnector operation.  

        Parameters
        ----------
        * `baudrate` :  
            enum representing the baudrate e.g
            moduleconnectorwrapper.XTID_BAUDRATE_115200.  

        """
        return _moduleconnectorwrapper.PyX4M200_set_baudrate(self, baudrate)


    def set_debug_level(self, level):
        """
        set_debug_level(PyX4M200 self, unsigned char level)



        Sets debug level in the Xethru module.  

        Parameters
        ----------
        * `level` :  
            New debug level. Legal range [0-9].  

        """
        return _moduleconnectorwrapper.PyX4M200_set_debug_level(self, level)


    def ping(self):
        """
        ping(PyX4M200 self) -> uint32_t



        Make sure there is a connection to FW on the Xethru X4M200 module.  

        Returns
        -------
        pong: 0xaaeeaeea means system ready and 0xaeeaeeaa means system not ready  

        """
        return _moduleconnectorwrapper.PyX4M200_ping(self)


    def get_system_info(self, info_code):
        """
        get_system_info(PyX4M200 self, uint8_t const info_code) -> std::string



        Returns a string containing system information given by infocode:  

        XTID_SSIC_ITEMNUMBER = 0x00 -> Returns the internal Novelda PCBA Item Number,
        including revision. This is programmed in Flash during manufacturing
        XTID_SSIC_ORDERCODE = 0x01 -> Returns the PCBA / PCBA stack order code.
        XTID_SSIC_FIRMWAREID = 0x02 -> Returns the installed Firmware ID. As viewed from
        the "highest" level of the software, "X4M300". XTID_SSIC_VERSION = 0x03 ->
        Returns the installed Firmware Version. As viewed from the "highest" level of
        the software. XTID_SSIC_BUILD = 0x04 -> Returns information of the SW Build
        installed on the device XTID_SSIC_SERIALNUMBER = 0x06 -> Returns the PCBA serial
        number XTID_SSIC_VERSIONLIST = 0x07 -> Returns ID and version of all components.
        Calls all components and compound a string. E.g.
        "X4M300:1.0.0.3;XEP:2.3.4.5;X4C51:1.0.0.0;DSP:1.1.1.1"  

        """
        return _moduleconnectorwrapper.PyX4M200_get_system_info(self, info_code)


    def module_reset(self):
        """
        module_reset(PyX4M200 self)



        Resets and restart the module.  

        The client must perform a close and then an open on the ModuleConnector to
        reeastablish connection.  

        """
        return _moduleconnectorwrapper.PyX4M200_module_reset(self)


    def reset(self):
        """
        reset(PyX4M200 self)



        Resets and restart the module.  

        This method automatically reestablishes.  

        """
        return _moduleconnectorwrapper.PyX4M200_reset(self)


    def reset_to_factory_preset(self):
        """
        reset_to_factory_preset(PyX4M200 self)



        Resets all parameters in the module to factory presets.  

        """
        return _moduleconnectorwrapper.PyX4M200_reset_to_factory_preset(self)


    def start_bootloader(self):
        """
        start_bootloader(PyX4M200 self)



        Enters the bootloader for FW upgrades.  

        """
        return _moduleconnectorwrapper.PyX4M200_start_bootloader(self)


    def inject_frame(self, frame_counter, frame_length, frame):
        """
        inject_frame(PyX4M200 self, uint32_t frame_counter, uint32_t frame_length, FloatVector frame)



        Injects a radar frame.  

        Parameters
        ----------
        * `frame_counter` :  
            Frame counter of frame.  
        * `frame_length` :  
            Number of bins in the frame.  
        * `frame` :  
            The frame data to inject.  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyX4M200_inject_frame(self, frame_counter, frame_length, frame)


    def prepare_inject_frame(self, num_frames, num_bins, mode):
        """
        prepare_inject_frame(PyX4M200 self, uint32_t num_frames, uint32_t num_bins, uint32_t mode)



        Prepare for injection of radar frame(s).  

        Parameters
        ----------
        * `num_frame` :  
            Number of frame to inject  
        * `num_bins` :  
            Number of bins in each frame.  
        * `mode` :  
            The frame injection mode: LOOP, SEQUENTIAL, SINGLE  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyX4M200_prepare_inject_frame(self, num_frames, num_bins, mode)


    def system_run_test(self, testcode, data):
        """
        system_run_test(PyX4M200 self, uint8_t const testcode, ucVector data)



        Runs the different manufacturing tests identified by testcode.  

        Can return any number of results depending on test_mode. Host must know how to
        parse test results.  

        Parameters
        ----------
        * `testcode` :  
        * `data` :  
            data buffer containing the result from a test run.  

        """
        return _moduleconnectorwrapper.PyX4M200_system_run_test(self, testcode, data)


    def load_profile(self, profileid):
        """
        load_profile(PyX4M200 self, uint32_t const profileid)



        Loads the presence profile.  

        If another profile is loaded, the other profile is unloaded before the new
        profile is loaded. The profile does not start, the module remains idle.  

        Parameters
        ----------
        * `profileid` :  
            the id of the profile to load profileid = XTS_ID_APP_RESPIRATION_2 : sleep
            profile  

        """
        return _moduleconnectorwrapper.PyX4M200_load_profile(self, profileid)


    def set_sensor_mode(self, mode, param):
        """
        set_sensor_mode(PyX4M200 self, uint8_t const mode, uint8_t const param)



        Control the execution mode of the sensor.  

        Parameters
        ----------
        * `mode` :  

             XTID_SM_RUN : Start profile execution  
             XTID_SM_IDLE : Halts profile execution. Can be resumed by setting mode to
            Run.  
             XTID_SM_STOP : Stops profile execution. Must do load_profile to continue.  
             XTID_SM_MANUAL : Routes X4 radar data directly to host rather than to
            profile execution. Can then interact directly with XEP / X4Driver. Will
            disrupt profile performance.  
        * `param` :  
            Not used, ignored, can be 0.  

        """
        return _moduleconnectorwrapper.PyX4M200_set_sensor_mode(self, mode, param)


    def get_sensor_mode(self):
        """
        get_sensor_mode(PyX4M200 self) -> uint8_t



        """
        return _moduleconnectorwrapper.PyX4M200_get_sensor_mode(self)


    def set_sensitivity(self, sensitivity):
        """
        set_sensitivity(PyX4M200 self, uint32_t const sensitivity)



        Sets the overall sensitivity.  

        Parameters
        ----------
        * `sensitivity` :  
            : 0 to 9, 0 = low, 9 = high  

        """
        return _moduleconnectorwrapper.PyX4M200_set_sensitivity(self, sensitivity)


    def get_sensitivity(self):
        """
        get_sensitivity(PyX4M200 self) -> uint32_t



        Gets the overall sensitivity.  

        Returns
        -------
        sensitivity : 0 to 9, 0 = low, 9 = high  

        """
        return _moduleconnectorwrapper.PyX4M200_get_sensitivity(self)


    def set_tx_center_frequency(self, frequency_band):
        """
        set_tx_center_frequency(PyX4M200 self, uint32_t const frequency_band)



        Sets TX center frequency.  

        Parameters
        ----------
        * `frequency_band` :  
            : 3 for low band, 4 for high band  

        """
        return _moduleconnectorwrapper.PyX4M200_set_tx_center_frequency(self, frequency_band)


    def get_tx_center_frequency(self):
        """
        get_tx_center_frequency(PyX4M200 self) -> uint32_t



        Gets TX center frequency.  

        Returns
        -------
        frequency_band : 3 for low band, 4 for high band  

        """
        return _moduleconnectorwrapper.PyX4M200_get_tx_center_frequency(self)


    def set_detection_zone(self, start, end):
        """
        set_detection_zone(PyX4M200 self, float const start, float const end)



        Sets the current detection zone.  

        Rules: See datasheet. The actual detection zone is determined by radar settings.
        Use the get_detection_zone command to get the actual values  

        Parameters
        ----------
        * `start` :  
        * `end` :  

        """
        return _moduleconnectorwrapper.PyX4M200_set_detection_zone(self, start, end)


    def get_detection_zone(self):
        """
        get_detection_zone(PyX4M200 self) -> DetectionZone



        Returns the actual range window.  

        Returns
        -------
        DetectionZone  

        """
        return _moduleconnectorwrapper.PyX4M200_get_detection_zone(self)


    def get_detection_zone_limits(self):
        """
        get_detection_zone_limits(PyX4M200 self) -> DetectionZoneLimits



        Returns the potential settings of detection zone from the module.  

        Returns
        -------
        DetectionZoneLimits:  

        """
        return _moduleconnectorwrapper.PyX4M200_get_detection_zone_limits(self)


    def set_led_control(self, mode, intensity):
        """
        set_led_control(PyX4M200 self, uint8_t const mode, uint8_t intensity)



        This command configures the LED mode.  



        Parameters
        ----------
        * `mode` :  
            (modes are defined in xtid.h)  
             mode = XTID_LED_MODE_OFF : OFF  
             mode = XTID_LED_MODE_SIMPLE : simple  
             mode = XTID_LED_MODE_FULL : full (default)  
        * `intensity` :  
            0 to 100, 0=low, 100=high, not implemented yet  

        """
        return _moduleconnectorwrapper.PyX4M200_set_led_control(self, mode, intensity)


    def get_led_control(self):
        """
        get_led_control(PyX4M200 self) -> uint32_t



        Gets LED mode mode = XTID_LED_MODE_OFF : OFF  
         mode = XTID_LED_MODE_SIMPLE : simple  
         mode = XTID_LED_MODE_FULL : full (default)  
         *.  

        Returns
        -------
        mode  

        """
        return _moduleconnectorwrapper.PyX4M200_get_led_control(self)


    def set_output_control(self, output_feature, output_control):
        """
        set_output_control(PyX4M200 self, uint32_t output_feature, uint32_t output_control)



        Control module profile output.  

        Enable and disable data messages. Several calls can be made, one for each
        available output message the profile provides.  

        Only one of XTS_ID_BASEBAND_IQ and XTS_ID_BASEBAND_AMPLITUDE_PHASE can be
        enabled at a time. Enabling one disables the other. Disabling one, even if it is
        already disabled, disables the other.  

        Only one of XTS_ID_PULSEDOPPLER_FLOAT and XTS_ID_PULSEDOPPLER_BYTE can be
        enabled for each of XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE and
        XTID_OUTPUT_CONTROL_PD_FAST_ENABLE. Same with XTS_ID_NOISEMAP_FLOAT and
        XTS_ID_NOISEMAP_BYTE. Turning on a float output automatically disables the byte
        output, and vice versa.  

        Parameters
        ----------
        * `output_feature` :  
            see values in xtid.h.  
             Possible features are:  
             XTS_ID_RESPIRATION_MOVINGLIST,  
             XTS_ID_RESPIRATION_DETECTIONLIST,  
             XTS_ID_RESP_STATUS,  
             XTS_ID_RESP_STATUS_EXT,  
             XTS_ID_BASEBAND_IQ,  
             XTS_ID_BASEBAND_AMPLITUDE_PHASE,  
             XTS_ID_PULSEDOPPLER_FLOAT,  
             XTS_ID_PULSEDOPPLER_BYTE,  
             XTS_ID_NOISEMAP_FLOAT and  
             XTS_ID_NOISEMAP_BYTE  
        * `output_control` :  
            see values in xtid.h.  
             Typical values:  
             XTID_OUTPUT_CONTROL_DISABLE = disable,  
             XTID_OUTPUT_CONTROL_ENABLE = enable.  
             For pulse-Doppler and noisemap byte/float:  
             XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE  
             XTID_OUTPUT_CONTROL_PD_FAST_ENABLE  

        """
        return _moduleconnectorwrapper.PyX4M200_set_output_control(self, output_feature, output_control)


    def set_debug_output_control(self, output_feature, output_control):
        """
        set_debug_output_control(PyX4M200 self, uint32_t output_feature, uint32_t output_control)



        """
        return _moduleconnectorwrapper.PyX4M200_set_debug_output_control(self, output_feature, output_control)


    def get_output_control(self, output_feature):
        """
        get_output_control(PyX4M200 self, uint32_t const output_feature) -> uint32_t



        """
        return _moduleconnectorwrapper.PyX4M200_get_output_control(self, output_feature)


    def get_debug_output_control(self, output_feature):
        """
        get_debug_output_control(PyX4M200 self, uint32_t const output_feature) -> uint32_t



        """
        return _moduleconnectorwrapper.PyX4M200_get_debug_output_control(self, output_feature)


    def peek_message_baseband_ap(self):
        """
        peek_message_baseband_ap(PyX4M200 self) -> int



        Return number of BasebandApData messages available in queue.  

        Returns
        -------
        size: number of messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_baseband_ap(self)


    def read_message_baseband_ap(self):
        """
        read_message_baseband_ap(PyX4M200 self) -> BasebandApData



        Read a single BasebandApData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        BasebandApData:  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_baseband_ap(self)


    def peek_message_baseband_iq(self):
        """
        peek_message_baseband_iq(PyX4M200 self) -> int



        Return number of BasebandIqData messages available in queue.  

        Returns
        -------
        size: number of messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_baseband_iq(self)


    def read_message_baseband_iq(self):
        """
        read_message_baseband_iq(PyX4M200 self) -> BasebandIqData



        Read a single BasebandIqData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        baseband_qi:  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_baseband_iq(self)


    def peek_message_respiration_legacy(self):
        """
        peek_message_respiration_legacy(PyX4M200 self) -> int



        Return number of legacy respiration packets available in the queue.  

        Returns
        -------
        size: number of messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_respiration_legacy(self)


    def read_message_respiration_legacy(self):
        """
        read_message_respiration_legacy(PyX4M200 self) -> RespirationData



        Read a single RespirationData item from the queue.  

        Blocks if queue is empty.  

        return respiration_data: pointer to returned RespirationData item  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_respiration_legacy(self)


    def peek_message_respiration_sleep(self):
        """
        peek_message_respiration_sleep(PyX4M200 self) -> int



        Return number of respiration sleep packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_respiration_sleep(self)


    def read_message_respiration_sleep(self):
        """
        read_message_respiration_sleep(PyX4M200 self) -> SleepData



        Get one sleep data message from subscription queue.  

        Returns
        -------
        sleep_data: A data object holding the resulting respiration data.  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_respiration_sleep(self)


    def peek_message_respiration_movinglist(self):
        """
        peek_message_respiration_movinglist(PyX4M200 self) -> int



        Return number of respiration moving list packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_respiration_movinglist(self)


    def read_message_respiration_movinglist(self):
        """
        read_message_respiration_movinglist(PyX4M200 self) -> RespirationMovingListData



        Get one respiration moving list data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting respiration moving list data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_respiration_movinglist(self)


    def peek_message_respiration_detectionlist(self):
        """
        peek_message_respiration_detectionlist(PyX4M200 self) -> int



        Return number of respiration detection list packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_respiration_detectionlist(self)


    def read_message_respiration_detectionlist(self):
        """
        read_message_respiration_detectionlist(PyX4M200 self) -> RespirationDetectionListData



        Get one respiration detection list data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting respiration detection list data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_respiration_detectionlist(self)


    def peek_message_respiration_normalizedmovementlist(self):
        """
        peek_message_respiration_normalizedmovementlist(PyX4M200 self) -> int



        Return number of respiration normalized movement list packets available in the
        queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_respiration_normalizedmovementlist(self)


    def read_message_respiration_normalizedmovementlist(self):
        """
        read_message_respiration_normalizedmovementlist(PyX4M200 self) -> RespirationNormalizedMovementListData



        Get one respiration normalized movement list data message from subscription
        queue.  

        Returns
        -------
        : A data object holding the resulting respiration normalized movement list data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_respiration_normalizedmovementlist(self)


    def peek_message_vital_signs(self):
        """
        peek_message_vital_signs(PyX4M200 self) -> int



        Return number of vital signs packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_vital_signs(self)


    def read_message_vital_signs(self):
        """
        read_message_vital_signs(PyX4M200 self) -> VitalSignsData



        Get one vital signs data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting vital signs data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_vital_signs(self)


    def peek_message_pulsedoppler_float(self):
        """
        peek_message_pulsedoppler_float(PyX4M200 self) -> int



        Return number of pulse-Doppler float packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_pulsedoppler_float(self)


    def read_message_pulsedoppler_float(self):
        """
        read_message_pulsedoppler_float(PyX4M200 self) -> PulseDopplerFloatData



        Get one pulse-Doppler float data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting pulse-Doppler float data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_pulsedoppler_float(self)


    def peek_message_pulsedoppler_byte(self):
        """
        peek_message_pulsedoppler_byte(PyX4M200 self) -> int



        Return number of pulse-Doppler byte packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_pulsedoppler_byte(self)


    def read_message_pulsedoppler_byte(self):
        """
        read_message_pulsedoppler_byte(PyX4M200 self) -> PulseDopplerByteData



        Get one pulse-Doppler byte data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting pulse-Doppler byte data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_pulsedoppler_byte(self)


    def peek_message_noisemap_float(self):
        """
        peek_message_noisemap_float(PyX4M200 self) -> int



        Return number of noisemap float packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_noisemap_float(self)


    def read_message_noisemap_float(self):
        """
        read_message_noisemap_float(PyX4M200 self) -> PulseDopplerFloatData



        Get one noisemap float data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting noisemap float data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_noisemap_float(self)


    def peek_message_noisemap_byte(self):
        """
        peek_message_noisemap_byte(PyX4M200 self) -> int



        Return number of noisemap byte packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M200_peek_message_noisemap_byte(self)


    def read_message_noisemap_byte(self):
        """
        read_message_noisemap_byte(PyX4M200 self) -> PulseDopplerByteData



        Get one noisemap byte data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting noisemap byte data  

        """
        return _moduleconnectorwrapper.PyX4M200_read_message_noisemap_byte(self)


    def load_noisemap(self):
        """
        load_noisemap(PyX4M200 self)



        Send command to module to load a previously stored noisemap.  

        Not yet functional as of FW 1.3  

        """
        return _moduleconnectorwrapper.PyX4M200_load_noisemap(self)


    def store_noisemap(self):
        """
        store_noisemap(PyX4M200 self)



        Send command to module to store the current noisemap to module flash.  

        Fails if a store already is active, for example during the first initialize with
        XTID_NOISEMAP_CONTROL_INIT_ON_RESET disabled.  

        """
        return _moduleconnectorwrapper.PyX4M200_store_noisemap(self)


    def delete_noisemap(self):
        """
        delete_noisemap(PyX4M200 self)



        Send command to module to delete stored noisemap from module flash.  

        Fails in case of flash access issues.  

        """
        return _moduleconnectorwrapper.PyX4M200_delete_noisemap(self)


    def set_noisemap_control(self, noisemap_control):
        """
        set_noisemap_control(PyX4M200 self, uint32_t noisemap_control)



        Configure the use of noisemap.  

        Parameters
        ----------
        * `noisemap_control` :  
            A bitfield of the various features.  

            *   Use Stored Noise Map
                -   On - XTID_NOISEMAP_CONTROL_USE_STORED
                    -   If a valid Stored Noise Map exists this will be used at reset or
                        when the Profile is started.  
                    -   If no valid Stored Noise Map exists and Use Default Noise Map is
                        off, a new Noise Map will be created during Initialization
                        state. The newly created Noise Map will be stored in the sensor
                        when Initialization is done. A noise map created with a
                        different Detection Zone is not valid.  
                    -   If no valid Stored Noise Map exists and Use Default Noise Map is
                        on, the Default Noise Map will be used at reset or when the
                        Profile is started.  
                -   Off - XTID_NOISEMAP_CONTROL_INIT_ON_RESET
                    -   If Use Default Noise Map is off, a new Noise Map will always be
                        created at reset or when the Profile is started. Sensor will be
                        in Initialization state during Noise Map creation. A previously
                        Stored Noise Map in the sensor will be ignored, but not
                        overwritten, when the Profile starts.  
                    -   If Use Default Noise Map is on, the Default Noise Map will be
                        used at reset or when the Profile is started.  
            *   Use Default Noise Map
                -   On - XTID_NOISEMAP_CONTROL_USE_DEFAULT / DISABLE
                    -   If Use Store Noise Map is on and a valid Stored Noise Map
                        exists, Default Noise Map will not be used.  
                    -   If Use Stored Noise Map is on and no valid Stored Noise Map
                        exists, the Default Noise Map will be used at reset or when the
                        Profile is started.  
                    -   If Use Stored Noise Map is off, the Default Noise Map will be
                        used at reset or when the Profile is started.  
                -   Off - XTID_NOISEMAP_CONTROL_ENABLE
                    -   The Default Noise Map will not be used.  
            *   Adaptive Noise Map
                -   On - XTID_NOISEMAP_CONTROL_ADAPTIVE
                    -   Enables Noise Map adaptation. Noise Map will still not adapt in
                        certain conditions as described in Firmware Algorithms section
                        below.  
                -   Off - XTID_NOISEMAP_CONTROL_NONADAPTIVE
                    -   Disables Noise Map adaptation (not implemented).  

        """
        return _moduleconnectorwrapper.PyX4M200_set_noisemap_control(self, noisemap_control)


    def get_noisemap_control(self):
        """
        get_noisemap_control(PyX4M200 self) -> uint32_t



        Get current noisemap configuration.  

        Returns
        -------
        noisemap_control : A bitfield of the various features.  

        """
        return _moduleconnectorwrapper.PyX4M200_get_noisemap_control(self)


    def set_periodic_noisemap_store(self, interval_minutes, reserved):
        """
        set_periodic_noisemap_store(PyX4M200 self, uint32_t interval_minutes, uint32_t reserved)



        Set interval for periodoc storing of noisemap.  

        Parameters
        ----------
        * `interval_minutes` :  
            Interval for storing moisemap  
        * `reserved` :  
            Reserved for future use, must be set to 0.  

        """
        return _moduleconnectorwrapper.PyX4M200_set_periodic_noisemap_store(self, interval_minutes, reserved)


    def get_periodic_noisemap_store(self):
        """
        get_periodic_noisemap_store(PyX4M200 self) -> PeriodicNoisemapStore



        Get interval for periodoc storing of noisemap.  

        Parameters
        ----------
        * `interval_minutes` :  
            Interval for storing moisemap  
        * `reserved` :  
            Reserved for future use, must be set to 0.  

        """
        return _moduleconnectorwrapper.PyX4M200_get_periodic_noisemap_store(self)


    def get_parameter_file(self, filename):
        """
        get_parameter_file(PyX4M200 self, std::string const & filename) -> std::string



        Read the complete parameter file from the module.  

        Returns
        -------
        a string containing the complete paramter file data  

        """
        return _moduleconnectorwrapper.PyX4M200_get_parameter_file(self, filename)


    def get_profileid(self):
        """
        get_profileid(PyX4M200 self) -> uint32_t



        Get the id of the currently loaded profile.  

        Returns
        -------
        profileid: the id of the loaded profile or 0 in case of no loaded profile.  

        """
        return _moduleconnectorwrapper.PyX4M200_get_profileid(self)


    def set_parameter_file(self, filename, data):
        """
        set_parameter_file(PyX4M200 self, std::string const & filename, std::string const & data)



        Set a named parameter file on target.  

        Parameters
        ----------
        * `filename` :  
            The name to call the parameter file.  
        * `data` :  
            The content of the parameter-file.  

        """
        return _moduleconnectorwrapper.PyX4M200_set_parameter_file(self, filename, data)


    def set_iopin_control(self, pin_id, pin_setup, pin_feature):
        """
        set_iopin_control(PyX4M200 self, uint32_t pin_id, uint32_t pin_setup, uint32_t pin_feature)



        Configures GPIO pin.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the IO pin to configure. pin_id = 0 means all IO pins.  
        * `pin_setup` :  
            Specifies the direction and drive of the IO pin. bit 0: input = 0, output =
            1 bit 1: open-drain = 0, push-pull = 1 bit 2: active-high = 0, active-low =
            1 bit 3: no pull-up = 0, pull-up = 1  
        * `pin_feature` :  
            Specifies the configuration of the IO pin. 0 = Disable all iopin features. 1
            = Configure according to datasheet default. This overrides pin_setup. 2 =
            Passive, set and get iopin level from host. 4 = Movement, see X4M200
            datasheet for details. 5 = Breathing, see X4M200 datasheet for details.  

        See also: get_iopin_value  

        """
        return _moduleconnectorwrapper.PyX4M200_set_iopin_control(self, pin_id, pin_setup, pin_feature)


    def get_iopin_control(self, pin_id):
        """
        get_iopin_control(PyX4M200 self, uint32_t pin_id) -> IoPinControl



        Gets the GPIO pin configuration.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the io pin to get.  

        Returns
        -------
        : A data object holding the pin configuration  

        See also: set_iopin_contron  

        """
        return _moduleconnectorwrapper.PyX4M200_get_iopin_control(self, pin_id)


    def set_iopin_value(self, pin_id, pin_value):
        """
        set_iopin_value(PyX4M200 self, uint32_t pin_id, uint32_t pin_value)



        Sets GPIO pin value.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the pin.  
        * `pin_value` :  
            Specifies the value.  

        note: Pin must be configured as output pin.  

        See also: set_iopin_control  

        """
        return _moduleconnectorwrapper.PyX4M200_set_iopin_value(self, pin_id, pin_value)


    def get_iopin_value(self, pin_id):
        """
        get_iopin_value(PyX4M200 self, uint32_t pin_id) -> uint32_t



        Gets GPIO pin value.  

        See also: set_iopin_value  

        """
        return _moduleconnectorwrapper.PyX4M200_get_iopin_value(self, pin_id)

PyX4M200_swigregister = _moduleconnectorwrapper.PyX4M200_swigregister
PyX4M200_swigregister(PyX4M200)

class PyX4M210(_object):
    """Proxy of C++ XeThru::PyX4M210 class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyX4M210, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyX4M210, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface):
        """__init__(XeThru::PyX4M210 self, LockedRadarInterfacePtr & radar_interface) -> PyX4M210"""
        this = _moduleconnectorwrapper.new_PyX4M210(radar_interface)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyX4M210
    __del__ = lambda self: None

    def set_baudrate(self, baudrate):
        """set_baudrate(PyX4M210 self, uint32_t baudrate)"""
        return _moduleconnectorwrapper.PyX4M210_set_baudrate(self, baudrate)


    def set_debug_level(self, level):
        """set_debug_level(PyX4M210 self, unsigned char level)"""
        return _moduleconnectorwrapper.PyX4M210_set_debug_level(self, level)


    def ping(self):
        """ping(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_ping(self)


    def get_system_info(self, info_code):
        """get_system_info(PyX4M210 self, uint8_t const info_code) -> std::string"""
        return _moduleconnectorwrapper.PyX4M210_get_system_info(self, info_code)


    def module_reset(self):
        """module_reset(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_module_reset(self)


    def reset(self):
        """reset(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_reset(self)


    def reset_to_factory_preset(self):
        """reset_to_factory_preset(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_reset_to_factory_preset(self)


    def start_bootloader(self):
        """start_bootloader(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_start_bootloader(self)


    def inject_frame(self, frame_counter, frame_length, frame):
        """inject_frame(PyX4M210 self, uint32_t frame_counter, uint32_t frame_length, FloatVector frame)"""
        return _moduleconnectorwrapper.PyX4M210_inject_frame(self, frame_counter, frame_length, frame)


    def prepare_inject_frame(self, num_frames, num_bins, mode):
        """prepare_inject_frame(PyX4M210 self, uint32_t num_frames, uint32_t num_bins, uint32_t mode)"""
        return _moduleconnectorwrapper.PyX4M210_prepare_inject_frame(self, num_frames, num_bins, mode)


    def system_run_test(self, testcode, data):
        """system_run_test(PyX4M210 self, uint8_t const testcode, ucVector data)"""
        return _moduleconnectorwrapper.PyX4M210_system_run_test(self, testcode, data)


    def load_profile(self, profileid):
        """load_profile(PyX4M210 self, uint32_t const profileid)"""
        return _moduleconnectorwrapper.PyX4M210_load_profile(self, profileid)


    def set_sensor_mode(self, mode, param):
        """set_sensor_mode(PyX4M210 self, uint8_t const mode, uint8_t const param)"""
        return _moduleconnectorwrapper.PyX4M210_set_sensor_mode(self, mode, param)


    def get_sensor_mode(self):
        """get_sensor_mode(PyX4M210 self) -> uint8_t"""
        return _moduleconnectorwrapper.PyX4M210_get_sensor_mode(self)


    def set_sensitivity(self, sensitivity):
        """set_sensitivity(PyX4M210 self, uint32_t const sensitivity)"""
        return _moduleconnectorwrapper.PyX4M210_set_sensitivity(self, sensitivity)


    def get_sensitivity(self):
        """get_sensitivity(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_sensitivity(self)


    def set_tx_center_frequency(self, frequency_band):
        """set_tx_center_frequency(PyX4M210 self, uint32_t const frequency_band)"""
        return _moduleconnectorwrapper.PyX4M210_set_tx_center_frequency(self, frequency_band)


    def get_tx_center_frequency(self):
        """get_tx_center_frequency(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_tx_center_frequency(self)


    def set_detection_zone(self, start, end):
        """set_detection_zone(PyX4M210 self, float const start, float const end)"""
        return _moduleconnectorwrapper.PyX4M210_set_detection_zone(self, start, end)


    def get_detection_zone(self):
        """get_detection_zone(PyX4M210 self) -> DetectionZone"""
        return _moduleconnectorwrapper.PyX4M210_get_detection_zone(self)


    def get_detection_zone_limits(self):
        """get_detection_zone_limits(PyX4M210 self) -> DetectionZoneLimits"""
        return _moduleconnectorwrapper.PyX4M210_get_detection_zone_limits(self)


    def set_led_control(self, mode, intensity):
        """set_led_control(PyX4M210 self, uint8_t const mode, uint8_t intensity)"""
        return _moduleconnectorwrapper.PyX4M210_set_led_control(self, mode, intensity)


    def get_led_control(self):
        """get_led_control(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_led_control(self)


    def set_output_control(self, output_feature, output_control):
        """set_output_control(PyX4M210 self, uint32_t output_feature, uint32_t output_control)"""
        return _moduleconnectorwrapper.PyX4M210_set_output_control(self, output_feature, output_control)


    def set_debug_output_control(self, output_feature, output_control):
        """set_debug_output_control(PyX4M210 self, uint32_t output_feature, uint32_t output_control)"""
        return _moduleconnectorwrapper.PyX4M210_set_debug_output_control(self, output_feature, output_control)


    def get_output_control(self, output_feature):
        """get_output_control(PyX4M210 self, uint32_t const output_feature) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_output_control(self, output_feature)


    def get_debug_output_control(self, output_feature):
        """get_debug_output_control(PyX4M210 self, uint32_t const output_feature) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_debug_output_control(self, output_feature)


    def peek_message_baseband_ap(self):
        """peek_message_baseband_ap(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_baseband_ap(self)


    def read_message_baseband_ap(self):
        """read_message_baseband_ap(PyX4M210 self) -> BasebandApData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_baseband_ap(self)


    def peek_message_baseband_iq(self):
        """peek_message_baseband_iq(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_baseband_iq(self)


    def read_message_baseband_iq(self):
        """read_message_baseband_iq(PyX4M210 self) -> BasebandIqData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_baseband_iq(self)


    def peek_message_respiration_legacy(self):
        """peek_message_respiration_legacy(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_respiration_legacy(self)


    def read_message_respiration_legacy(self):
        """read_message_respiration_legacy(PyX4M210 self) -> RespirationData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_respiration_legacy(self)


    def peek_message_respiration_sleep(self):
        """peek_message_respiration_sleep(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_respiration_sleep(self)


    def read_message_respiration_sleep(self):
        """read_message_respiration_sleep(PyX4M210 self) -> SleepData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_respiration_sleep(self)


    def peek_message_respiration_movinglist(self):
        """peek_message_respiration_movinglist(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_respiration_movinglist(self)


    def read_message_respiration_movinglist(self):
        """read_message_respiration_movinglist(PyX4M210 self) -> RespirationMovingListData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_respiration_movinglist(self)


    def peek_message_respiration_detectionlist(self):
        """peek_message_respiration_detectionlist(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_respiration_detectionlist(self)


    def read_message_respiration_detectionlist(self):
        """read_message_respiration_detectionlist(PyX4M210 self) -> RespirationDetectionListData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_respiration_detectionlist(self)


    def peek_message_respiration_normalizedmovementlist(self):
        """peek_message_respiration_normalizedmovementlist(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_respiration_normalizedmovementlist(self)


    def read_message_respiration_normalizedmovementlist(self):
        """read_message_respiration_normalizedmovementlist(PyX4M210 self) -> RespirationNormalizedMovementListData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_respiration_normalizedmovementlist(self)


    def peek_message_vital_signs(self):
        """peek_message_vital_signs(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_vital_signs(self)


    def read_message_vital_signs(self):
        """read_message_vital_signs(PyX4M210 self) -> VitalSignsData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_vital_signs(self)


    def peek_message_pulsedoppler_float(self):
        """peek_message_pulsedoppler_float(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_pulsedoppler_float(self)


    def read_message_pulsedoppler_float(self):
        """read_message_pulsedoppler_float(PyX4M210 self) -> PulseDopplerFloatData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_pulsedoppler_float(self)


    def peek_message_pulsedoppler_byte(self):
        """peek_message_pulsedoppler_byte(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_pulsedoppler_byte(self)


    def read_message_pulsedoppler_byte(self):
        """read_message_pulsedoppler_byte(PyX4M210 self) -> PulseDopplerByteData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_pulsedoppler_byte(self)


    def peek_message_noisemap_float(self):
        """peek_message_noisemap_float(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_noisemap_float(self)


    def read_message_noisemap_float(self):
        """read_message_noisemap_float(PyX4M210 self) -> PulseDopplerFloatData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_noisemap_float(self)


    def peek_message_noisemap_byte(self):
        """peek_message_noisemap_byte(PyX4M210 self) -> int"""
        return _moduleconnectorwrapper.PyX4M210_peek_message_noisemap_byte(self)


    def read_message_noisemap_byte(self):
        """read_message_noisemap_byte(PyX4M210 self) -> PulseDopplerByteData"""
        return _moduleconnectorwrapper.PyX4M210_read_message_noisemap_byte(self)


    def load_noisemap(self):
        """load_noisemap(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_load_noisemap(self)


    def store_noisemap(self):
        """store_noisemap(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_store_noisemap(self)


    def delete_noisemap(self):
        """delete_noisemap(PyX4M210 self)"""
        return _moduleconnectorwrapper.PyX4M210_delete_noisemap(self)


    def set_noisemap_control(self, noisemap_control):
        """set_noisemap_control(PyX4M210 self, uint32_t noisemap_control)"""
        return _moduleconnectorwrapper.PyX4M210_set_noisemap_control(self, noisemap_control)


    def get_noisemap_control(self):
        """get_noisemap_control(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_noisemap_control(self)


    def set_periodic_noisemap_store(self, interval_minutes, reserved):
        """set_periodic_noisemap_store(PyX4M210 self, uint32_t interval_minutes, uint32_t reserved)"""
        return _moduleconnectorwrapper.PyX4M210_set_periodic_noisemap_store(self, interval_minutes, reserved)


    def get_periodic_noisemap_store(self):
        """get_periodic_noisemap_store(PyX4M210 self) -> PeriodicNoisemapStore"""
        return _moduleconnectorwrapper.PyX4M210_get_periodic_noisemap_store(self)


    def get_parameter_file(self, filename):
        """get_parameter_file(PyX4M210 self, std::string const & filename) -> std::string"""
        return _moduleconnectorwrapper.PyX4M210_get_parameter_file(self, filename)


    def get_profileid(self):
        """get_profileid(PyX4M210 self) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_profileid(self)


    def set_parameter_file(self, filename, data):
        """set_parameter_file(PyX4M210 self, std::string const & filename, std::string const & data)"""
        return _moduleconnectorwrapper.PyX4M210_set_parameter_file(self, filename, data)


    def set_iopin_control(self, pin_id, pin_setup, pin_feature):
        """set_iopin_control(PyX4M210 self, uint32_t pin_id, uint32_t pin_setup, uint32_t pin_feature)"""
        return _moduleconnectorwrapper.PyX4M210_set_iopin_control(self, pin_id, pin_setup, pin_feature)


    def get_iopin_control(self, pin_id):
        """get_iopin_control(PyX4M210 self, uint32_t pin_id) -> IoPinControl"""
        return _moduleconnectorwrapper.PyX4M210_get_iopin_control(self, pin_id)


    def set_iopin_value(self, pin_id, pin_value):
        """set_iopin_value(PyX4M210 self, uint32_t pin_id, uint32_t pin_value)"""
        return _moduleconnectorwrapper.PyX4M210_set_iopin_value(self, pin_id, pin_value)


    def get_iopin_value(self, pin_id):
        """get_iopin_value(PyX4M210 self, uint32_t pin_id) -> uint32_t"""
        return _moduleconnectorwrapper.PyX4M210_get_iopin_value(self, pin_id)

PyX4M210_swigregister = _moduleconnectorwrapper.PyX4M210_swigregister
PyX4M210_swigregister(PyX4M210)

class PyX4M300(_object):
    """


    C++ includes: PyX4M300.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyX4M300, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyX4M300, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface):
        """
        __init__(XeThru::PyX4M300 self, LockedRadarInterfacePtr & radar_interface) -> PyX4M300



        """
        this = _moduleconnectorwrapper.new_PyX4M300(radar_interface)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyX4M300
    __del__ = lambda self: None

    def set_baudrate(self, baudrate):
        """
        set_baudrate(PyX4M300 self, uint32_t baudrate)



        Set baudrate for serial communication during ModuleConnector operation.  

        Parameters
        ----------
        * `baudrate` :  
            enum representing the baudrate e.g
            moduleconnectorwrapper.XTID_BAUDRATE_115200.  

        """
        return _moduleconnectorwrapper.PyX4M300_set_baudrate(self, baudrate)


    def set_debug_level(self, level):
        """
        set_debug_level(PyX4M300 self, unsigned char level)



        Sets debug level in the Xethru module.  

        Parameters
        ----------
        * `level` :  
            New debug level. Legal range [0-9].  

        """
        return _moduleconnectorwrapper.PyX4M300_set_debug_level(self, level)


    def ping(self):
        """
        ping(PyX4M300 self) -> uint32_t



        Make sure there is a connection to FW on the Xethru X4M200 module.  

        Returns
        -------
        pong: 0xaaeeaeea means system ready and 0xaeeaeeaa means system not ready  

        """
        return _moduleconnectorwrapper.PyX4M300_ping(self)


    def get_system_info(self, info_code):
        """
        get_system_info(PyX4M300 self, uint8_t const info_code) -> std::string



        Returns a string containing system information given by infocode:  

        XTID_SSIC_ITEMNUMBER = 0x00 -> Returns the internal Novelda PCBA Item Number,
        including revision. This is programmed in Flash during manufacturing
        XTID_SSIC_ORDERCODE = 0x01 -> Returns the PCBA / PCBA stack order code.
        XTID_SSIC_FIRMWAREID = 0x02 -> Returns the installed Firmware ID. As viewed from
        the "highest" level of the software, "X4M300". XTID_SSIC_VERSION = 0x03 ->
        Returns the installed Firmware Version. As viewed from the "highest" level of
        the software. XTID_SSIC_BUILD = 0x04 -> Returns information of the SW Build
        installed on the device XTID_SSIC_SERIALNUMBER = 0x06 -> Returns the PCBA serial
        number XTID_SSIC_VERSIONLIST = 0x07 -> Returns ID and version of all components.
        Calls all components and compound a string. E.g.
        "X4M300:1.0.0.3;XEP:2.3.4.5;X4C51:1.0.0.0;DSP:1.1.1.1"  

        """
        return _moduleconnectorwrapper.PyX4M300_get_system_info(self, info_code)


    def module_reset(self):
        """
        module_reset(PyX4M300 self)



        Resets and restart the module.  

        The client must perform a close and then an open on the ModuleConnector to
        reeastablish connection.  

        """
        return _moduleconnectorwrapper.PyX4M300_module_reset(self)


    def reset(self):
        """
        reset(PyX4M300 self) -> int



        Resets and restart the module.  

        This method automatically reestablishes.  

        """
        return _moduleconnectorwrapper.PyX4M300_reset(self)


    def reset_to_factory_preset(self):
        """
        reset_to_factory_preset(PyX4M300 self)



        Resets all parameters in the module to factory presets.  

        """
        return _moduleconnectorwrapper.PyX4M300_reset_to_factory_preset(self)


    def start_bootloader(self):
        """
        start_bootloader(PyX4M300 self)



        Enters the bootloader for FW upgrades.  

        """
        return _moduleconnectorwrapper.PyX4M300_start_bootloader(self)


    def inject_frame(self, frame_counter, frame_length, frame):
        """
        inject_frame(PyX4M300 self, uint32_t frame_counter, uint32_t frame_length, FloatVector frame)



        Injects a radar frame.  

        Parameters
        ----------
        * `frame_counter` :  
            Frame counter of frame.  
        * `frame_length` :  
            Number of bins in the frame.  
        * `frame` :  
            The frame data to inject.  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyX4M300_inject_frame(self, frame_counter, frame_length, frame)


    def prepare_inject_frame(self, num_frames, num_bins, mode):
        """
        prepare_inject_frame(PyX4M300 self, uint32_t num_frames, uint32_t num_bins, uint32_t mode)



        Prepare for injection of radar frame(s).  

        Parameters
        ----------
        * `num_frame` :  
            Number of frame to inject  
        * `num_bins` :  
            Number of bins in each frame.  
        * `mode` :  
            The frame injection mode: LOOP, SEQUENTIAL, SINGLE  

        Returns
        -------
        execution status  

        """
        return _moduleconnectorwrapper.PyX4M300_prepare_inject_frame(self, num_frames, num_bins, mode)


    def system_run_test(self, testcode, data):
        """
        system_run_test(PyX4M300 self, uint8_t const testcode, ucVector data) -> int



        Runs the different manufacturing tests identified by testcode.  

        Can return any number of results depending on test_mode. Host must know how to
        parse test results.  

        Parameters
        ----------
        * `testcode` :  
        * `data` :  
            data buffer containing the result from a test run.  

        """
        return _moduleconnectorwrapper.PyX4M300_system_run_test(self, testcode, data)


    def load_profile(self, profileid):
        """
        load_profile(PyX4M300 self, uint32_t const profileid)



        Loads the presence profile.  

        If another profile is loaded, the other profile is unloaded before the new
        profile is loaded. The profile does not start, the module remains idle.  

        Parameters
        ----------
        * `profileid` :  
            the id of the profile to load profileid = XTS_ID_APP_PRESENCE_2 : presence
            profile  

        """
        return _moduleconnectorwrapper.PyX4M300_load_profile(self, profileid)


    def set_sensor_mode(self, mode, param):
        """
        set_sensor_mode(PyX4M300 self, uint8_t const mode, uint8_t const param)



        Control the execution mode of the sensor.  

        Parameters
        ----------
        * `mode` :  

             XTID_SM_RUN : Start profile execution  
             XTID_SM_IDLE : Halts profile execution. Can be resumed by setting mode to
            Run.  
             XTID_SM_STOP : Stops profile execution. Must do load_profile to continue.  
             XTID_SM_MANUAL : Routes X4 radar data directly to host rather than to
            profile execution. Can then interact directly with XEP / X4Driver. Will
            disrupt profile performance.  
        * `param` :  
            Not used, ignored, can be 0.  

        """
        return _moduleconnectorwrapper.PyX4M300_set_sensor_mode(self, mode, param)


    def get_sensor_mode(self):
        """
        get_sensor_mode(PyX4M300 self) -> uint8_t



        """
        return _moduleconnectorwrapper.PyX4M300_get_sensor_mode(self)


    def set_sensitivity(self, sensitivity):
        """
        set_sensitivity(PyX4M300 self, uint32_t const sensitivity)



        Sets the overall sensitivity.  

        Parameters
        ----------
        * `sensitivity` :  
            : 0 to 9, 0 = low, 9 = high  

        """
        return _moduleconnectorwrapper.PyX4M300_set_sensitivity(self, sensitivity)


    def get_sensitivity(self):
        """
        get_sensitivity(PyX4M300 self) -> uint32_t



        Gets the overall sensitivity.  

        Returns
        -------
        sensitivity : 0 to 9, 0 = low, 9 = high  

        """
        return _moduleconnectorwrapper.PyX4M300_get_sensitivity(self)


    def set_tx_center_frequency(self, frequency_band):
        """
        set_tx_center_frequency(PyX4M300 self, uint32_t const frequency_band)



        Sets TX center frequency.  

        Parameters
        ----------
        * `frequency_band` :  
            : 3 for low band, 4 for high band  

        """
        return _moduleconnectorwrapper.PyX4M300_set_tx_center_frequency(self, frequency_band)


    def get_tx_center_frequency(self):
        """
        get_tx_center_frequency(PyX4M300 self) -> uint32_t



        Gets TX center frequency.  

        Returns
        -------
        frequency_band : 3 for low band, 4 for high band  

        """
        return _moduleconnectorwrapper.PyX4M300_get_tx_center_frequency(self)


    def set_detection_zone(self, start, end):
        """
        set_detection_zone(PyX4M300 self, float const start, float const end)



        Sets the current detection zone.  

        Rules: See datasheet. The actual detection zone is determined by radar settings.
        Use the get_detection_zone command to get the actual values  

        Parameters
        ----------
        * `start` :  
        * `end` :  

        """
        return _moduleconnectorwrapper.PyX4M300_set_detection_zone(self, start, end)


    def get_detection_zone(self):
        """
        get_detection_zone(PyX4M300 self) -> DetectionZone



        Returns the actual range window.  

        Returns
        -------
        DetectionZone:  

        """
        return _moduleconnectorwrapper.PyX4M300_get_detection_zone(self)


    def get_detection_zone_limits(self):
        """
        get_detection_zone_limits(PyX4M300 self) -> DetectionZoneLimits



        Returns the potential settings of detection zone from the module.  

        Returns
        -------
        DetectionZoneLimits:  

        """
        return _moduleconnectorwrapper.PyX4M300_get_detection_zone_limits(self)


    def set_led_control(self, mode, intensity):
        """
        set_led_control(PyX4M300 self, uint8_t const mode, uint8_t intensity)



        This command configures the LED mode.  



        Parameters
        ----------
        * `mode` :  
            (modes are defined in xtid.h)  
             mode = XTID_LED_MODE_OFF : OFF  
             mode = XTID_LED_MODE_SIMPLE : simple  
             mode = XTID_LED_MODE_FULL : full (default)  
        * `intensity` :  
            0 to 100, 0=low, 100=high, not implemented yet  

        """
        return _moduleconnectorwrapper.PyX4M300_set_led_control(self, mode, intensity)


    def get_led_control(self):
        """
        get_led_control(PyX4M300 self) -> uint32_t



        Gets LED mode mode = XTID_LED_MODE_OFF : OFF  
         mode = XTID_LED_MODE_SIMPLE : simple  
         mode = XTID_LED_MODE_FULL : full (default)  
         *.  

        Returns
        -------
        mode  

        """
        return _moduleconnectorwrapper.PyX4M300_get_led_control(self)


    def set_output_control(self, output_feature, output_control):
        """
        set_output_control(PyX4M300 self, uint32_t output_feature, uint32_t output_control)



        Control module profile output.  

        Enable and disable data messages. Several calls can be made, one for each
        available output message the profile provides.  

        Only one of XTS_ID_BASEBAND_IQ and XTS_ID_BASEBAND_AMPLITUDE_PHASE can be
        enabled at a time. Enabling one disables the other. Disabling one, even if it is
        already disabled, disables the other.  

        Only one of XTS_ID_PULSEDOPPLER_FLOAT and XTS_ID_PULSEDOPPLER_BYTE can be
        enabled for each of XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE and
        XTID_OUTPUT_CONTROL_PD_FAST_ENABLE. Same with XTS_ID_NOISEMAP_FLOAT and
        XTS_ID_NOISEMAP_BYTE. Turning on a float output automatically disables the byte
        output, and vice versa.  

        Parameters
        ----------
        * `output_feature` :  
            see values in xtid.h.  
             Possible features are:  
             XTS_ID_PRESENCE_SINGLE,  
             XTS_ID_PRESENCE_MOVINGLIST,  
             XTS_ID_BASEBAND_IQ,  
             XTS_ID_BASEBAND_AMPLITUDE_PHASE,  
             XTS_ID_PULSEDOPPLER_FLOAT,  
             XTS_ID_PULSEDOPPLER_BYTE,  
             XTS_ID_NOISEMAP_FLOAT and  
             XTS_ID_NOISEMAP_BYTE  
        * `output_control` :  
            see values in xtid.h.  
             Typical values:  
             XTID_OUTPUT_CONTROL_DISABLE = disable,  
             XTID_OUTPUT_CONTROL_ENABLE = enable.  
             For pulse-Doppler and noisemap byte/float:  
             XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE  
             XTID_OUTPUT_CONTROL_PD_FAST_ENABLE  

        """
        return _moduleconnectorwrapper.PyX4M300_set_output_control(self, output_feature, output_control)


    def set_debug_output_control(self, output_feature, output_control):
        """
        set_debug_output_control(PyX4M300 self, uint32_t output_feature, uint32_t output_control)



        """
        return _moduleconnectorwrapper.PyX4M300_set_debug_output_control(self, output_feature, output_control)


    def get_output_control(self, output_feature):
        """
        get_output_control(PyX4M300 self, uint32_t const output_feature) -> uint32_t



        """
        return _moduleconnectorwrapper.PyX4M300_get_output_control(self, output_feature)


    def get_debug_output_control(self, output_feature):
        """
        get_debug_output_control(PyX4M300 self, uint32_t const output_feature) -> uint32_t



        """
        return _moduleconnectorwrapper.PyX4M300_get_debug_output_control(self, output_feature)


    def peek_message_presence_single(self):
        """
        peek_message_presence_single(PyX4M300 self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_presence_single(self)


    def read_message_presence_single(self):
        """
        read_message_presence_single(PyX4M300 self) -> PresenceSingleData



        Read a single PresenceSingleData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        presence_single:  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_presence_single(self)


    def peek_message_presence_movinglist(self):
        """
        peek_message_presence_movinglist(PyX4M300 self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_presence_movinglist(self)


    def read_message_presence_movinglist(self):
        """
        read_message_presence_movinglist(PyX4M300 self) -> PresenceMovingListData



        Read a single PresenceMovingList item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        presence_moving_list:  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_presence_movinglist(self)


    def peek_message_baseband_ap(self):
        """
        peek_message_baseband_ap(PyX4M300 self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_baseband_ap(self)


    def read_message_baseband_ap(self):
        """
        read_message_baseband_ap(PyX4M300 self) -> BasebandApData



        Read a single BasebandApData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        baseband_ap:  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_baseband_ap(self)


    def peek_message_baseband_iq(self):
        """
        peek_message_baseband_iq(PyX4M300 self) -> int



        Return number of messages available.  

        Returns
        -------
        : size: number og messages in buffer  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_baseband_iq(self)


    def read_message_baseband_iq(self):
        """
        read_message_baseband_iq(PyX4M300 self) -> BasebandIqData



        Read a single BasebandIqData item from the queue.  

        Blocks if queue is empty.  

        Returns
        -------
        baseband_qi:  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_baseband_iq(self)


    def peek_message_pulsedoppler_float(self):
        """
        peek_message_pulsedoppler_float(PyX4M300 self) -> int



        Return number of pulse-Doppler float packets available in the queue.  

        Returns
        -------
        size: number og messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_pulsedoppler_float(self)


    def read_message_pulsedoppler_float(self):
        """
        read_message_pulsedoppler_float(PyX4M300 self) -> PulseDopplerFloatData



        Get one pulse-Doppler float data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting pulse-Doppler float data  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_pulsedoppler_float(self)


    def peek_message_pulsedoppler_byte(self):
        """
        peek_message_pulsedoppler_byte(PyX4M300 self) -> int



        Return number of pulse-Doppler byte packets available in the queue.  

        Returns
        -------
        size: number og messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_pulsedoppler_byte(self)


    def read_message_pulsedoppler_byte(self):
        """
        read_message_pulsedoppler_byte(PyX4M300 self) -> PulseDopplerByteData



        Get one pulse-Doppler byte data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting pulse-Doppler float data  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_pulsedoppler_byte(self)


    def peek_message_noisemap_float(self):
        """
        peek_message_noisemap_float(PyX4M300 self) -> int



        Return number of noisemap float packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_noisemap_float(self)


    def read_message_noisemap_float(self):
        """
        read_message_noisemap_float(PyX4M300 self) -> PulseDopplerFloatData



        Get one noisemap float data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting noisemap float data  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_noisemap_float(self)


    def peek_message_noisemap_byte(self):
        """
        peek_message_noisemap_byte(PyX4M300 self) -> int



        Return number of noisemap byte packets available in the queue.  

        Returns
        -------
        size: number of messages in queue  

        """
        return _moduleconnectorwrapper.PyX4M300_peek_message_noisemap_byte(self)


    def read_message_noisemap_byte(self):
        """
        read_message_noisemap_byte(PyX4M300 self) -> PulseDopplerByteData



        Get one noisemap byte data message from subscription queue.  

        Returns
        -------
        : A data object holding the resulting noisemap byte data  

        """
        return _moduleconnectorwrapper.PyX4M300_read_message_noisemap_byte(self)


    def load_noisemap(self):
        """
        load_noisemap(PyX4M300 self)



        Send command to module to load a previously stored noisemap.  

        Not yet functional as of FW 1.3  

        """
        return _moduleconnectorwrapper.PyX4M300_load_noisemap(self)


    def store_noisemap(self):
        """
        store_noisemap(PyX4M300 self)



        Send command to module to store the current noisemap to module flash.  

        Fails if a store already is active, for example during the first initialize with
        XTID_NOISEMAP_CONTROL_INIT_ON_RESET disabled.  

        """
        return _moduleconnectorwrapper.PyX4M300_store_noisemap(self)


    def delete_noisemap(self):
        """
        delete_noisemap(PyX4M300 self)



        Send command to module to delete stored noisemap from module flash.  

        Fails in case of flash access issues.  

        """
        return _moduleconnectorwrapper.PyX4M300_delete_noisemap(self)


    def set_noisemap_control(self, noisemap_control):
        """
        set_noisemap_control(PyX4M300 self, uint32_t noisemap_control)



        Configure the use of noisemap.  

        Parameters
        ----------
        * `noisemap_control` :  
            A bitfield of the various features.  

            *   Use Stored Noise Map
                -   On - XTID_NOISEMAP_CONTROL_USE_STORED
                    -   If a valid Stored Noise Map exists this will be used at reset or
                        when the Profile is started.  
                    -   If no valid Stored Noise Map exists and Use Default Noise Map is
                        off, a new Noise Map will be created during Initialization
                        state. The newly created Noise Map will be stored in the sensor
                        when Initialization is done. A noise map created with a
                        different Detection Zone is not valid.  
                    -   If no valid Stored Noise Map exists and Use Default Noise Map is
                        on, the Default Noise Map will be used at reset or when the
                        Profile is started.  
                -   Off - XTID_NOISEMAP_CONTROL_INIT_ON_RESET
                    -   If Use Default Noise Map is off, a new Noise Map will always be
                        created at reset or when the Profile is started. Sensor will be
                        in Initialization state during Noise Map creation. A previously
                        Stored Noise Map in the sensor will be ignored, but not
                        overwritten, when the Profile starts.  
                    -   If Use Default Noise Map is on, the Default Noise Map will be
                        used at reset or when the Profile is started.  
            *   Use Default Noise Map
                -   On - XTID_NOISEMAP_CONTROL_USE_DEFAULT / DISABLE
                    -   If Use Store Noise Map is on and a valid Stored Noise Map
                        exists, Default Noise Map will not be used.  
                    -   If Use Stored Noise Map is on and no valid Stored Noise Map
                        exists, the Default Noise Map will be used at reset or when the
                        Profile is started.  
                    -   If Use Stored Noise Map is off, the Default Noise Map will be
                        used at reset or when the Profile is started.  
                -   Off - XTID_NOISEMAP_CONTROL_ENABLE
                    -   The Default Noise Map will not be used.  
            *   Adaptive Noise Map
                -   On - XTID_NOISEMAP_CONTROL_ADAPTIVE
                    -   Enables Noise Map adaptation. Noise Map will still not adapt in
                        certain conditions as described in Firmware Algorithms section
                        below.  
                -   Off - XTID_NOISEMAP_CONTROL_NONADAPTIVE
                    -   Disables Noise Map adaptation (not implemented).  

        """
        return _moduleconnectorwrapper.PyX4M300_set_noisemap_control(self, noisemap_control)


    def get_noisemap_control(self):
        """
        get_noisemap_control(PyX4M300 self) -> uint32_t



        Get current noisemap configuration.  

        Returns
        -------
        noisemap_control : A bitfield of the various features.  

        """
        return _moduleconnectorwrapper.PyX4M300_get_noisemap_control(self)


    def set_periodic_noisemap_store(self, interval_minutes, reserved):
        """
        set_periodic_noisemap_store(PyX4M300 self, uint32_t interval_minutes, uint32_t reserved)



        Set interval for periodoc storing of noisemap.  

        Parameters
        ----------
        * `interval_minutes` :  
            Interval for storing moisemap  
        * `reserved` :  
            Reserved for future use, must be set to 0.  

        """
        return _moduleconnectorwrapper.PyX4M300_set_periodic_noisemap_store(self, interval_minutes, reserved)


    def get_periodic_noisemap_store(self):
        """
        get_periodic_noisemap_store(PyX4M300 self) -> PeriodicNoisemapStore



        Get interval for periodoc storing of noisemap.  

        Parameters
        ----------
        * `interval_minutes` :  
            Interval for storing moisemap  
        * `reserved` :  
            Reserved for future use, must be set to 0.  

        """
        return _moduleconnectorwrapper.PyX4M300_get_periodic_noisemap_store(self)


    def get_parameter_file(self, filename):
        """
        get_parameter_file(PyX4M300 self, std::string const & filename) -> std::string



        Read the complete parameter file from the module.  

        Returns
        -------
        a string containing the complete paramter file data  

        """
        return _moduleconnectorwrapper.PyX4M300_get_parameter_file(self, filename)


    def get_profileid(self):
        """
        get_profileid(PyX4M300 self) -> uint32_t



        Get the id of the currently loaded profile.  

        Returns
        -------
        profileid: the id of the loaded profile or 0 in case of no loaded profile.  

        """
        return _moduleconnectorwrapper.PyX4M300_get_profileid(self)


    def set_parameter_file(self, filename, data):
        """
        set_parameter_file(PyX4M300 self, std::string const & filename, std::string const & data)



        Set a named parameter file on target.  

        Parameters
        ----------
        * `filename` :  
            The name to call the parameter file.  
        * `data` :  
            The content of the parameter-file.  

        """
        return _moduleconnectorwrapper.PyX4M300_set_parameter_file(self, filename, data)


    def set_iopin_control(self, pin_id, pin_setup, pin_feature):
        """
        set_iopin_control(PyX4M300 self, uint32_t pin_id, uint32_t pin_setup, uint32_t pin_feature)



        Configures GPIO pin.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the IO pin to configure. pin_id = 0 means all IO pins.  
        * `pin_setup` :  
            Specifies the direction and drive of the IO pin. bit 0: input = 0, output =
            1 bit 1: open-drain = 0, push-pull = 1 bit 2: active-high = 0, active-low =
            1 bit 3: no pull-up = 0, pull-up = 1  
        * `pin_feature` :  
            Specifies the configuration of the IO pin. 0 = Disable all iopin features. 1
            = Configure according to datasheet default. This overrides pin_setup. 2 =
            Passive, set and get iopin level from host. 3 = Presence, see X4M300
            datasheet for details.  

        See also: get_iopin_value  

        """
        return _moduleconnectorwrapper.PyX4M300_set_iopin_control(self, pin_id, pin_setup, pin_feature)


    def get_iopin_control(self, pin_id):
        """
        get_iopin_control(PyX4M300 self, uint32_t pin_id) -> IoPinControl



        Gets the GPIO pin configuration.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the io pin to get.  

        Returns
        -------
        : A data object holding the pin configuration  

        See also: set_iopin_contron  

        """
        return _moduleconnectorwrapper.PyX4M300_get_iopin_control(self, pin_id)


    def set_iopin_value(self, pin_id, pin_value):
        """
        set_iopin_value(PyX4M300 self, uint32_t pin_id, uint32_t pin_value)



        Sets GPIO pin value.  

        Parameters
        ----------
        * `pin_id` :  
            Specifies the pin.  
        * `pin_value` :  
            Specifies the value.  

        note: Pin must be configured as output pin.  

        See also: set_iopin_control  

        """
        return _moduleconnectorwrapper.PyX4M300_set_iopin_value(self, pin_id, pin_value)


    def get_iopin_value(self, pin_id):
        """
        get_iopin_value(PyX4M300 self, uint32_t pin_id) -> uint32_t



        Gets GPIO pin value.  

        See also: set_iopin_value  

        """
        return _moduleconnectorwrapper.PyX4M300_get_iopin_value(self, pin_id)

PyX4M300_swigregister = _moduleconnectorwrapper.PyX4M300_swigregister
PyX4M300_swigregister(PyX4M300)

class PyDataRecorder(_object):
    """


    The DataRecorder class allows recording of xethru data types.  

    The DataRecorder class is a high level recorder class. It can be used to record
    all data types sent by a xethru device over serial port or similar. All low-
    level I/O is handled by the recorder itself with no setup required. Data is
    stored on disk as specified by the XeThru File Formats document and can be
    easily read back using the *DataReader* class.  

    @snippet record.py Typical usage  

    note: The DataRecorder has no means to enable or disable data output on a
        physical xethru device. It simply records the specified data type(s) if sent
        by the module. Therefore, it is the user's responsibility to enable or
        disable data ouput on the module itself. If no data is sent, no data will be
        recorded.  

    DataRecorder also supports more advance *RecordingOptions* such as splitting of
    files and directories.  

    See also: start_recording RecordingOptions DataReader.  

    C++ includes: PyDataRecorder.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyDataRecorder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyDataRecorder, name)
    __repr__ = _swig_repr

    def __init__(self, radar_interface):
        """
        __init__(XeThru::PyDataRecorder self, LockedRadarInterfacePtr & radar_interface) -> PyDataRecorder



        Constructs recorder.  

        """
        this = _moduleconnectorwrapper.new_PyDataRecorder(radar_interface)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyDataRecorder
    __del__ = lambda self: None

    def start_recording(self, *args):
        """
        start_recording(PyDataRecorder self, XeThru::DataTypes data_types, std::string const & directory, RecordingOptions options) -> int
        start_recording(PyDataRecorder self, XeThru::DataTypes data_types, std::string const & directory) -> int



        Starts recording the specified data type(s) and output recorded files to the
        directory specified.  

        This command does not enable data output on the module.  

        Parameters
        ----------
        * `data_types` :  
            DataTypes is a bitmask that consists of a combination of DataType flags.
            These flags can be combined with the bitwise OR operator (|). For example:
            BasebandIqData | SleepData. A convenience value AllDataTypes can also be
            specified.  
        * `directory` :  
            Output folder where recorded files will be stored.  
        * `options` :  
            Specifies advanced options such as splitting of files and directories. By
            default, this parameter is RecordingOptions() (no advanced options).  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: RecordingOptions, stop_recording  

        """
        return _moduleconnectorwrapper.PyDataRecorder_start_recording(self, *args)


    def stop_recording(self, data_types):
        """
        stop_recording(PyDataRecorder self, XeThru::DataTypes data_types)



        Stops recording the specified data type(s).  

        This command does not disable data output on the module.  

        Parameters
        ----------
        * `data_types` :  
            DataTypes is a bitmask that consists of a combination of DataType flags.
            These flags can be combined with the bitwise OR operator (|). For example:
            BasebandIqData | SleepData. A convenience value AllDataTypes can also be
            specified.  

        See also: start_recording  

        """
        return _moduleconnectorwrapper.PyDataRecorder_stop_recording(self, data_types)


    def is_recording(self, data_type):
        """
        is_recording(PyDataRecorder self, uint32_t data_type) -> bool



        Returns
        -------
        true if recording is started for the specified data type, otherwise returns
        false  

        See also: start_recording  

        """
        return _moduleconnectorwrapper.PyDataRecorder_is_recording(self, data_type)


    def process(self, data_type, data):
        """
        process(PyDataRecorder self, uint32_t data_type, ucVector data) -> bool



        This function should not be used when recording data from a physical xethru
        device.  

        It is only relevant for recording data generated elsewhere. Most users will not
        need this functionality.  

        Process the specified data for a given data type.  

        Parameters
        ----------
        * `data_type` :  
            Specifies the data type to process  
        * `data` :  
            Specifies the bytes to process  

        Returns
        -------
        true on success, otherwise returns false  

        """
        return _moduleconnectorwrapper.PyDataRecorder_process(self, data_type, data)


    def unsubscribe_to_file_available(self, data_types):
        """
        unsubscribe_to_file_available(PyDataRecorder self, XeThru::DataTypes data_types)



        Unsubscribes to notifications when a recorded file for a data type is available.  

        Parameters
        ----------
        * `data_types` :  
            DataTypes is a bitmask that consists of a combination of DataType flags.
            These flags can be combined with the bitwise OR operator (|). For example:
            BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can
            also be specified.  

        See also: subscribe_to_file_available  

        """
        return _moduleconnectorwrapper.PyDataRecorder_unsubscribe_to_file_available(self, data_types)


    def unsubscribe_to_meta_file_available(self):
        """
        unsubscribe_to_meta_file_available(PyDataRecorder self) -> int



        Unsubscribes to notifications when a meta file is available.  

        See also: subscribe_to_meta_file_available  

        """
        return _moduleconnectorwrapper.PyDataRecorder_unsubscribe_to_meta_file_available(self)


    def set_basename_for_data_type(self, data_type, name):
        """
        set_basename_for_data_type(PyDataRecorder self, uint32_t data_type, std::string const & name)



        Sets the basename for the specified data type.  

        Most users will not need this functionality.  

        Parameters
        ----------
        * `data_type` :  
            Specifies the data type  
        * `name` :  
            Specifies the name  

        See also: get_basename_for_data_type, clear_basename_for_data_types  

        """
        return _moduleconnectorwrapper.PyDataRecorder_set_basename_for_data_type(self, data_type, name)


    def get_basename_for_data_type(self, data_type):
        """
        get_basename_for_data_type(PyDataRecorder self, uint32_t data_type) -> std::string



        Gets the basename for the specified data type.  

        Most users will not need this functionality.  

        Parameters
        ----------
        * `data_type` :  
            Specifies the data type.  

        Returns
        -------
        the basename for the specified data type  

        See also: set_basename_for_data_type  

        """
        return _moduleconnectorwrapper.PyDataRecorder_get_basename_for_data_type(self, data_type)


    def clear_basename_for_data_types(self, data_types):
        """
        clear_basename_for_data_types(PyDataRecorder self, XeThru::DataTypes data_types)



        Resets the basename(s) to default value(s) for the specified data type(s).  

        Most users will not need this functionality.  

        Parameters
        ----------
        * `data_types` :  
            DataTypes is a bitmask that consists of a combination of DataType flags.
            These flags can be combined with the bitwise OR operator (|). For example:
            BasebandIqData | SleepData. A convenience value AllDataTypes can also be
            specified.  

        See also: set_basename_for_data_type  

        """
        return _moduleconnectorwrapper.PyDataRecorder_clear_basename_for_data_types(self, data_types)


    def get_recording_directory(self, *args):
        """
        get_recording_directory(PyDataRecorder self, std::string const & session_id) -> std::string
        get_recording_directory(PyDataRecorder self, uint32_t data_type) -> std::string



        Gets the output folder for the specified data type.  

        The folder is relative to the directory specified in start_recording.  

        Parameters
        ----------
        * `session_id` :  
            Specifies the data type.  

        Returns
        -------
        the output folder if a recording for the given data type is active, otherwise
        returns an empty string.  

        See also: is_recording  

        """
        return _moduleconnectorwrapper.PyDataRecorder_get_recording_directory(self, *args)


    def data_type_to_string(data_type):
        """
        data_type_to_string(uint32_t data_type) -> std::string



        Convenience method for converting data type to human readable string
        representation.  

        Parameters
        ----------
        * `data_type` :  

        Returns
        -------
        the string representation of the specified data type  

        """
        return _moduleconnectorwrapper.PyDataRecorder_data_type_to_string(data_type)

    data_type_to_string = staticmethod(data_type_to_string)

    def subscribe_to_file_available(self, *args):
        """
        subscribe_to_file_available(PyDataRecorder self, XeThru::DataTypes data_types, XeThru::PyDataRecorder::FileAvailableCallback const & callback) -> int
        subscribe_to_file_available(PyDataRecorder self, uint32_t data_type, PyObject * callback) -> int



        Subscribes to notifications when a recorded file for a data type is available.  

        The callback is triggered when a new file is stored on disk, i.e. when module
        connector is done with the file and no longer will perform I/O operations on it.
        This usually triggers when recording is stopped or as a result of file
        splitting. In either case module connector will no longer hold any reference to
        the file.  

        Declare a standard function:  

        @snippet record.py Callback declare  

        Then construct the callback and pass as parameter:  

        @snippet record.py Callback subscribe  

        Parameters
        ----------
        * `data_types` :  
            DataTypes is a bitmask that consists of a combination of DataType flags.
            These flags can be combined with the bitwise OR operator (|). For example:
            BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can
            also be specified.  
        * `callback` :  
            Specifies the function to be called when a recorded file is available.  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: start_recording, unsubscribe_to_file_available, FileAvailableCallback  

        """
        return _moduleconnectorwrapper.PyDataRecorder_subscribe_to_file_available(self, *args)


    def subscribe_to_meta_file_available(self, *args):
        """
        subscribe_to_meta_file_available(PyDataRecorder self, XeThru::PyDataRecorder::MetaFileAvailableCallback const & callback) -> int
        subscribe_to_meta_file_available(PyDataRecorder self, PyObject * callback) -> int



        Subscribes to notifications when a meta file is available.  

        The callback is triggered when a new meta file is stored on disk, i.e. when
        module connector is done with the file and no longer perform I/O operations on
        it. This usually triggers when recording is stopped or as a result of
        file/directory splitting. In either case module connector will no longer hold
        any reference to the file.  

        The meta file contains detailed information about a particular recording
        session. For example which data types and files were written during the session.
        This information is possible to extract via *DataReader* and allows for
        convenient readback of data from disk. The meta file is only intended for use
        with *DataReader*.  

        Declare a standard function:  

        @snippet record.py Callback meta declare  

        Then construct the callback and pass as parameter:  

        @snippet record.py Callback meta subscribe  

        Parameters
        ----------
        * `callback` :  
            Specifies the function to be called when a meta file is available. For
            example: void on_meta_file_available(const std::string &session_id, const
            std::string &filename)  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: DataReader, start_recording, unsubscribe_to_meta_file_available,
            subscribe_to_file_available  

        """
        return _moduleconnectorwrapper.PyDataRecorder_subscribe_to_meta_file_available(self, *args)


    def set_error_callback(self, *args):
        """
        set_error_callback(PyDataRecorder self, XeThru::PyDataRecorder::RecordingErrorCallback callback)
        set_error_callback(PyDataRecorder self, PyObject * callback)



        Supply a function that will be called if an error occurs during recording.  

        Call this method with nullptr as argument to clear the callback.  

        """
        return _moduleconnectorwrapper.PyDataRecorder_set_error_callback(self, *args)

PyDataRecorder_swigregister = _moduleconnectorwrapper.PyDataRecorder_swigregister
PyDataRecorder_swigregister(PyDataRecorder)

def PyDataRecorder_data_type_to_string(data_type):
    """
    PyDataRecorder_data_type_to_string(uint32_t data_type) -> std::string



    Convenience method for converting data type to human readable string
    representation.  

    Parameters
    ----------
    * `data_type` :  

    Returns
    -------
    the string representation of the specified data type  

    """
    return _moduleconnectorwrapper.PyDataRecorder_data_type_to_string(data_type)

class PyDataReader(_object):
    """


    The PyDataReader class allows reading of xethru data records from a recording.  

    The PyDataReader class is a high level reader class. It can be used to read all
    data records stored on disk by the *DataRecorder* class. From the user's point
    of view the recording appears as one big file even if the recording may contain
    several files and folders on disk.  

    Data returned from this class is always aligned on complete data records as
    specified by the Xethru File Formats document for a given DataType.  

    @snippet read_recording.py Typical usage  

    note: Use *xethru_recording_meta.dat* as input argument to open. This file
        contains all required information for a particular recording.  

    See also: PyDataRecorder  

    C++ includes: PyDataReader.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyDataReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyDataReader, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(XeThru::PyDataReader self) -> PyDataReader



        Constructs reader.  

        """
        this = _moduleconnectorwrapper.new_PyDataReader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyDataReader
    __del__ = lambda self: None

    def open(self, meta_filename, depth=-1):
        """
        open(PyDataReader self, std::string const & meta_filename, int depth=-1) -> int
        open(PyDataReader self, std::string const & meta_filename) -> int



        Opens a recording specified by the given meta filename.  

        One recording may contain several meta files, for example as a result of
        file/directory splitting. The meta file contains information about which files
        and data types were written to disk during a recording session. Common for all
        use cases is that *xethru_recording_meta.dat* is always present in the output
        folder generated by *DataRecorder*. Use that file as input argument to this
        function.  

        Parameters
        ----------
        * `meta_filename` :  
            Specifies which recording (*xethru_recording_meta.dat*) to open  
        * `depth` :  
            Specifies the number of meta files to open in 'chained mode'. By default,
            this parameter is -1 (automatically open all files, i.e. the entire
            recording).  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: read_record  

        """
        return _moduleconnectorwrapper.PyDataReader_open(self, meta_filename, depth)


    def is_open(self):
        """
        is_open(PyDataReader self) -> bool



        Returns
        -------
        true if the recording is successfully opened, otherwise returns false  

        See also: open  

        """
        return _moduleconnectorwrapper.PyDataReader_is_open(self)


    def close(self):
        """
        close(PyDataReader self)



        Closes all meta files and data files opened by this class.  

        See also: open  

        """
        return _moduleconnectorwrapper.PyDataReader_close(self)


    def at_end(self):
        """
        at_end(PyDataReader self) -> bool



        Returns
        -------
        true if no more data records is available for reading, otherwise returns false.  

        See also: open, read_record  

        """
        return _moduleconnectorwrapper.PyDataReader_at_end(self)


    def read_record(self):
        """
        read_record(PyDataReader self) -> DataRecord



        Reads all bytes from a data record on disk and returns the DataRecord.  

        This is a convenience method that ensures all bytes from a record is read.  

        This method has no way of reporting error, however *DataRecord::is_valid* is set
        to true on success; otherwise set to false.  

        Returns
        -------
        the DataRecord.  

        See also: at_end, set_filter  

        """
        return _moduleconnectorwrapper.PyDataReader_read_record(self)


    def peek_record(self):
        """
        peek_record(PyDataReader self) -> DataRecord



        Reads all bytes from a data record on disk and returns the DataRecord without
        side effects (i.e.  

        if you call read after peek it will return the same data).  

        This is a convenience method that ensures all bytes from a record is read.  

        This method has no way of reporting error, however *DataRecord::is_valid* is set
        to true on success; otherwise set to false.  

        Returns
        -------
        the DataRecord.  

        See also: read_record, at_end, set_filter  

        """
        return _moduleconnectorwrapper.PyDataReader_peek_record(self)


    def seek_ms(self, position):
        """
        seek_ms(PyDataReader self, int64_t position) -> int



        Sets the current position as specified.  

        Parameters
        ----------
        * `position` :  
            Specifies the position as number of milliseconds.  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: seek_byte, get_duration, at_end  

        """
        return _moduleconnectorwrapper.PyDataReader_seek_ms(self, position)


    def seek_byte(self, position):
        """
        seek_byte(PyDataReader self, int64_t position) -> int



        Sets the current position as specified.  

        Parameters
        ----------
        * `position` :  
            Specifies the position as number of bytes.  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: seek_ms, get_size, at_end  

        """
        return _moduleconnectorwrapper.PyDataReader_seek_byte(self, position)


    def set_filter(self, data_types):
        """
        set_filter(PyDataReader self, uint32_t data_types) -> int



        Sets the filter used by read_record and peek_record.  

        The filter is used to specify the kind of data records returned by read_record
        and peek_record.  

        By default, the filter is set to all data types.  

        Parameters
        ----------
        * `data_types` :  
            Specifies the filter as a bitmask that consists of a combination of DataType
            flags. These flags can be combined with the bitwise OR operator (|). For
            example: BasebandIqDataType | SleepDataType. A convenience value
            AllDataTypes can also be specified.  

        Returns
        -------
        0 success, otherwise returns 1  

        See also: read_record, peek_record  

        """
        return _moduleconnectorwrapper.PyDataReader_set_filter(self, data_types)


    def get_filter(self):
        """
        get_filter(PyDataReader self) -> uint32_t



        Returns
        -------
        the filter used by read_record and peek_record. By default this value is all
        data types.  

        See also: set_filter  

        """
        return _moduleconnectorwrapper.PyDataReader_get_filter(self)


    def get_start_epoch(self):
        """
        get_start_epoch(PyDataReader self) -> int64_t



        Returns
        -------
        the start date/time for the recording as number of milliseconds since
        1970.01.01.  

        See also: get_size  

        """
        return _moduleconnectorwrapper.PyDataReader_get_start_epoch(self)


    def get_duration(self):
        """
        get_duration(PyDataReader self) -> int64_t



        Returns
        -------
        the total duration of the recording as milliseconds.  

        See also: get_start_epoch  

        """
        return _moduleconnectorwrapper.PyDataReader_get_duration(self)


    def get_size(self):
        """
        get_size(PyDataReader self) -> int64_t



        Returns
        -------
        the total size of the recording as number of bytes.  

        """
        return _moduleconnectorwrapper.PyDataReader_get_size(self)


    def get_data_types(self):
        """
        get_data_types(PyDataReader self) -> uint32_t



        This function returns a bitmask of all data types included in the recording.  

        The bitmask is an OR combination of DataType flags. For example:
        BasebandIqDataType | SleepDataType.  

        Returns
        -------
        a bitmask of all data types included in the recording.  

        """
        return _moduleconnectorwrapper.PyDataReader_get_data_types(self)


    def get_max_record_size(self):
        """
        get_max_record_size(PyDataReader self) -> uint32_t



        Returns
        -------
        the number of bytes of the largest record on disk included in the recording.  

        See also: read_record  

        """
        return _moduleconnectorwrapper.PyDataReader_get_max_record_size(self)


    def get_session_id(self):
        """
        get_session_id(PyDataReader self) -> std::string



        Returns
        -------
        the session id for the recording.  

        See also: RecordingOptions::set_session_id  

        """
        return _moduleconnectorwrapper.PyDataReader_get_session_id(self)

PyDataReader_swigregister = _moduleconnectorwrapper.PyDataReader_swigregister
PyDataReader_swigregister(PyDataReader)

class PyDataPlayer(_object):
    """


    The DataPlayer class allows playback of telegrams / binary packets from a
    recording generated by PyDataRecorder.  

    The DataPlayer class is a high level data playback class. It provides the user
    with the ability to playback recorded data as if it was coming from a physical
    device. So rather than initialising PythonModuleConnector with a physical device
    (serial port), it is possible to construct PythonModuleConnector with a
    DataPlayer object and receive telegrams / binary packets as one would normally
    receive from a physical XeThru device. For example, CSV data on disk is
    converted back to its original telegram / binary format before it is dispatched
    via ModuleConnector.  

    Moreover, it is possible to control the playback via functions such as play,
    pause, stop, set_playback_rate, set_filter.  

    @snippet read_recording.py Typical usage  

    This class uses the PyDataReader class to read records from disk before it
    converts them into telegrams / binary packets.  

    See also: PythonModuleConnector, PyDataRecorder, PyDataReader  

    C++ includes: PyDataPlayer.hpp

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyDataPlayer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyDataPlayer, name)
    __repr__ = _swig_repr

    def __init__(self, meta_filename, depth=-1):
        """
        __init__(XeThru::PyDataPlayer self, std::string const & meta_filename, int depth=-1) -> PyDataPlayer
        __init__(XeThru::PyDataPlayer self, std::string const & meta_filename) -> PyDataPlayer



        Constructs the player and opens the recording specified by the given meta
        filename.  

        One recording may contain several meta files, for example as a result of
        file/directory splitting. The meta file contains information about which files
        and data types were written to disk during a recording session. Common for all
        use cases is that *xethru_recording_meta.dat* is always present in the output
        folder generated by *DataRecorder*. Use that file as input argument to this
        constructor.  

        Parameters
        ----------
        * `meta_filename` :  
            Specifies which recording (*xethru_recording_meta.dat*) to open.  
        * `depth` :  
            Specifies the number of meta files to open in 'chained mode'. By default,
            this parameter is -1 (automatically open all files, i.e. the entire
            recording).  

        Constructor throws an runtime exception if the recording could not be opened.  

        """
        this = _moduleconnectorwrapper.new_PyDataPlayer(meta_filename, depth)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_PyDataPlayer
    __del__ = lambda self: None

    def play(self):
        """
        play(PyDataPlayer self)



        Start or resume playback.  

        Convenience function, equivalent to set_state(DataPlayer::PlayingState).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_play(self)


    def pause(self):
        """
        pause(PyDataPlayer self)



        Pause playback.  

        Convenience function, equivalent to set_state(DataPlayer::PausedState).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_pause(self)


    def stop(self):
        """
        stop(PyDataPlayer self)



        Stop playback and reset the play position to the beginning.  

        Convenience function, equivalent to set_state(DataPlayer::StoppedState).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_stop(self)


    def set_filter(self, data_types):
        """
        set_filter(PyDataPlayer self, uint32_t data_types) -> int



        Specifies which data types to play.  

        By default, the filter is set to all data types.  

        Parameters
        ----------
        * `data_types` :  
            Specifies the filter as a bitmask that consists of a combination of DataType
            flags. These flags can be combined with the bitwise OR operator (|). For
            example: BasebandIqDataType | SleepDataType. A convenience value
            AllDataTypes can also be specified.  

        Returns
        -------
        0 success, otherwise returns 1  

        See also: play  

        """
        return _moduleconnectorwrapper.PyDataPlayer_set_filter(self, data_types)


    def get_filter(self):
        """
        get_filter(PyDataPlayer self) -> uint32_t



        Returns
        -------
        the filter used to specify which data types to play. By default this value is
        all data types.  

        See also: set_filter  

        """
        return _moduleconnectorwrapper.PyDataPlayer_get_filter(self)


    def set_playback_rate(self, rate):
        """
        set_playback_rate(PyDataPlayer self, float rate)



        Sets the playback rate specified as a multiplier.  

        By default, this value is 1.0 indicating that the player is playing at the
        standard pace. Values higher than 1.0 will increase the pace, whereas a lower
        value will decrease the pace. Values less than zero indicate the player should
        play as fast as possible. Value zero is essentially the same as paused state.  

        Parameters
        ----------
        * `rate` :  
            Specifies the multiplier for the playback rate.  

        See also: play  

        """
        return _moduleconnectorwrapper.PyDataPlayer_set_playback_rate(self, rate)


    def get_playback_rate(self):
        """
        get_playback_rate(PyDataPlayer self) -> float



        Returns
        -------
        the multiplayer used for the playback rate. By default, this value is 1.0.  

        See also: set_playback_rate  

        """
        return _moduleconnectorwrapper.PyDataPlayer_get_playback_rate(self)


    def set_loop_mode_enabled(self, enabled):
        """
        set_loop_mode_enabled(PyDataPlayer self, bool enabled)



        Enables or disables loop mode as specified.  

        When loop mode is enabled the, the player's position is reset to the beginning
        when the player reaches the end. This allows for playback forever.  

        Parameters
        ----------
        * `enabled` :  
            Specifies if loop mode is enabled or disabled. By default, loop mode is
            disabled (i.e. false).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_set_loop_mode_enabled(self, enabled)


    def get_loop_mode_enabled(self):
        """
        get_loop_mode_enabled(PyDataPlayer self) -> bool



        Returns
        -------
        true if loop mode is enabled, otherwise returns false. By default, this value is
        false.  

        See also: set_loop_mode_enabled  

        """
        return _moduleconnectorwrapper.PyDataPlayer_get_loop_mode_enabled(self)


    def set_position(self, position):
        """
        set_position(PyDataPlayer self, int64_t position) -> int



        Sets the current position (ms) as specified.  

        The value must be in range [0, get_duration()].  

        Parameters
        ----------
        * `position` :  
            Specifies the position as number of milliseconds (ms).  

        Returns
        -------
        0 on success, otherwise returns 1  

        See also: get_duration  

        """
        return _moduleconnectorwrapper.PyDataPlayer_set_position(self, position)


    def get_position(self):
        """
        get_position(PyDataPlayer self) -> int64_t



        Returns
        -------
        the player's current position specified as number of milliseconds (ms).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_get_position(self)


    def get_duration(self):
        """
        get_duration(PyDataPlayer self) -> int64_t



        Returns
        -------
        the total duration of the recording specified as number of milliseconds (ms).  

        """
        return _moduleconnectorwrapper.PyDataPlayer_get_duration(self)


    def meta_filename(self):
        """
        meta_filename(PyDataPlayer self) -> std::string



        Returns
        -------
        the meta filename used when constructing this class.  

        """
        return _moduleconnectorwrapper.PyDataPlayer_meta_filename(self)

PyDataPlayer_swigregister = _moduleconnectorwrapper.PyDataPlayer_swigregister
PyDataPlayer_swigregister(PyDataPlayer)

DEPRECATED_XTS_SPR_APPDATA_FAST = _moduleconnectorwrapper.DEPRECATED_XTS_SPR_APPDATA_FAST
XTS_DEF_ENTER_BOOTLOADER_KEY = _moduleconnectorwrapper.XTS_DEF_ENTER_BOOTLOADER_KEY
XTS_DEF_PINGVAL = _moduleconnectorwrapper.XTS_DEF_PINGVAL
XTS_DEF_PONGVAL_READY = _moduleconnectorwrapper.XTS_DEF_PONGVAL_READY
XTS_DEF_PONGVAL_NOTREADY = _moduleconnectorwrapper.XTS_DEF_PONGVAL_NOTREADY
XTS_DEF_PONGVAL_SAFEMODE = _moduleconnectorwrapper.XTS_DEF_PONGVAL_SAFEMODE
XTS_DEF_ENTER_BOOTLOADER_KEY_2 = _moduleconnectorwrapper.XTS_DEF_ENTER_BOOTLOADER_KEY_2
XTS_SPA_VSDM_GET_STATUS = _moduleconnectorwrapper.XTS_SPA_VSDM_GET_STATUS
XTS_SPA_COMMON_GET_SPECTRUM = _moduleconnectorwrapper.XTS_SPA_COMMON_GET_SPECTRUM
XTS_USER_CONTENTID_COMFIGMSG = _moduleconnectorwrapper.XTS_USER_CONTENTID_COMFIGMSG
XTS_USER_CONTENTID_RADARSETTINGS = _moduleconnectorwrapper.XTS_USER_CONTENTID_RADARSETTINGS
XTS_USER_CONTENTID_SYSTEM_STATUS = _moduleconnectorwrapper.XTS_USER_CONTENTID_SYSTEM_STATUS
XTS_SPC_RESERVED = _moduleconnectorwrapper.XTS_SPC_RESERVED
XTS_SPC_PING = _moduleconnectorwrapper.XTS_SPC_PING
XTS_SPC_START_BOOTLOADER = _moduleconnectorwrapper.XTS_SPC_START_BOOTLOADER
XTS_SPC_APPCOMMAND = _moduleconnectorwrapper.XTS_SPC_APPCOMMAND
XTS_SPC_MOD_SETMODE = _moduleconnectorwrapper.XTS_SPC_MOD_SETMODE
XTS_SPC_MOD_LOADAPP = _moduleconnectorwrapper.XTS_SPC_MOD_LOADAPP
XTS_SPC_MOD_RESET = _moduleconnectorwrapper.XTS_SPC_MOD_RESET
XTS_SPC_MOD_SETCOM = _moduleconnectorwrapper.XTS_SPC_MOD_SETCOM
XTS_SPC_MOD_SETLEDCONTROL = _moduleconnectorwrapper.XTS_SPC_MOD_SETLEDCONTROL
XTS_SPC_MOD_NOISEMAP = _moduleconnectorwrapper.XTS_SPC_MOD_NOISEMAP
XTS_SPC_MOD_GETMODE = _moduleconnectorwrapper.XTS_SPC_MOD_GETMODE
XTS_SPC_IOPIN = _moduleconnectorwrapper.XTS_SPC_IOPIN
XTS_SPC_OUTPUT = _moduleconnectorwrapper.XTS_SPC_OUTPUT
XTS_SPC_DEBUG_OUTPUT = _moduleconnectorwrapper.XTS_SPC_DEBUG_OUTPUT
XTS_SPC_X4DRIVER = _moduleconnectorwrapper.XTS_SPC_X4DRIVER
XTS_SPC_DSP = _moduleconnectorwrapper.XTS_SPC_DSP
XTS_SPC_DIR_COMMAND = _moduleconnectorwrapper.XTS_SPC_DIR_COMMAND
XTS_SPC_HIL = _moduleconnectorwrapper.XTS_SPC_HIL
XTS_SPC_DEBUG_LEVEL = _moduleconnectorwrapper.XTS_SPC_DEBUG_LEVEL
XTS_SPC_BOOTLOADER = _moduleconnectorwrapper.XTS_SPC_BOOTLOADER
XTS_SPCD_RESERVED = _moduleconnectorwrapper.XTS_SPCD_RESERVED
XTS_SPCD_GET = _moduleconnectorwrapper.XTS_SPCD_GET
XTS_SPCD_SET = _moduleconnectorwrapper.XTS_SPCD_SET
XTS_SPCDI_NORMALIZATION = _moduleconnectorwrapper.XTS_SPCDI_NORMALIZATION
XTS_SPCDI_PHASE_NOISE_CORRECTION = _moduleconnectorwrapper.XTS_SPCDI_PHASE_NOISE_CORRECTION
XTS_SPCDI_DECIMATION_FACTOR = _moduleconnectorwrapper.XTS_SPCDI_DECIMATION_FACTOR
XTS_SPCDI_NUMBER_FORMAT = _moduleconnectorwrapper.XTS_SPCDI_NUMBER_FORMAT
XTS_SPCDI_LEGACY_OUTPUT = _moduleconnectorwrapper.XTS_SPCDI_LEGACY_OUTPUT
XTS_SPCA_RESERVED = _moduleconnectorwrapper.XTS_SPCA_RESERVED
XTS_SPCA_SET = _moduleconnectorwrapper.XTS_SPCA_SET
XTS_SPCA_GET = _moduleconnectorwrapper.XTS_SPCA_GET
XTS_SPCA_FACTORY_PRESET = _moduleconnectorwrapper.XTS_SPCA_FACTORY_PRESET
XTS_SPCA_STORE_NOISEMAP = _moduleconnectorwrapper.XTS_SPCA_STORE_NOISEMAP
XTS_SPCA_LOAD_NOISEMAP = _moduleconnectorwrapper.XTS_SPCA_LOAD_NOISEMAP
XTS_SPCA_GET_PARAMETER_FILE = _moduleconnectorwrapper.XTS_SPCA_GET_PARAMETER_FILE
XTS_SPCA_DELETE_NOISEMAP = _moduleconnectorwrapper.XTS_SPCA_DELETE_NOISEMAP
XTS_SPCA_POLL = _moduleconnectorwrapper.XTS_SPCA_POLL
XTS_SPCB_GET_DEVICE_INFO = _moduleconnectorwrapper.XTS_SPCB_GET_DEVICE_INFO
XTS_SPCB_WRITE_PAGE = _moduleconnectorwrapper.XTS_SPCB_WRITE_PAGE
XTS_SPCB_START_APP = _moduleconnectorwrapper.XTS_SPCB_START_APP
XTS_SPR_RESERVED = _moduleconnectorwrapper.XTS_SPR_RESERVED
XTS_SPR_PONG = _moduleconnectorwrapper.XTS_SPR_PONG
XTS_SPR_ACK = _moduleconnectorwrapper.XTS_SPR_ACK
XTS_SPR_REPLY = _moduleconnectorwrapper.XTS_SPR_REPLY
XTS_SPR_HIL = _moduleconnectorwrapper.XTS_SPR_HIL
XTS_SPR_ERROR = _moduleconnectorwrapper.XTS_SPR_ERROR
XTS_SPR_SYSTEM = _moduleconnectorwrapper.XTS_SPR_SYSTEM
XTS_SPR_APPDATA = _moduleconnectorwrapper.XTS_SPR_APPDATA
XTS_SPR_DATA = _moduleconnectorwrapper.XTS_SPR_DATA
XTS_SPRE_RESERVED = _moduleconnectorwrapper.XTS_SPRE_RESERVED
XTS_SPRE_NOT_RECOGNIZED = _moduleconnectorwrapper.XTS_SPRE_NOT_RECOGNIZED
XTS_SPRE_CRC_FAILED = _moduleconnectorwrapper.XTS_SPRE_CRC_FAILED
XTS_SPRE_BUSY = _moduleconnectorwrapper.XTS_SPRE_BUSY
XTS_SPRE_APP_INVALID = _moduleconnectorwrapper.XTS_SPRE_APP_INVALID
XTS_SPRE_COMMAND_FAILED = _moduleconnectorwrapper.XTS_SPRE_COMMAND_FAILED
XTS_SPRE_RESTARTING = _moduleconnectorwrapper.XTS_SPRE_RESTARTING
XTS_SPRE_USER = _moduleconnectorwrapper.XTS_SPRE_USER
XTS_SPRS_RESERVED = _moduleconnectorwrapper.XTS_SPRS_RESERVED
XTS_SPRS_BOOTING = _moduleconnectorwrapper.XTS_SPRS_BOOTING
XTS_SPRS_READY = _moduleconnectorwrapper.XTS_SPRS_READY
XTS_SDC_RESERVED = _moduleconnectorwrapper.XTS_SDC_RESERVED
XTS_SDC_RADAR_FIRST = _moduleconnectorwrapper.XTS_SDC_RADAR_FIRST
XTS_SDC_RADLIB_EXECUTE = _moduleconnectorwrapper.XTS_SDC_RADLIB_EXECUTE
XTS_SDC_RADLIB_SETVARINT = _moduleconnectorwrapper.XTS_SDC_RADLIB_SETVARINT
XTS_SDC_RADLIB_GETVARINT = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETVARINT
XTS_SDC_RADLIB_SETVARFLOAT = _moduleconnectorwrapper.XTS_SDC_RADLIB_SETVARFLOAT
XTS_SDC_RADLIB_GETVARFLOAT = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETVARFLOAT
XTS_SDC_RADLIB_SETREGFIELD = _moduleconnectorwrapper.XTS_SDC_RADLIB_SETREGFIELD
XTS_SDC_RADLIB_GETREGFIELD = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETREGFIELD
XTS_SDC_RADLIB_GETFRAMEFLOAT = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETFRAMEFLOAT
XTS_SDC_RADLIB_GETFRAMERAW = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETFRAMERAW
XTS_SDC_RADLIB_GETCHIPID = _moduleconnectorwrapper.XTS_SDC_RADLIB_GETCHIPID
XTS_SDC_RADLIB_TIMINGMEASUREMENT = _moduleconnectorwrapper.XTS_SDC_RADLIB_TIMINGMEASUREMENT
XTS_SDC_RADHW_RESET = _moduleconnectorwrapper.XTS_SDC_RADHW_RESET
XTS_SDC_RADHW_CLOCK = _moduleconnectorwrapper.XTS_SDC_RADHW_CLOCK
XTS_SDC_RADMSC_DOFRAMETOFLASH = _moduleconnectorwrapper.XTS_SDC_RADMSC_DOFRAMETOFLASH
XTS_SDC_RADAR_LAST = _moduleconnectorwrapper.XTS_SDC_RADAR_LAST
XTS_SDC_SYSTEM_FIRST = _moduleconnectorwrapper.XTS_SDC_SYSTEM_FIRST
XTS_SDC_SYSTEM_TEST = _moduleconnectorwrapper.XTS_SDC_SYSTEM_TEST
XTS_SDC_SYSCFG_SETINT = _moduleconnectorwrapper.XTS_SDC_SYSCFG_SETINT
XTS_SDC_SYSCFG_SETFLOAT = _moduleconnectorwrapper.XTS_SDC_SYSCFG_SETFLOAT
XTS_SDC_SYSFLASH_GETBLOCK = _moduleconnectorwrapper.XTS_SDC_SYSFLASH_GETBLOCK
XTS_SDC_SYSFLASH_SETBLOCK = _moduleconnectorwrapper.XTS_SDC_SYSFLASH_SETBLOCK
XTS_SDC_SYSTEM_GET_VERSION = _moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_VERSION
XTS_SDC_SYSTEM_GET_BUILD = _moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_BUILD
XTS_SDC_SYSTEM_GET_PRODUCT = _moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_PRODUCT
XTS_SDC_SYSTEM_GET_INFO = _moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_INFO
XTS_SDC_SYSTEM_GET_DEBUG_DATA = _moduleconnectorwrapper.XTS_SDC_SYSTEM_GET_DEBUG_DATA
XTS_SDC_GET_PARAMETER_FILE = _moduleconnectorwrapper.XTS_SDC_GET_PARAMETER_FILE
XTS_SDC_GET_CRASH_DUMP_LENGTH = _moduleconnectorwrapper.XTS_SDC_GET_CRASH_DUMP_LENGTH
XTS_SDC_CLEAR_CRASH_DUMP = _moduleconnectorwrapper.XTS_SDC_CLEAR_CRASH_DUMP
XTS_SDC_GET_CRASH_DUMP = _moduleconnectorwrapper.XTS_SDC_GET_CRASH_DUMP
XTS_SDC_SEARCH_FILE_TYPE = _moduleconnectorwrapper.XTS_SDC_SEARCH_FILE_TYPE
XTS_SDC_FIND_ALL_FILES = _moduleconnectorwrapper.XTS_SDC_FIND_ALL_FILES
XTS_SDC_CREATE_NEW_FILE = _moduleconnectorwrapper.XTS_SDC_CREATE_NEW_FILE
XTS_SDC_SET_FILE_DATA = _moduleconnectorwrapper.XTS_SDC_SET_FILE_DATA
XTS_SDC_CLOSE_FILE = _moduleconnectorwrapper.XTS_SDC_CLOSE_FILE
XTS_SDC_GET_FILE_LENGTH = _moduleconnectorwrapper.XTS_SDC_GET_FILE_LENGTH
XTS_SDC_DELETE_FILE = _moduleconnectorwrapper.XTS_SDC_DELETE_FILE
XTS_SDC_GET_FILE_DATA = _moduleconnectorwrapper.XTS_SDC_GET_FILE_DATA
XTS_SDC_OPEN_FILE = _moduleconnectorwrapper.XTS_SDC_OPEN_FILE
XTS_SDC_FORMAT_FILESYSTEM = _moduleconnectorwrapper.XTS_SDC_FORMAT_FILESYSTEM
XTS_SDC_GET_PROFILEID = _moduleconnectorwrapper.XTS_SDC_GET_PROFILEID
XTS_SDC_INJECT_FRAME = _moduleconnectorwrapper.XTS_SDC_INJECT_FRAME
XTS_SDC_PREPARE_INJECT_FRAME = _moduleconnectorwrapper.XTS_SDC_PREPARE_INJECT_FRAME
XTS_SDC_SYSTEM_LAST = _moduleconnectorwrapper.XTS_SDC_SYSTEM_LAST
XTS_SDC_APP_FIRST = _moduleconnectorwrapper.XTS_SDC_APP_FIRST
XTS_SDC_APP_SETFLOAT = _moduleconnectorwrapper.XTS_SDC_APP_SETFLOAT
XTS_SDC_APP_SETINT = _moduleconnectorwrapper.XTS_SDC_APP_SETINT
XTS_SDC_APP_LAST = _moduleconnectorwrapper.XTS_SDC_APP_LAST
XTS_SDC_COMM_FIRST = _moduleconnectorwrapper.XTS_SDC_COMM_FIRST
XTS_SDC_COMM_SETBAUDRATE = _moduleconnectorwrapper.XTS_SDC_COMM_SETBAUDRATE
XTS_SDC_COMM_LAST = _moduleconnectorwrapper.XTS_SDC_COMM_LAST
XTS_SPCIOP_RESERVED = _moduleconnectorwrapper.XTS_SPCIOP_RESERVED
XTS_SPCIOP_SETCONTROL = _moduleconnectorwrapper.XTS_SPCIOP_SETCONTROL
XTS_SPCIOP_GETCONTROL = _moduleconnectorwrapper.XTS_SPCIOP_GETCONTROL
XTS_SPCIOP_SETVALUE = _moduleconnectorwrapper.XTS_SPCIOP_SETVALUE
XTS_SPCIOP_GETVALUE = _moduleconnectorwrapper.XTS_SPCIOP_GETVALUE
XTS_SPCO_RESERVED = _moduleconnectorwrapper.XTS_SPCO_RESERVED
XTS_SPCO_SETCONTROL = _moduleconnectorwrapper.XTS_SPCO_SETCONTROL
XTS_SPCO_GETCONTROL = _moduleconnectorwrapper.XTS_SPCO_GETCONTROL
XTS_SPCN_RESERVED = _moduleconnectorwrapper.XTS_SPCN_RESERVED
XTS_SPCN_SETCONTROL = _moduleconnectorwrapper.XTS_SPCN_SETCONTROL
XTS_SPCN_GETCONTROL = _moduleconnectorwrapper.XTS_SPCN_GETCONTROL
XTS_SPCN_SETPERIODICSTORE = _moduleconnectorwrapper.XTS_SPCN_SETPERIODICSTORE
XTS_SPCN_GETPERIODICSTORE = _moduleconnectorwrapper.XTS_SPCN_GETPERIODICSTORE
XTS_SPCX_RESERVED = _moduleconnectorwrapper.XTS_SPCX_RESERVED
XTS_SPCX_SET = _moduleconnectorwrapper.XTS_SPCX_SET
XTS_SPCX_GET = _moduleconnectorwrapper.XTS_SPCX_GET
XTS_SPCX_WRITE = _moduleconnectorwrapper.XTS_SPCX_WRITE
XTS_SPCX_READ = _moduleconnectorwrapper.XTS_SPCX_READ
XTS_SPCX_I2C_WRITE = _moduleconnectorwrapper.XTS_SPCX_I2C_WRITE
XTS_SPCX_I2C_READ = _moduleconnectorwrapper.XTS_SPCX_I2C_READ
XTS_SPCX_INIT = _moduleconnectorwrapper.XTS_SPCX_INIT
XTS_SPCXI_RESERVED = _moduleconnectorwrapper.XTS_SPCXI_RESERVED
XTS_SPCXI_FPS = _moduleconnectorwrapper.XTS_SPCXI_FPS
XTS_SPCXI_PULSESPERSTEP = _moduleconnectorwrapper.XTS_SPCXI_PULSESPERSTEP
XTS_SPCXI_ITERATIONS = _moduleconnectorwrapper.XTS_SPCXI_ITERATIONS
XTS_SPCXI_DOWNCONVERSION = _moduleconnectorwrapper.XTS_SPCXI_DOWNCONVERSION
XTS_SPCXI_FRAMEAREA = _moduleconnectorwrapper.XTS_SPCXI_FRAMEAREA
XTS_SPCXI_DACSTEP = _moduleconnectorwrapper.XTS_SPCXI_DACSTEP
XTS_SPCXI_DACMIN = _moduleconnectorwrapper.XTS_SPCXI_DACMIN
XTS_SPCXI_DACMAX = _moduleconnectorwrapper.XTS_SPCXI_DACMAX
XTS_SPCXI_FRAMEAREAOFFSET = _moduleconnectorwrapper.XTS_SPCXI_FRAMEAREAOFFSET
XTS_SPCXI_ENABLE = _moduleconnectorwrapper.XTS_SPCXI_ENABLE
XTS_SPCXI_TXCENTERFREQUENCY = _moduleconnectorwrapper.XTS_SPCXI_TXCENTERFREQUENCY
XTS_SPCXI_TXPOWER = _moduleconnectorwrapper.XTS_SPCXI_TXPOWER
XTS_SPCXI_SPIREGISTER = _moduleconnectorwrapper.XTS_SPCXI_SPIREGISTER
XTS_SPCXI_PIFREGISTER = _moduleconnectorwrapper.XTS_SPCXI_PIFREGISTER
XTS_SPCXI_XIFREGISTER = _moduleconnectorwrapper.XTS_SPCXI_XIFREGISTER
XTS_SPCXI_PRFDIV = _moduleconnectorwrapper.XTS_SPCXI_PRFDIV
XTS_SPCXI_FRAMEBINCOUNT = _moduleconnectorwrapper.XTS_SPCXI_FRAMEBINCOUNT
XTS_SPCXI_I2CREGISTER = _moduleconnectorwrapper.XTS_SPCXI_I2CREGISTER
XTS_SPH_RESERVED = _moduleconnectorwrapper.XTS_SPH_RESERVED
XTS_SPH_CMD_CONTINUE = _moduleconnectorwrapper.XTS_SPH_CMD_CONTINUE
XTS_SPH_SEND_FLOAT = _moduleconnectorwrapper.XTS_SPH_SEND_FLOAT
XTS_SSCR_RESERVED = _moduleconnectorwrapper.XTS_SSCR_RESERVED
XTS_SSCR_PULSESPERSTEP = _moduleconnectorwrapper.XTS_SSCR_PULSESPERSTEP
XTS_SSCR_ITERATIONS = _moduleconnectorwrapper.XTS_SSCR_ITERATIONS
XTS_SSCR_DACSTEP = _moduleconnectorwrapper.XTS_SSCR_DACSTEP
XTS_SSCR_DACMIN = _moduleconnectorwrapper.XTS_SSCR_DACMIN
XTS_SSCR_DACMAX = _moduleconnectorwrapper.XTS_SSCR_DACMAX
XTS_SSCR_SAMPLEDELAY = _moduleconnectorwrapper.XTS_SSCR_SAMPLEDELAY
XTS_SSCR_PGSELECT = _moduleconnectorwrapper.XTS_SSCR_PGSELECT
XTS_SSCR_MCLKDIV = _moduleconnectorwrapper.XTS_SSCR_MCLKDIV
XTS_SSCR_STAGGEREDPRFENABLE = _moduleconnectorwrapper.XTS_SSCR_STAGGEREDPRFENABLE
XTS_SSCR_DACAUTO = _moduleconnectorwrapper.XTS_SSCR_DACAUTO
XTS_SSCR_FPS = _moduleconnectorwrapper.XTS_SSCR_FPS
XTS_SSCR_FRAMESTITCH = _moduleconnectorwrapper.XTS_SSCR_FRAMESTITCH
XTS_SACR_RESERVED = _moduleconnectorwrapper.XTS_SACR_RESERVED
XTS_SACR_OUTPUTBASEBAND = _moduleconnectorwrapper.XTS_SACR_OUTPUTBASEBAND
XTS_SACR_OUTPUTSTATUS = _moduleconnectorwrapper.XTS_SACR_OUTPUTSTATUS
XTS_SACR_OUTPUTSTATUSEXT = _moduleconnectorwrapper.XTS_SACR_OUTPUTSTATUSEXT
XTS_SACR_OUTPUT_RF = _moduleconnectorwrapper.XTS_SACR_OUTPUT_RF
XTS_SACR_OUTPUT_PULSE_DOPPLER = _moduleconnectorwrapper.XTS_SACR_OUTPUT_PULSE_DOPPLER
XTS_SPRD_NONE = _moduleconnectorwrapper.XTS_SPRD_NONE
XTS_SPRD_BYTE = _moduleconnectorwrapper.XTS_SPRD_BYTE
XTS_SPRD_INT = _moduleconnectorwrapper.XTS_SPRD_INT
XTS_SPRD_FLOAT = _moduleconnectorwrapper.XTS_SPRD_FLOAT
XTS_SPRD_STRING = _moduleconnectorwrapper.XTS_SPRD_STRING
XTS_SPRD_USER = _moduleconnectorwrapper.XTS_SPRD_USER
XTS_FLAG_START = _moduleconnectorwrapper.XTS_FLAG_START
XTS_FLAG_END = _moduleconnectorwrapper.XTS_FLAG_END
XTS_FLAG_ESC = _moduleconnectorwrapper.XTS_FLAG_ESC
XTS_FLAGSEQUENCE_START_NOESCAPE = _moduleconnectorwrapper.XTS_FLAGSEQUENCE_START_NOESCAPE
XTS_SSTC_SUCCESS = _moduleconnectorwrapper.XTS_SSTC_SUCCESS
XTS_SSTC_FAILED = _moduleconnectorwrapper.XTS_SSTC_FAILED
XTS_SSTC_NOTIMPLEMENTED = _moduleconnectorwrapper.XTS_SSTC_NOTIMPLEMENTED
XTS_SSTC_TEST_FIRST = _moduleconnectorwrapper.XTS_SSTC_TEST_FIRST
XTS_SSTC_TEST_RESETCOUNT = _moduleconnectorwrapper.XTS_SSTC_TEST_RESETCOUNT
XTS_SSTC_TEST_EXTRAM = _moduleconnectorwrapper.XTS_SSTC_TEST_EXTRAM
XTS_SSTC_TEST_EXTFLASH = _moduleconnectorwrapper.XTS_SSTC_TEST_EXTFLASH
XTS_SSTC_TEST_PMIC = _moduleconnectorwrapper.XTS_SSTC_TEST_PMIC
XTS_SSTC_TEST_INPUT_HIGH = _moduleconnectorwrapper.XTS_SSTC_TEST_INPUT_HIGH
XTS_SSTC_TEST_INPUT_LOW = _moduleconnectorwrapper.XTS_SSTC_TEST_INPUT_LOW
XTS_SSTC_TEST_OUTPUT_HIGH = _moduleconnectorwrapper.XTS_SSTC_TEST_OUTPUT_HIGH
XTS_SSTC_TEST_OUTPUT_LOW = _moduleconnectorwrapper.XTS_SSTC_TEST_OUTPUT_LOW
XTS_SSTC_TEST_READ_IOPINS = _moduleconnectorwrapper.XTS_SSTC_TEST_READ_IOPINS
XTS_SSTC_TEST_X4_CONN = _moduleconnectorwrapper.XTS_SSTC_TEST_X4_CONN
XTS_SSTC_TEST_CERT_MODE_EN = _moduleconnectorwrapper.XTS_SSTC_TEST_CERT_MODE_EN
XTS_SSTC_TEST_CERT_MODE_DIS = _moduleconnectorwrapper.XTS_SSTC_TEST_CERT_MODE_DIS
XTS_SSTC_TEST_HW_CONFIG = _moduleconnectorwrapper.XTS_SSTC_TEST_HW_CONFIG
XTS_SSTC_TEST_CERT_TX_ONLY = _moduleconnectorwrapper.XTS_SSTC_TEST_CERT_TX_ONLY
XTS_SSTC_TEST_CERT_TX_ONLY_TX_OFF = _moduleconnectorwrapper.XTS_SSTC_TEST_CERT_TX_ONLY_TX_OFF
XTS_SSTC_TEST_CERT_STREAM_TX_OFF = _moduleconnectorwrapper.XTS_SSTC_TEST_CERT_STREAM_TX_OFF
XTS_SSTC_TEST_LAST = _moduleconnectorwrapper.XTS_SSTC_TEST_LAST
XTS_SSIC_ITEMNUMBER = _moduleconnectorwrapper.XTS_SSIC_ITEMNUMBER
XTS_SSIC_ORDERCODE = _moduleconnectorwrapper.XTS_SSIC_ORDERCODE
XTS_SSIC_FIRMWAREID = _moduleconnectorwrapper.XTS_SSIC_FIRMWAREID
XTS_SSIC_VERSION = _moduleconnectorwrapper.XTS_SSIC_VERSION
XTS_SSIC_BUILD = _moduleconnectorwrapper.XTS_SSIC_BUILD
XTS_SSIC_APPIDLIST = _moduleconnectorwrapper.XTS_SSIC_APPIDLIST
XTS_SSIC_SERIALNUMBER = _moduleconnectorwrapper.XTS_SSIC_SERIALNUMBER
XTS_SM_RESERVED = _moduleconnectorwrapper.XTS_SM_RESERVED
XTS_SM_RUN = _moduleconnectorwrapper.XTS_SM_RUN
XTS_SM_NORMAL = _moduleconnectorwrapper.XTS_SM_NORMAL
XTS_SM_IDLE = _moduleconnectorwrapper.XTS_SM_IDLE
XTS_SM_MANUAL = _moduleconnectorwrapper.XTS_SM_MANUAL
XTS_SM_STOP = _moduleconnectorwrapper.XTS_SM_STOP
XTS_SM_REG = _moduleconnectorwrapper.XTS_SM_REG
XTS_SM_REG_IDLE = _moduleconnectorwrapper.XTS_SM_REG_IDLE
XTS_SM_REG_CERT_TX_ONLY = _moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY
XTS_SM_REG_CERT_TX_ONLY_TX_OFF = _moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY_TX_OFF
XTS_SM_REG_CERT_STREAM_TX_OFF = _moduleconnectorwrapper.XTS_SM_REG_CERT_STREAM_TX_OFF
XTS_SM_REG_CERT_TX_ONLY_EXTCLK = _moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY_EXTCLK
XTS_SM_REG_CERT_STREAM = _moduleconnectorwrapper.XTS_SM_REG_CERT_STREAM
XTS_SM_REG_CERT_TX_ONLY_CLKOUT = _moduleconnectorwrapper.XTS_SM_REG_CERT_TX_ONLY_CLKOUT
XTS_SM_REG_CERT_RX_FAILURE_EMU = _moduleconnectorwrapper.XTS_SM_REG_CERT_RX_FAILURE_EMU
XTS_SM_NORMAL_EMBEDDED = _moduleconnectorwrapper.XTS_SM_NORMAL_EMBEDDED
XTS_SM_NORMAL_HIL_UP = _moduleconnectorwrapper.XTS_SM_NORMAL_HIL_UP
XTS_SM_NORMAL_HIL_DOWN = _moduleconnectorwrapper.XTS_SM_NORMAL_HIL_DOWN
XTS_SM_NORMAL_DEFAULT = _moduleconnectorwrapper.XTS_SM_NORMAL_DEFAULT
ID_RAW_FRAME_BUFFER = _moduleconnectorwrapper.ID_RAW_FRAME_BUFFER
ID_BASEBAND_BUFFER_ICHANN = _moduleconnectorwrapper.ID_BASEBAND_BUFFER_ICHANN
ID_BASEBAND_BUFFER_QCHANN = _moduleconnectorwrapper.ID_BASEBAND_BUFFER_QCHANN
ID_BASEBAND_BUFFER_IQCHANN_LEGACY = _moduleconnectorwrapper.ID_BASEBAND_BUFFER_IQCHANN_LEGACY
ID_BASEBAND_ENVELOPE = _moduleconnectorwrapper.ID_BASEBAND_ENVELOPE
ID_DOPPLER_FFT_INPUT = _moduleconnectorwrapper.ID_DOPPLER_FFT_INPUT
ID_DOPPLER_FFT_OUTPUT = _moduleconnectorwrapper.ID_DOPPLER_FFT_OUTPUT
ID_PULSEDOPPLER_MATRIX = _moduleconnectorwrapper.ID_PULSEDOPPLER_MATRIX
ID_NOISEMAP = _moduleconnectorwrapper.ID_NOISEMAP
ID_FRAMESTORAGE_BUFFER_ICHANN = _moduleconnectorwrapper.ID_FRAMESTORAGE_BUFFER_ICHANN
ID_FRAMESTORAGE_BUFFER_QCHANN = _moduleconnectorwrapper.ID_FRAMESTORAGE_BUFFER_QCHANN
ID_RAW_FLASH_FRAME = _moduleconnectorwrapper.ID_RAW_FLASH_FRAME
ID_BASEBAND_IQ = _moduleconnectorwrapper.ID_BASEBAND_IQ
ID_BASEBAND_AP = _moduleconnectorwrapper.ID_BASEBAND_AP
ID_GENERIC_BYTE_STREAM = _moduleconnectorwrapper.ID_GENERIC_BYTE_STREAM
NUMBER_OF_MESSAGE_IDS = _moduleconnectorwrapper.NUMBER_OF_MESSAGE_IDS
XTS_SACR_ID_BASEBAND_OUTPUT_OFF = _moduleconnectorwrapper.XTS_SACR_ID_BASEBAND_OUTPUT_OFF
XTS_SACR_ID_BASEBAND_OUTPUT_IQ = _moduleconnectorwrapper.XTS_SACR_ID_BASEBAND_OUTPUT_IQ
XTS_SACR_ID_BASEBAND_OUTPUT_AMPLITUDE_PHASE = _moduleconnectorwrapper.XTS_SACR_ID_BASEBAND_OUTPUT_AMPLITUDE_PHASE
XTS_BASEBAND_AMPLITUDE_ONLY = _moduleconnectorwrapper.XTS_BASEBAND_AMPLITUDE_ONLY
XTS_BASEBAND_PHASE_ONLY = _moduleconnectorwrapper.XTS_BASEBAND_PHASE_ONLY
class baseband_output_header_t(_object):
    """Proxy of C++ baseband_output_header_t class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, baseband_output_header_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, baseband_output_header_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["id"] = _moduleconnectorwrapper.baseband_output_header_t_id_set
    __swig_getmethods__["id"] = _moduleconnectorwrapper.baseband_output_header_t_id_get
    if _newclass:
        id = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_id_get, _moduleconnectorwrapper.baseband_output_header_t_id_set)
    __swig_setmethods__["Counter"] = _moduleconnectorwrapper.baseband_output_header_t_Counter_set
    __swig_getmethods__["Counter"] = _moduleconnectorwrapper.baseband_output_header_t_Counter_get
    if _newclass:
        Counter = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_Counter_get, _moduleconnectorwrapper.baseband_output_header_t_Counter_set)
    __swig_setmethods__["NumOfBins"] = _moduleconnectorwrapper.baseband_output_header_t_NumOfBins_set
    __swig_getmethods__["NumOfBins"] = _moduleconnectorwrapper.baseband_output_header_t_NumOfBins_get
    if _newclass:
        NumOfBins = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_NumOfBins_get, _moduleconnectorwrapper.baseband_output_header_t_NumOfBins_set)
    __swig_setmethods__["BinLength"] = _moduleconnectorwrapper.baseband_output_header_t_BinLength_set
    __swig_getmethods__["BinLength"] = _moduleconnectorwrapper.baseband_output_header_t_BinLength_get
    if _newclass:
        BinLength = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_BinLength_get, _moduleconnectorwrapper.baseband_output_header_t_BinLength_set)
    __swig_setmethods__["SamplingFrequency"] = _moduleconnectorwrapper.baseband_output_header_t_SamplingFrequency_set
    __swig_getmethods__["SamplingFrequency"] = _moduleconnectorwrapper.baseband_output_header_t_SamplingFrequency_get
    if _newclass:
        SamplingFrequency = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_SamplingFrequency_get, _moduleconnectorwrapper.baseband_output_header_t_SamplingFrequency_set)
    __swig_setmethods__["CarrierFrequency"] = _moduleconnectorwrapper.baseband_output_header_t_CarrierFrequency_set
    __swig_getmethods__["CarrierFrequency"] = _moduleconnectorwrapper.baseband_output_header_t_CarrierFrequency_get
    if _newclass:
        CarrierFrequency = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_CarrierFrequency_get, _moduleconnectorwrapper.baseband_output_header_t_CarrierFrequency_set)
    __swig_setmethods__["RangeOffset"] = _moduleconnectorwrapper.baseband_output_header_t_RangeOffset_set
    __swig_getmethods__["RangeOffset"] = _moduleconnectorwrapper.baseband_output_header_t_RangeOffset_get
    if _newclass:
        RangeOffset = _swig_property(_moduleconnectorwrapper.baseband_output_header_t_RangeOffset_get, _moduleconnectorwrapper.baseband_output_header_t_RangeOffset_set)

    def __init__(self):
        """__init__(baseband_output_header_t self) -> baseband_output_header_t"""
        this = _moduleconnectorwrapper.new_baseband_output_header_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_baseband_output_header_t
    __del__ = lambda self: None
baseband_output_header_t_swigregister = _moduleconnectorwrapper.baseband_output_header_t_swigregister
baseband_output_header_t_swigregister(baseband_output_header_t)

XTS_PULSEDOPPLER_OUTPUT_OFF = _moduleconnectorwrapper.XTS_PULSEDOPPLER_OUTPUT_OFF
XTS_PULSEDOPPLER_AS_FLOAT = _moduleconnectorwrapper.XTS_PULSEDOPPLER_AS_FLOAT
XTS_PULSEDOPPLER_AS_BYTE = _moduleconnectorwrapper.XTS_PULSEDOPPLER_AS_BYTE
CRC_ERROR = _moduleconnectorwrapper.CRC_ERROR
LOST_BYTES = _moduleconnectorwrapper.LOST_BYTES
INCOMPLETE_PACKET = _moduleconnectorwrapper.INCOMPLETE_PACKET
OUT_OF_BUFFER = _moduleconnectorwrapper.OUT_OF_BUFFER
COMMAND_TIMEOUT = _moduleconnectorwrapper.COMMAND_TIMEOUT
class xtsUserVsdmStatus(_object):
    """Proxy of C++ xtsUserVsdmStatus class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, xtsUserVsdmStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, xtsUserVsdmStatus, name)
    __repr__ = _swig_repr
    __swig_setmethods__["frameCtr"] = _moduleconnectorwrapper.xtsUserVsdmStatus_frameCtr_set
    __swig_getmethods__["frameCtr"] = _moduleconnectorwrapper.xtsUserVsdmStatus_frameCtr_get
    if _newclass:
        frameCtr = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_frameCtr_get, _moduleconnectorwrapper.xtsUserVsdmStatus_frameCtr_set)
    __swig_setmethods__["state"] = _moduleconnectorwrapper.xtsUserVsdmStatus_state_set
    __swig_getmethods__["state"] = _moduleconnectorwrapper.xtsUserVsdmStatus_state_get
    if _newclass:
        state = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_state_get, _moduleconnectorwrapper.xtsUserVsdmStatus_state_set)
    __swig_setmethods__["stateData"] = _moduleconnectorwrapper.xtsUserVsdmStatus_stateData_set
    __swig_getmethods__["stateData"] = _moduleconnectorwrapper.xtsUserVsdmStatus_stateData_get
    if _newclass:
        stateData = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_stateData_get, _moduleconnectorwrapper.xtsUserVsdmStatus_stateData_set)
    __swig_setmethods__["objectDistance"] = _moduleconnectorwrapper.xtsUserVsdmStatus_objectDistance_set
    __swig_getmethods__["objectDistance"] = _moduleconnectorwrapper.xtsUserVsdmStatus_objectDistance_get
    if _newclass:
        objectDistance = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_objectDistance_get, _moduleconnectorwrapper.xtsUserVsdmStatus_objectDistance_set)
    __swig_setmethods__["objectMovement"] = _moduleconnectorwrapper.xtsUserVsdmStatus_objectMovement_set
    __swig_getmethods__["objectMovement"] = _moduleconnectorwrapper.xtsUserVsdmStatus_objectMovement_get
    if _newclass:
        objectMovement = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_objectMovement_get, _moduleconnectorwrapper.xtsUserVsdmStatus_objectMovement_set)
    __swig_setmethods__["signalQuality"] = _moduleconnectorwrapper.xtsUserVsdmStatus_signalQuality_set
    __swig_getmethods__["signalQuality"] = _moduleconnectorwrapper.xtsUserVsdmStatus_signalQuality_get
    if _newclass:
        signalQuality = _swig_property(_moduleconnectorwrapper.xtsUserVsdmStatus_signalQuality_get, _moduleconnectorwrapper.xtsUserVsdmStatus_signalQuality_set)

    def __init__(self):
        """__init__(xtsUserVsdmStatus self) -> xtsUserVsdmStatus"""
        this = _moduleconnectorwrapper.new_xtsUserVsdmStatus()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_xtsUserVsdmStatus
    __del__ = lambda self: None
xtsUserVsdmStatus_swigregister = _moduleconnectorwrapper.xtsUserVsdmStatus_swigregister
xtsUserVsdmStatus_swigregister(xtsUserVsdmStatus)

class xtsUserPresenceStatus(_object):
    """Proxy of C++ xtsUserPresenceStatus class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, xtsUserPresenceStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, xtsUserPresenceStatus, name)
    __repr__ = _swig_repr
    __swig_setmethods__["presence"] = _moduleconnectorwrapper.xtsUserPresenceStatus_presence_set
    __swig_getmethods__["presence"] = _moduleconnectorwrapper.xtsUserPresenceStatus_presence_get
    if _newclass:
        presence = _swig_property(_moduleconnectorwrapper.xtsUserPresenceStatus_presence_get, _moduleconnectorwrapper.xtsUserPresenceStatus_presence_set)
    __swig_setmethods__["objectDistance"] = _moduleconnectorwrapper.xtsUserPresenceStatus_objectDistance_set
    __swig_getmethods__["objectDistance"] = _moduleconnectorwrapper.xtsUserPresenceStatus_objectDistance_get
    if _newclass:
        objectDistance = _swig_property(_moduleconnectorwrapper.xtsUserPresenceStatus_objectDistance_get, _moduleconnectorwrapper.xtsUserPresenceStatus_objectDistance_set)
    __swig_setmethods__["detectionValue"] = _moduleconnectorwrapper.xtsUserPresenceStatus_detectionValue_set
    __swig_getmethods__["detectionValue"] = _moduleconnectorwrapper.xtsUserPresenceStatus_detectionValue_get
    if _newclass:
        detectionValue = _swig_property(_moduleconnectorwrapper.xtsUserPresenceStatus_detectionValue_get, _moduleconnectorwrapper.xtsUserPresenceStatus_detectionValue_set)
    __swig_setmethods__["signalQuality"] = _moduleconnectorwrapper.xtsUserPresenceStatus_signalQuality_set
    __swig_getmethods__["signalQuality"] = _moduleconnectorwrapper.xtsUserPresenceStatus_signalQuality_get
    if _newclass:
        signalQuality = _swig_property(_moduleconnectorwrapper.xtsUserPresenceStatus_signalQuality_get, _moduleconnectorwrapper.xtsUserPresenceStatus_signalQuality_set)

    def __init__(self):
        """__init__(xtsUserPresenceStatus self) -> xtsUserPresenceStatus"""
        this = _moduleconnectorwrapper.new_xtsUserPresenceStatus()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_xtsUserPresenceStatus
    __del__ = lambda self: None
xtsUserPresenceStatus_swigregister = _moduleconnectorwrapper.xtsUserPresenceStatus_swigregister
xtsUserPresenceStatus_swigregister(xtsUserPresenceStatus)

class xtssRadarSettings_t(_object):
    """Proxy of C++ xtssRadarSettings_t class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, xtssRadarSettings_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, xtssRadarSettings_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["timingValue"] = _moduleconnectorwrapper.xtssRadarSettings_t_timingValue_set
    __swig_getmethods__["timingValue"] = _moduleconnectorwrapper.xtssRadarSettings_t_timingValue_get
    if _newclass:
        timingValue = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_timingValue_get, _moduleconnectorwrapper.xtssRadarSettings_t_timingValue_set)
    __swig_setmethods__["timingValueRaw"] = _moduleconnectorwrapper.xtssRadarSettings_t_timingValueRaw_set
    __swig_getmethods__["timingValueRaw"] = _moduleconnectorwrapper.xtssRadarSettings_t_timingValueRaw_get
    if _newclass:
        timingValueRaw = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_timingValueRaw_get, _moduleconnectorwrapper.xtssRadarSettings_t_timingValueRaw_set)
    __swig_setmethods__["PRF"] = _moduleconnectorwrapper.xtssRadarSettings_t_PRF_set
    __swig_getmethods__["PRF"] = _moduleconnectorwrapper.xtssRadarSettings_t_PRF_get
    if _newclass:
        PRF = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_PRF_get, _moduleconnectorwrapper.xtssRadarSettings_t_PRF_set)
    __swig_setmethods__["delayInCoarseMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInCoarseMeasured_set
    __swig_getmethods__["delayInCoarseMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInCoarseMeasured_get
    if _newclass:
        delayInCoarseMeasured = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayInCoarseMeasured_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayInCoarseMeasured_set)
    __swig_setmethods__["delayInMediumMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInMediumMeasured_set
    __swig_getmethods__["delayInMediumMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInMediumMeasured_get
    if _newclass:
        delayInMediumMeasured = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayInMediumMeasured_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayInMediumMeasured_set)
    __swig_setmethods__["delayInFineMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInFineMeasured_set
    __swig_getmethods__["delayInFineMeasured"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayInFineMeasured_get
    if _newclass:
        delayInFineMeasured = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayInFineMeasured_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayInFineMeasured_set)
    __swig_setmethods__["delayCoarseTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayCoarseTune_set
    __swig_getmethods__["delayCoarseTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayCoarseTune_get
    if _newclass:
        delayCoarseTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayCoarseTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayCoarseTune_set)
    __swig_setmethods__["delayMediumTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayMediumTune_set
    __swig_getmethods__["delayMediumTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayMediumTune_get
    if _newclass:
        delayMediumTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayMediumTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayMediumTune_set)
    __swig_setmethods__["delayFineTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayFineTune_set
    __swig_getmethods__["delayFineTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayFineTune_get
    if _newclass:
        delayFineTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayFineTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayFineTune_set)
    __swig_setmethods__["samplesPerSecond"] = _moduleconnectorwrapper.xtssRadarSettings_t_samplesPerSecond_set
    __swig_getmethods__["samplesPerSecond"] = _moduleconnectorwrapper.xtssRadarSettings_t_samplesPerSecond_get
    if _newclass:
        samplesPerSecond = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_samplesPerSecond_get, _moduleconnectorwrapper.xtssRadarSettings_t_samplesPerSecond_set)
    __swig_setmethods__["frameSize"] = _moduleconnectorwrapper.xtssRadarSettings_t_frameSize_set
    __swig_getmethods__["frameSize"] = _moduleconnectorwrapper.xtssRadarSettings_t_frameSize_get
    if _newclass:
        frameSize = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_frameSize_get, _moduleconnectorwrapper.xtssRadarSettings_t_frameSize_set)
    __swig_setmethods__["mediumInCoarseAverage"] = _moduleconnectorwrapper.xtssRadarSettings_t_mediumInCoarseAverage_set
    __swig_getmethods__["mediumInCoarseAverage"] = _moduleconnectorwrapper.xtssRadarSettings_t_mediumInCoarseAverage_get
    if _newclass:
        mediumInCoarseAverage = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_mediumInCoarseAverage_get, _moduleconnectorwrapper.xtssRadarSettings_t_mediumInCoarseAverage_set)
    __swig_setmethods__["fineInMediumAverage"] = _moduleconnectorwrapper.xtssRadarSettings_t_fineInMediumAverage_set
    __swig_getmethods__["fineInMediumAverage"] = _moduleconnectorwrapper.xtssRadarSettings_t_fineInMediumAverage_get
    if _newclass:
        fineInMediumAverage = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_fineInMediumAverage_get, _moduleconnectorwrapper.xtssRadarSettings_t_fineInMediumAverage_set)
    __swig_setmethods__["delayLengthCoarseTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthCoarseTune_set
    __swig_getmethods__["delayLengthCoarseTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthCoarseTune_get
    if _newclass:
        delayLengthCoarseTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayLengthCoarseTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthCoarseTune_set)
    __swig_setmethods__["delayLengthMediumTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthMediumTune_set
    __swig_getmethods__["delayLengthMediumTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthMediumTune_get
    if _newclass:
        delayLengthMediumTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayLengthMediumTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthMediumTune_set)
    __swig_setmethods__["delayLengthFineTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthFineTune_set
    __swig_getmethods__["delayLengthFineTune"] = _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthFineTune_get
    if _newclass:
        delayLengthFineTune = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_delayLengthFineTune_get, _moduleconnectorwrapper.xtssRadarSettings_t_delayLengthFineTune_set)
    __swig_setmethods__["stopWatchInitialized"] = _moduleconnectorwrapper.xtssRadarSettings_t_stopWatchInitialized_set
    __swig_getmethods__["stopWatchInitialized"] = _moduleconnectorwrapper.xtssRadarSettings_t_stopWatchInitialized_get
    if _newclass:
        stopWatchInitialized = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_stopWatchInitialized_get, _moduleconnectorwrapper.xtssRadarSettings_t_stopWatchInitialized_set)
    __swig_setmethods__["frameLengths"] = _moduleconnectorwrapper.xtssRadarSettings_t_frameLengths_set
    __swig_getmethods__["frameLengths"] = _moduleconnectorwrapper.xtssRadarSettings_t_frameLengths_get
    if _newclass:
        frameLengths = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_frameLengths_get, _moduleconnectorwrapper.xtssRadarSettings_t_frameLengths_set)
    __swig_setmethods__["origSampleDelayLength"] = _moduleconnectorwrapper.xtssRadarSettings_t_origSampleDelayLength_set
    __swig_getmethods__["origSampleDelayLength"] = _moduleconnectorwrapper.xtssRadarSettings_t_origSampleDelayLength_get
    if _newclass:
        origSampleDelayLength = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_origSampleDelayLength_get, _moduleconnectorwrapper.xtssRadarSettings_t_origSampleDelayLength_set)
    __swig_setmethods__["sampleDelayLengthError"] = _moduleconnectorwrapper.xtssRadarSettings_t_sampleDelayLengthError_set
    __swig_getmethods__["sampleDelayLengthError"] = _moduleconnectorwrapper.xtssRadarSettings_t_sampleDelayLengthError_get
    if _newclass:
        sampleDelayLengthError = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_sampleDelayLengthError_get, _moduleconnectorwrapper.xtssRadarSettings_t_sampleDelayLengthError_set)
    __swig_setmethods__["PGDelay"] = _moduleconnectorwrapper.xtssRadarSettings_t_PGDelay_set
    __swig_getmethods__["PGDelay"] = _moduleconnectorwrapper.xtssRadarSettings_t_PGDelay_get
    if _newclass:
        PGDelay = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_PGDelay_get, _moduleconnectorwrapper.xtssRadarSettings_t_PGDelay_set)
    __swig_setmethods__["chekcsum"] = _moduleconnectorwrapper.xtssRadarSettings_t_chekcsum_set
    __swig_getmethods__["chekcsum"] = _moduleconnectorwrapper.xtssRadarSettings_t_chekcsum_get
    if _newclass:
        chekcsum = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_chekcsum_get, _moduleconnectorwrapper.xtssRadarSettings_t_chekcsum_set)
    __swig_setmethods__["modified"] = _moduleconnectorwrapper.xtssRadarSettings_t_modified_set
    __swig_getmethods__["modified"] = _moduleconnectorwrapper.xtssRadarSettings_t_modified_get
    if _newclass:
        modified = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_modified_get, _moduleconnectorwrapper.xtssRadarSettings_t_modified_set)
    __swig_setmethods__["cfgPulsesPerStep"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgPulsesPerStep_set
    __swig_getmethods__["cfgPulsesPerStep"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgPulsesPerStep_get
    if _newclass:
        cfgPulsesPerStep = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgPulsesPerStep_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgPulsesPerStep_set)
    __swig_setmethods__["cfgIterations"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgIterations_set
    __swig_getmethods__["cfgIterations"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgIterations_get
    if _newclass:
        cfgIterations = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgIterations_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgIterations_set)
    __swig_setmethods__["cfgDACStep"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACStep_set
    __swig_getmethods__["cfgDACStep"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACStep_get
    if _newclass:
        cfgDACStep = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgDACStep_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACStep_set)
    __swig_setmethods__["cfgDACMin"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMin_set
    __swig_getmethods__["cfgDACMin"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMin_get
    if _newclass:
        cfgDACMin = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMin_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMin_set)
    __swig_setmethods__["cfgDACMax"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMax_set
    __swig_getmethods__["cfgDACMax"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMax_get
    if _newclass:
        cfgDACMax = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMax_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACMax_set)
    __swig_setmethods__["cfgPGSelect"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgPGSelect_set
    __swig_getmethods__["cfgPGSelect"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgPGSelect_get
    if _newclass:
        cfgPGSelect = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgPGSelect_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgPGSelect_set)
    __swig_setmethods__["cfgMClkDiv"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgMClkDiv_set
    __swig_getmethods__["cfgMClkDiv"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgMClkDiv_get
    if _newclass:
        cfgMClkDiv = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgMClkDiv_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgMClkDiv_set)
    __swig_setmethods__["cfgStaggeredPRFEnable"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgStaggeredPRFEnable_set
    __swig_getmethods__["cfgStaggeredPRFEnable"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgStaggeredPRFEnable_get
    if _newclass:
        cfgStaggeredPRFEnable = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgStaggeredPRFEnable_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgStaggeredPRFEnable_set)
    __swig_setmethods__["cfgSampleDelay"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgSampleDelay_set
    __swig_getmethods__["cfgSampleDelay"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgSampleDelay_get
    if _newclass:
        cfgSampleDelay = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgSampleDelay_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgSampleDelay_set)
    __swig_setmethods__["cfgDACAuto"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACAuto_set
    __swig_getmethods__["cfgDACAuto"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACAuto_get
    if _newclass:
        cfgDACAuto = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgDACAuto_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgDACAuto_set)
    __swig_setmethods__["cfgFPS"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgFPS_set
    __swig_getmethods__["cfgFPS"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgFPS_get
    if _newclass:
        cfgFPS = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgFPS_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgFPS_set)
    __swig_setmethods__["cfgFrameStitch"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgFrameStitch_set
    __swig_getmethods__["cfgFrameStitch"] = _moduleconnectorwrapper.xtssRadarSettings_t_cfgFrameStitch_get
    if _newclass:
        cfgFrameStitch = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_cfgFrameStitch_get, _moduleconnectorwrapper.xtssRadarSettings_t_cfgFrameStitch_set)
    __swig_setmethods__["carrierFreqFromPG"] = _moduleconnectorwrapper.xtssRadarSettings_t_carrierFreqFromPG_set
    __swig_getmethods__["carrierFreqFromPG"] = _moduleconnectorwrapper.xtssRadarSettings_t_carrierFreqFromPG_get
    if _newclass:
        carrierFreqFromPG = _swig_property(_moduleconnectorwrapper.xtssRadarSettings_t_carrierFreqFromPG_get, _moduleconnectorwrapper.xtssRadarSettings_t_carrierFreqFromPG_set)

    def __init__(self):
        """__init__(xtssRadarSettings_t self) -> xtssRadarSettings_t"""
        this = _moduleconnectorwrapper.new_xtssRadarSettings_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_xtssRadarSettings_t
    __del__ = lambda self: None
xtssRadarSettings_t_swigregister = _moduleconnectorwrapper.xtssRadarSettings_t_swigregister
xtssRadarSettings_t_swigregister(xtssRadarSettings_t)

class xtsUserRadarPerformanceStatus_t(_object):
    """Proxy of C++ xtsUserRadarPerformanceStatus_t class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, xtsUserRadarPerformanceStatus_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, xtsUserRadarPerformanceStatus_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["swRadarSweep"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarSweep_set
    __swig_getmethods__["swRadarSweep"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarSweep_get
    if _newclass:
        swRadarSweep = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarSweep_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarSweep_set)
    __swig_setmethods__["swRadarCaptureFrame"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarCaptureFrame_set
    __swig_getmethods__["swRadarCaptureFrame"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarCaptureFrame_get
    if _newclass:
        swRadarCaptureFrame = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarCaptureFrame_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarCaptureFrame_set)
    __swig_setmethods__["swRadarNormalizeFrame"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarNormalizeFrame_set
    __swig_getmethods__["swRadarNormalizeFrame"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarNormalizeFrame_get
    if _newclass:
        swRadarNormalizeFrame = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarNormalizeFrame_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swRadarNormalizeFrame_set)
    __swig_setmethods__["swDoPrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoPrimary_set
    __swig_getmethods__["swDoPrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoPrimary_get
    if _newclass:
        swDoPrimary = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoPrimary_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoPrimary_set)
    __swig_setmethods__["swDoSecondary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoSecondary_set
    __swig_getmethods__["swDoSecondary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoSecondary_get
    if _newclass:
        swDoSecondary = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoSecondary_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoSecondary_set)
    __swig_setmethods__["swDoOutput"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoOutput_set
    __swig_getmethods__["swDoOutput"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoOutput_get
    if _newclass:
        swDoOutput = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoOutput_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swDoOutput_set)
    __swig_setmethods__["frameStitch"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_frameStitch_set
    __swig_getmethods__["frameStitch"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_frameStitch_get
    if _newclass:
        frameStitch = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_frameStitch_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_frameStitch_set)
    __swig_setmethods__["FPS"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_FPS_set
    __swig_getmethods__["FPS"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_FPS_get
    if _newclass:
        FPS = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_FPS_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_FPS_set)
    __swig_setmethods__["overflowRadarTrigger"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowRadarTrigger_set
    __swig_getmethods__["overflowRadarTrigger"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowRadarTrigger_get
    if _newclass:
        overflowRadarTrigger = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowRadarTrigger_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowRadarTrigger_set)
    __swig_setmethods__["overflowPrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowPrimary_set
    __swig_getmethods__["overflowPrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowPrimary_get
    if _newclass:
        overflowPrimary = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowPrimary_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowPrimary_set)
    __swig_setmethods__["overflowOutput"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowOutput_set
    __swig_getmethods__["overflowOutput"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowOutput_get
    if _newclass:
        overflowOutput = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowOutput_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_overflowOutput_set)
    __swig_setmethods__["memSysStackUntouched"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memSysStackUntouched_set
    __swig_getmethods__["memSysStackUntouched"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memSysStackUntouched_get
    if _newclass:
        memSysStackUntouched = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memSysStackUntouched_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memSysStackUntouched_set)
    __swig_setmethods__["memOSHeap"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memOSHeap_set
    __swig_getmethods__["memOSHeap"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memOSHeap_get
    if _newclass:
        memOSHeap = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memOSHeap_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memOSHeap_set)
    __swig_setmethods__["memTaskRadar"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskRadar_set
    __swig_getmethods__["memTaskRadar"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskRadar_get
    if _newclass:
        memTaskRadar = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskRadar_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskRadar_set)
    __swig_setmethods__["memTaskAppEnginePrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEnginePrimary_set
    __swig_getmethods__["memTaskAppEnginePrimary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEnginePrimary_get
    if _newclass:
        memTaskAppEnginePrimary = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEnginePrimary_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEnginePrimary_set)
    __swig_setmethods__["memTaskAppEngineSecondary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEngineSecondary_set
    __swig_getmethods__["memTaskAppEngineSecondary"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEngineSecondary_get
    if _newclass:
        memTaskAppEngineSecondary = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEngineSecondary_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskAppEngineSecondary_set)
    __swig_setmethods__["memTaskSystem"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskSystem_set
    __swig_getmethods__["memTaskSystem"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskSystem_get
    if _newclass:
        memTaskSystem = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskSystem_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskSystem_set)
    __swig_setmethods__["memTaskUartRx"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartRx_set
    __swig_getmethods__["memTaskUartRx"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartRx_get
    if _newclass:
        memTaskUartRx = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartRx_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartRx_set)
    __swig_setmethods__["memTaskUartTx"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartTx_set
    __swig_getmethods__["memTaskUartTx"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartTx_get
    if _newclass:
        memTaskUartTx = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartTx_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_memTaskUartTx_set)
    __swig_setmethods__["idleTicks"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_idleTicks_set
    __swig_getmethods__["idleTicks"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_idleTicks_get
    if _newclass:
        idleTicks = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_idleTicks_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_idleTicks_set)
    __swig_setmethods__["comTxBufHighWatermark"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_comTxBufHighWatermark_set
    __swig_getmethods__["comTxBufHighWatermark"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_comTxBufHighWatermark_get
    if _newclass:
        comTxBufHighWatermark = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_comTxBufHighWatermark_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_comTxBufHighWatermark_set)
    __swig_setmethods__["periodSystemTicks"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_periodSystemTicks_set
    __swig_getmethods__["periodSystemTicks"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_periodSystemTicks_get
    if _newclass:
        periodSystemTicks = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_periodSystemTicks_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_periodSystemTicks_set)
    __swig_setmethods__["lastSystemTick"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_lastSystemTick_set
    __swig_getmethods__["lastSystemTick"] = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_lastSystemTick_get
    if _newclass:
        lastSystemTick = _swig_property(_moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_lastSystemTick_get, _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_lastSystemTick_set)

    def __init__(self):
        """__init__(xtsUserRadarPerformanceStatus_t self) -> xtsUserRadarPerformanceStatus_t"""
        this = _moduleconnectorwrapper.new_xtsUserRadarPerformanceStatus_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _moduleconnectorwrapper.delete_xtsUserRadarPerformanceStatus_t
    __del__ = lambda self: None
xtsUserRadarPerformanceStatus_t_swigregister = _moduleconnectorwrapper.xtsUserRadarPerformanceStatus_t_swigregister
xtsUserRadarPerformanceStatus_t_swigregister(xtsUserRadarPerformanceStatus_t)

XTS_ID_APP_UNKNOWN = _moduleconnectorwrapper.XTS_ID_APP_UNKNOWN
XTS_ID_APP_PRESENCE = _moduleconnectorwrapper.XTS_ID_APP_PRESENCE
XTS_ID_APP_RESP = _moduleconnectorwrapper.XTS_ID_APP_RESP
XTS_ID_APP_SLEEP = _moduleconnectorwrapper.XTS_ID_APP_SLEEP
XTS_ID_APP_RESPIRATION_2 = _moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_2
XTS_ID_APP_RESPIRATION_3 = _moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_3
XTS_ID_APP_RESPIRATION_4 = _moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_4
XTS_ID_APP_RESPIRATION_5 = _moduleconnectorwrapper.XTS_ID_APP_RESPIRATION_5
XTS_ID_APP_HEARTRATE = _moduleconnectorwrapper.XTS_ID_APP_HEARTRATE
XTS_ID_APP_DECIM = _moduleconnectorwrapper.XTS_ID_APP_DECIM
XTS_ID_APP_PRESENCE_2 = _moduleconnectorwrapper.XTS_ID_APP_PRESENCE_2
XTS_ID_APP_PRESENCE_3 = _moduleconnectorwrapper.XTS_ID_APP_PRESENCE_3
XTS_ID_APP_PRESENCE_3_DEBUG = _moduleconnectorwrapper.XTS_ID_APP_PRESENCE_3_DEBUG
XTS_ID_APP_HIGHBAY_1 = _moduleconnectorwrapper.XTS_ID_APP_HIGHBAY_1
XTS_ID_APP_HIGHBAY_1_DEBUG = _moduleconnectorwrapper.XTS_ID_APP_HIGHBAY_1_DEBUG
XTS_ID_APP_RADAR = _moduleconnectorwrapper.XTS_ID_APP_RADAR
XTS_ID_RADAR_RF = _moduleconnectorwrapper.XTS_ID_RADAR_RF
XTS_ID_RADAR_RF_NORMALIZED = _moduleconnectorwrapper.XTS_ID_RADAR_RF_NORMALIZED
XTS_ID_RADAR_BASEBAND_FLOAT = _moduleconnectorwrapper.XTS_ID_RADAR_BASEBAND_FLOAT
XTS_ID_RADAR_BASEBAND_Q15 = _moduleconnectorwrapper.XTS_ID_RADAR_BASEBAND_Q15
XTS_ID_DETECTION_ZONE = _moduleconnectorwrapper.XTS_ID_DETECTION_ZONE
XTS_ID_APPLICATION_USER_ZONE = _moduleconnectorwrapper.XTS_ID_APPLICATION_USER_ZONE
XTS_ID_DETECTION_ZONE_LIMITS = _moduleconnectorwrapper.XTS_ID_DETECTION_ZONE_LIMITS
XTS_ID_SENSITIVITY = _moduleconnectorwrapper.XTS_ID_SENSITIVITY
XTS_ID_PRESENCE_STATUS = _moduleconnectorwrapper.XTS_ID_PRESENCE_STATUS
XTS_ID_RESP_STATUS = _moduleconnectorwrapper.XTS_ID_RESP_STATUS
XTS_ID_RESP_STATUS_EXT = _moduleconnectorwrapper.XTS_ID_RESP_STATUS_EXT
XTS_ID_SLEEP_STATUS = _moduleconnectorwrapper.XTS_ID_SLEEP_STATUS
XTS_ID_PRESENCE_SINGLE = _moduleconnectorwrapper.XTS_ID_PRESENCE_SINGLE
XTS_ID_PRESENCE_MOVINGLIST = _moduleconnectorwrapper.XTS_ID_PRESENCE_MOVINGLIST
XTS_ID_PROFILE_PARAMETERFILE = _moduleconnectorwrapper.XTS_ID_PROFILE_PARAMETERFILE
XTS_ID_BASEBAND_IQ = _moduleconnectorwrapper.XTS_ID_BASEBAND_IQ
XTS_ID_BASEBAND_AMPLITUDE_PHASE = _moduleconnectorwrapper.XTS_ID_BASEBAND_AMPLITUDE_PHASE
XTS_ID_DECIM_STATUS = _moduleconnectorwrapper.XTS_ID_DECIM_STATUS
XTS_ID_PULSEDOPPLER_FLOAT = _moduleconnectorwrapper.XTS_ID_PULSEDOPPLER_FLOAT
XTS_ID_PULSEDOPPLER_BYTE = _moduleconnectorwrapper.XTS_ID_PULSEDOPPLER_BYTE
XTS_ID_NOISEMAP_FLOAT = _moduleconnectorwrapper.XTS_ID_NOISEMAP_FLOAT
XTS_ID_NOISEMAP_BYTE = _moduleconnectorwrapper.XTS_ID_NOISEMAP_BYTE
XTS_ID_RESPIRATION_MOVINGLIST = _moduleconnectorwrapper.XTS_ID_RESPIRATION_MOVINGLIST
XTS_ID_RESPIRATION_MOVEMENTLIST = _moduleconnectorwrapper.XTS_ID_RESPIRATION_MOVEMENTLIST
XTS_ID_RESPIRATION_DETECTIONLIST = _moduleconnectorwrapper.XTS_ID_RESPIRATION_DETECTIONLIST
XTS_ID_RESPIRATION_NORMALIZEDMOVEMENTLIST = _moduleconnectorwrapper.XTS_ID_RESPIRATION_NORMALIZEDMOVEMENTLIST
XTS_ID_VITAL_SIGNS = _moduleconnectorwrapper.XTS_ID_VITAL_SIGNS
XTS_ID_SLEEPSTAGE = _moduleconnectorwrapper.XTS_ID_SLEEPSTAGE
XTS_ID_TX_CENTER_FREQ = _moduleconnectorwrapper.XTS_ID_TX_CENTER_FREQ
XTS_ID_LED_CONTROL = _moduleconnectorwrapper.XTS_ID_LED_CONTROL
XTID_SSIC_ITEMNUMBER = _moduleconnectorwrapper.XTID_SSIC_ITEMNUMBER
XTID_SSIC_ORDERCODE = _moduleconnectorwrapper.XTID_SSIC_ORDERCODE
XTID_SSIC_FIRMWAREID = _moduleconnectorwrapper.XTID_SSIC_FIRMWAREID
XTID_SSIC_VERSION = _moduleconnectorwrapper.XTID_SSIC_VERSION
XTID_SSIC_BUILD = _moduleconnectorwrapper.XTID_SSIC_BUILD
XTID_SSIC_SERIALNUMBER = _moduleconnectorwrapper.XTID_SSIC_SERIALNUMBER
XTID_SSIC_VERSIONLIST = _moduleconnectorwrapper.XTID_SSIC_VERSIONLIST
XTID_SSIC_SYSTEMCOREID = _moduleconnectorwrapper.XTID_SSIC_SYSTEMCOREID
XTID_SSIC_BOOTLOADER = _moduleconnectorwrapper.XTID_SSIC_BOOTLOADER
XTID_SM_RUN = _moduleconnectorwrapper.XTID_SM_RUN
XTID_SM_NORMAL = _moduleconnectorwrapper.XTID_SM_NORMAL
XTID_SM_IDLE = _moduleconnectorwrapper.XTID_SM_IDLE
XTID_SM_MANUAL = _moduleconnectorwrapper.XTID_SM_MANUAL
XTID_SM_STOP = _moduleconnectorwrapper.XTID_SM_STOP
XTID_FIM_LOOP = _moduleconnectorwrapper.XTID_FIM_LOOP
XTID_FIM_SEQUENTIAL = _moduleconnectorwrapper.XTID_FIM_SEQUENTIAL
XTID_FIM_SINGLE = _moduleconnectorwrapper.XTID_FIM_SINGLE
XTID_BAUDRATE_9600 = _moduleconnectorwrapper.XTID_BAUDRATE_9600
XTID_BAUDRATE_19200 = _moduleconnectorwrapper.XTID_BAUDRATE_19200
XTID_BAUDRATE_38400 = _moduleconnectorwrapper.XTID_BAUDRATE_38400
XTID_BAUDRATE_115200 = _moduleconnectorwrapper.XTID_BAUDRATE_115200
XTID_BAUDRATE_230400 = _moduleconnectorwrapper.XTID_BAUDRATE_230400
XTID_BAUDRATE_460800 = _moduleconnectorwrapper.XTID_BAUDRATE_460800
XTID_BAUDRATE_500000 = _moduleconnectorwrapper.XTID_BAUDRATE_500000
XTID_BAUDRATE_576000 = _moduleconnectorwrapper.XTID_BAUDRATE_576000
XTID_BAUDRATE_921600 = _moduleconnectorwrapper.XTID_BAUDRATE_921600
XTID_BAUDRATE_1000000 = _moduleconnectorwrapper.XTID_BAUDRATE_1000000
XTID_BAUDRATE_2000000 = _moduleconnectorwrapper.XTID_BAUDRATE_2000000
XTID_BAUDRATE_3000000 = _moduleconnectorwrapper.XTID_BAUDRATE_3000000
XTID_BAUDRATE_4000000 = _moduleconnectorwrapper.XTID_BAUDRATE_4000000
XTID_IOPIN_SETUP_INPUT = _moduleconnectorwrapper.XTID_IOPIN_SETUP_INPUT
XTID_IOPIN_SETUP_OUTPUT = _moduleconnectorwrapper.XTID_IOPIN_SETUP_OUTPUT
XTID_IOPIN_SETUP_PUSH_PULL = _moduleconnectorwrapper.XTID_IOPIN_SETUP_PUSH_PULL
XTID_IOPIN_SETUP_INVERTED = _moduleconnectorwrapper.XTID_IOPIN_SETUP_INVERTED
XTID_IOPIN_SETUP_PULLUP = _moduleconnectorwrapper.XTID_IOPIN_SETUP_PULLUP
XTID_IOPIN_FEATURE_DISABLE = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_DISABLE
XTID_IOPIN_FEATURE_DEFAULT = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_DEFAULT
XTID_IOPIN_FEATURE_PASSIVE = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_PASSIVE
XTID_IOPIN_FEATURE_PRESENCE = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_PRESENCE
XTID_IOPIN_FEATURE_MOVEMENT = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_MOVEMENT
XTID_IOPIN_FEATURE_BREATHING = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_BREATHING
XTID_IOPIN_FEATURE_NOPRESENCE = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_NOPRESENCE
XTID_IOPIN_FEATURE_LAST = _moduleconnectorwrapper.XTID_IOPIN_FEATURE_LAST
XTID_OUTPUT_CONTROL_DISABLE = _moduleconnectorwrapper.XTID_OUTPUT_CONTROL_DISABLE
XTID_OUTPUT_CONTROL_ENABLE = _moduleconnectorwrapper.XTID_OUTPUT_CONTROL_ENABLE
XTID_OUTPUT_CONTROL_DEBUG = _moduleconnectorwrapper.XTID_OUTPUT_CONTROL_DEBUG
XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE = _moduleconnectorwrapper.XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE
XTID_OUTPUT_CONTROL_PD_FAST_ENABLE = _moduleconnectorwrapper.XTID_OUTPUT_CONTROL_PD_FAST_ENABLE
XTID_NOISEMAP_CONTROL_USE_DEFAULT = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_USE_DEFAULT
XTID_NOISEMAP_CONTROL_DISABLE = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_DISABLE
XTID_NOISEMAP_CONTROL_ENABLE = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_ENABLE
XTID_NOISEMAP_CONTROL_NONADAPTIVE = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_NONADAPTIVE
XTID_NOISEMAP_CONTROL_ADAPTIVE = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_ADAPTIVE
XTID_NOISEMAP_CONTROL_USE_STORED = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_USE_STORED
XTID_NOISEMAP_CONTROL_INIT_ON_RESET = _moduleconnectorwrapper.XTID_NOISEMAP_CONTROL_INIT_ON_RESET
XTID_LED_MODE_OFF = _moduleconnectorwrapper.XTID_LED_MODE_OFF
XTID_LED_MODE_SIMPLE = _moduleconnectorwrapper.XTID_LED_MODE_SIMPLE
XTID_LED_MODE_FULL = _moduleconnectorwrapper.XTID_LED_MODE_FULL
XTID_CENTER_FREQ_LOWBAND = _moduleconnectorwrapper.XTID_CENTER_FREQ_LOWBAND
XTID_CENTER_FREQ_HIGHBAND = _moduleconnectorwrapper.XTID_CENTER_FREQ_HIGHBAND
XTID_MCP_ERROR_NOT_RECOGNIZED = _moduleconnectorwrapper.XTID_MCP_ERROR_NOT_RECOGNIZED
XTS_VAL_RESP_STATE_BREATHING = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_BREATHING
XTS_VAL_RESP_STATE_MOVEMENT = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_MOVEMENT
XTS_VAL_RESP_STATE_MOVEMENT_TRACKING = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_MOVEMENT_TRACKING
XTS_VAL_RESP_STATE_NO_MOVEMENT = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_NO_MOVEMENT
XTS_VAL_RESP_STATE_INITIALIZING = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_INITIALIZING
XTS_VAL_RESP_STATE_ERROR = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_ERROR
XTS_VAL_RESP_STATE_UNKNOWN = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_UNKNOWN
XTS_VAL_RESP_STATE_HEART_RATE_AND_BREATHING = _moduleconnectorwrapper.XTS_VAL_RESP_STATE_HEART_RATE_AND_BREATHING
XTS_VAL_PRESENCE_PRESENCESTATE_NO_PRESENCE = _moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_NO_PRESENCE
XTS_VAL_PRESENCE_PRESENCESTATE_PRESENCE = _moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_PRESENCE
XTS_VAL_PRESENCE_PRESENCESTATE_INITIALIZING = _moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_INITIALIZING
XTS_VAL_PRESENCE_PRESENCESTATE_UNKNOWN = _moduleconnectorwrapper.XTS_VAL_PRESENCE_PRESENCESTATE_UNKNOWN
# This file is compatible with both classic and new-style classes.


