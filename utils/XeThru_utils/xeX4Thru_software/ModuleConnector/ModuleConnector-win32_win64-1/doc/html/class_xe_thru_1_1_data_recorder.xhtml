<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ModuleConnector: XeThru::DataRecorder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- Platform title -->
    <div class="page-title-bar container-fluid">
      <div id="projectalign" class="row">
        <div id="projectname" class="col-sm-12">ModuleConnector
          &#160;<span id="projectnumber">1.6.2</span>
        </div>
        <div id="projectbrief" class="col-sm-12">Project brief</div>
      </div>
    </div>
    <div class="topbar">
      <div class="container">
        <div id="titlearea">
          <div class="xethru-logo">
            <img src="xethru-logo_220x55HD.png" alt="Novelda XeThru web site" id="logo-image" />
          </div>
        </div>
        <!-- end header part -->
        <!-- Generated by Doxygen 1.8.12 -->
        <!--BEGIN MAIN-NAV AND SEARCHENGINE-->
        <div id="main-nav"></div>
        <!--END MAIN-NAV AND SEARCHENGINE-->
      </div>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_xe_thru.xhtml">XeThru</a></li><li class="navelem"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml">DataRecorder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_xe_thru_1_1_data_recorder-members.xhtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XeThru::DataRecorder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types to disk. ">DataRecorder</a> class allows recording of xethru data types to disk.  
 <a href="class_xe_thru_1_1_data_recorder.xhtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_data_recorder_8hpp_source.xhtml">DataRecorder.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7c474168931972cfeeb38ed7f08e46bb"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(<a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a>, const std::string &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a7c474168931972cfeeb38ed7f08e46bb">FileAvailableCallback</a></td></tr>
<tr class="memdesc:a7c474168931972cfeeb38ed7f08e46bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for std::function&lt;void(Xethru::DataType, const std::string&amp;)&gt;.  <a href="#a7c474168931972cfeeb38ed7f08e46bb">More...</a><br /></td></tr>
<tr class="separator:a7c474168931972cfeeb38ed7f08e46bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8446ecbd31b9267f7b216c6cf9046cbf"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(const std::string &amp;, const std::string &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a8446ecbd31b9267f7b216c6cf9046cbf">MetaFileAvailableCallback</a></td></tr>
<tr class="memdesc:a8446ecbd31b9267f7b216c6cf9046cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for std::function&lt;void(const std::string&amp;, const std::string&amp;)&gt;.  <a href="#a8446ecbd31b9267f7b216c6cf9046cbf">More...</a><br /></td></tr>
<tr class="separator:a8446ecbd31b9267f7b216c6cf9046cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04db519592582f22b495688e7cc142f"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(const std::string &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#ab04db519592582f22b495688e7cc142f">RecordingErrorCallback</a></td></tr>
<tr class="memdesc:ab04db519592582f22b495688e7cc142f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for std::function&lt;void(const std::string &amp;)&gt;.  <a href="#ab04db519592582f22b495688e7cc142f">More...</a><br /></td></tr>
<tr class="separator:ab04db519592582f22b495688e7cc142f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab5268fda508fab3a32c275fbd421c845"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#ab5268fda508fab3a32c275fbd421c845">DataRecorder</a> ()</td></tr>
<tr class="memdesc:ab5268fda508fab3a32c275fbd421c845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs recorder.  <a href="#ab5268fda508fab3a32c275fbd421c845">More...</a><br /></td></tr>
<tr class="separator:ab5268fda508fab3a32c275fbd421c845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8d6fc698f9eff1345e6d84b0fe42fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a0d8d6fc698f9eff1345e6d84b0fe42fe">DataRecorder</a> (LockedRadarInterfacePtr &amp;radar_interface)</td></tr>
<tr class="memdesc:a0d8d6fc698f9eff1345e6d84b0fe42fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs recorder.  <a href="#a0d8d6fc698f9eff1345e6d84b0fe42fe">More...</a><br /></td></tr>
<tr class="separator:a0d8d6fc698f9eff1345e6d84b0fe42fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58accae9f0b39b0b214131ff2a71a74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#af58accae9f0b39b0b214131ff2a71a74">DataRecorder</a> (Logger &amp;logger)</td></tr>
<tr class="memdesc:af58accae9f0b39b0b214131ff2a71a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs recorder initialized with a logger.  <a href="#af58accae9f0b39b0b214131ff2a71a74">More...</a><br /></td></tr>
<tr class="separator:af58accae9f0b39b0b214131ff2a71a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d68c4c2b8c6916eccb27a511eef5db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a32d68c4c2b8c6916eccb27a511eef5db">~DataRecorder</a> ()</td></tr>
<tr class="memdesc:a32d68c4c2b8c6916eccb27a511eef5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the recorder.  <a href="#a32d68c4c2b8c6916eccb27a511eef5db">More...</a><br /></td></tr>
<tr class="separator:a32d68c4c2b8c6916eccb27a511eef5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ec22bd31d182f08452c1bfcaf8cf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a0c0ec22bd31d182f08452c1bfcaf8cf6">start_recording</a> (<a class="el" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">XeThru::DataTypes</a> data_types, const std::string &amp;directory, const <a class="el" href="class_xe_thru_1_1_recording_options.xhtml">XeThru::RecordingOptions</a> &amp;options=<a class="el" href="class_xe_thru_1_1_recording_options.xhtml">XeThru::RecordingOptions</a>())</td></tr>
<tr class="memdesc:a0c0ec22bd31d182f08452c1bfcaf8cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts recording the specified data type(s) and output recorded files to the directory specified.  <a href="#a0c0ec22bd31d182f08452c1bfcaf8cf6">More...</a><br /></td></tr>
<tr class="separator:a0c0ec22bd31d182f08452c1bfcaf8cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b134e910ea00a9edf14a8dea7b25be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#ac3b134e910ea00a9edf14a8dea7b25be">stop_recording</a> (<a class="el" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">XeThru::DataTypes</a> data_types)</td></tr>
<tr class="memdesc:ac3b134e910ea00a9edf14a8dea7b25be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops recording the specified data type(s).  <a href="#ac3b134e910ea00a9edf14a8dea7b25be">More...</a><br /></td></tr>
<tr class="separator:ac3b134e910ea00a9edf14a8dea7b25be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f41cd9969ee450d4f657e5208fe173a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a2f41cd9969ee450d4f657e5208fe173a">is_recording</a> (<a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a> data_type) const</td></tr>
<tr class="separator:a2f41cd9969ee450d4f657e5208fe173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736098bcec20e9561d9354ce556dc3fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a736098bcec20e9561d9354ce556dc3fc">process</a> (<a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a> data_type, const Bytes &amp;data)</td></tr>
<tr class="memdesc:a736098bcec20e9561d9354ce556dc3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should not be used when recording data from a physical xethru device.  <a href="#a736098bcec20e9561d9354ce556dc3fc">More...</a><br /></td></tr>
<tr class="separator:a736098bcec20e9561d9354ce556dc3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c86f560481264af80cee9b7a5e5b86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a24c86f560481264af80cee9b7a5e5b86">subscribe_to_file_available</a> (<a class="el" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">DataTypes</a> data_types, const <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a7c474168931972cfeeb38ed7f08e46bb">FileAvailableCallback</a> &amp;callback)</td></tr>
<tr class="memdesc:a24c86f560481264af80cee9b7a5e5b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes to notifications when a recorded file for a data type is available.  <a href="#a24c86f560481264af80cee9b7a5e5b86">More...</a><br /></td></tr>
<tr class="separator:a24c86f560481264af80cee9b7a5e5b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5725c05b02ffac9d5991db898decc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#aaf5725c05b02ffac9d5991db898decc2">unsubscribe_to_file_available</a> (<a class="el" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">XeThru::DataTypes</a> data_types)</td></tr>
<tr class="memdesc:aaf5725c05b02ffac9d5991db898decc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribes to notifications when a recorded file for a data type is available.  <a href="#aaf5725c05b02ffac9d5991db898decc2">More...</a><br /></td></tr>
<tr class="separator:aaf5725c05b02ffac9d5991db898decc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2972e2177738e2a3404518325e9c4124"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a2972e2177738e2a3404518325e9c4124">subscribe_to_meta_file_available</a> (const <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a8446ecbd31b9267f7b216c6cf9046cbf">MetaFileAvailableCallback</a> &amp;callback)</td></tr>
<tr class="memdesc:a2972e2177738e2a3404518325e9c4124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes to notifications when a meta file is available.  <a href="#a2972e2177738e2a3404518325e9c4124">More...</a><br /></td></tr>
<tr class="separator:a2972e2177738e2a3404518325e9c4124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28266d06a8434134aa6c09d3ca43792"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#ac28266d06a8434134aa6c09d3ca43792">unsubscribe_to_meta_file_available</a> ()</td></tr>
<tr class="memdesc:ac28266d06a8434134aa6c09d3ca43792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribes to notifications when a meta file is available.  <a href="#ac28266d06a8434134aa6c09d3ca43792">More...</a><br /></td></tr>
<tr class="separator:ac28266d06a8434134aa6c09d3ca43792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1750f1a6083f60aec9fb743e8ee2ddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#af1750f1a6083f60aec9fb743e8ee2ddb">set_basename_for_data_type</a> (<a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a> data_type, const std::string &amp;name)</td></tr>
<tr class="memdesc:af1750f1a6083f60aec9fb743e8ee2ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the basename for the specified data type.  <a href="#af1750f1a6083f60aec9fb743e8ee2ddb">More...</a><br /></td></tr>
<tr class="separator:af1750f1a6083f60aec9fb743e8ee2ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418795b4615b9f113d92597ee59709c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a418795b4615b9f113d92597ee59709c1">get_basename_for_data_type</a> (<a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a> data_type) const</td></tr>
<tr class="memdesc:a418795b4615b9f113d92597ee59709c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the basename for the specified data type.  <a href="#a418795b4615b9f113d92597ee59709c1">More...</a><br /></td></tr>
<tr class="separator:a418795b4615b9f113d92597ee59709c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2af7eebc1d244f31db53d1237278a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a2a2af7eebc1d244f31db53d1237278a1">clear_basename_for_data_types</a> (<a class="el" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">XeThru::DataTypes</a> data_types)</td></tr>
<tr class="memdesc:a2a2af7eebc1d244f31db53d1237278a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the basename(s) to default value(s) for the specified data type(s).  <a href="#a2a2af7eebc1d244f31db53d1237278a1">More...</a><br /></td></tr>
<tr class="separator:a2a2af7eebc1d244f31db53d1237278a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1441d5a2dc144bf07d123cf956328a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a7a1441d5a2dc144bf07d123cf956328a">get_recording_directory</a> (const std::string &amp;session_id) const</td></tr>
<tr class="memdesc:a7a1441d5a2dc144bf07d123cf956328a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the output folder for the specified session id.  <a href="#a7a1441d5a2dc144bf07d123cf956328a">More...</a><br /></td></tr>
<tr class="separator:a7a1441d5a2dc144bf07d123cf956328a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835e090d998a74bca24f76c5885c3315"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a835e090d998a74bca24f76c5885c3315">get_recording_directory</a> (<a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a> data_type) const</td></tr>
<tr class="memdesc:a835e090d998a74bca24f76c5885c3315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the output folder for the specified data type.  <a href="#a835e090d998a74bca24f76c5885c3315">More...</a><br /></td></tr>
<tr class="separator:a835e090d998a74bca24f76c5885c3315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf7553621e6c115d37428770fe30945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a1bf7553621e6c115d37428770fe30945">set_error_callback</a> (<a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#ab04db519592582f22b495688e7cc142f">RecordingErrorCallback</a> callback)</td></tr>
<tr class="memdesc:a1bf7553621e6c115d37428770fe30945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply a function that will be called if an error occurs during recording.  <a href="#a1bf7553621e6c115d37428770fe30945">More...</a><br /></td></tr>
<tr class="separator:a1bf7553621e6c115d37428770fe30945"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8ae81b7bfb01230c62f075905e6651aa"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a8ae81b7bfb01230c62f075905e6651aa">data_type_to_string</a> (<a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a> data_type)</td></tr>
<tr class="memdesc:a8ae81b7bfb01230c62f075905e6651aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for converting data type to human readable string representation.  <a href="#a8ae81b7bfb01230c62f075905e6651aa">More...</a><br /></td></tr>
<tr class="separator:a8ae81b7bfb01230c62f075905e6651aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types to disk. ">DataRecorder</a> class allows recording of xethru data types to disk. </p>
<p>The <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types to disk. ">DataRecorder</a> class is a high level recorder class. It can be used to record all data types sent by a xethru device over serial port or similar. All low-level I/O is handled by the recorder itself with no setup required. Data is stored on disk as specified by the <a class="el" href="namespace_xe_thru.xhtml">XeThru</a> File Formats document and can be easily read back using the <a class="el" href="class_xe_thru_1_1_data_reader.xhtml">DataReader</a> class (read disk records) or <a class="el" href="class_xe_thru_1_1_data_player.xhtml">DataPlayer</a> class (playback disk records as binary packets).</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespace_xe_thru.xhtml">XeThru</a>;</div><div class="line"></div><div class="line">    <a class="code" href="class_xe_thru_1_1_module_connector.xhtml">ModuleConnector</a> mc(device_name, 3);</div><div class="line">    <a class="code" href="class_xe_thru_1_1_data_recorder.xhtml">DataRecorder</a> &amp;recorder = mc.get_data_recorder();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">DataTypes</a> data_types = BasebandApDataType | SleepDataType;</div><div class="line">    <span class="keyword">const</span> std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (recorder.<a class="code" href="class_xe_thru_1_1_data_recorder.xhtml#a0c0ec22bd31d182f08452c1bfcaf8cf6">start_recording</a>(data_types, output_directory) != 0) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to start recording&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Get interface for physical device and enable data output</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types to disk. ">DataRecorder</a> has no means to enable or disable data output on a physical xethru device. It simply records the specified data type(s) if sent by the module. Therefore, it is the user's responsibility to enable or disable data ouput on the module itself. If no data is sent, no data will be recorded.</dd></dl>
<p><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types to disk. ">DataRecorder</a> also supports more advance <em><a class="el" href="class_xe_thru_1_1_recording_options.xhtml" title="The RecordingOptions class allows specifying options for recording. ">RecordingOptions</a></em> such as splitting of files and directories.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a0c0ec22bd31d182f08452c1bfcaf8cf6" title="Starts recording the specified data type(s) and output recorded files to the directory specified...">start_recording</a>, <a class="el" href="class_xe_thru_1_1_recording_options.xhtml" title="The RecordingOptions class allows specifying options for recording. ">RecordingOptions</a>, <a class="el" href="class_xe_thru_1_1_data_reader.xhtml" title="The DataReader class allows reading of xethru data records from a recording generated by DataRecorder...">DataReader</a>, <a class="el" href="class_xe_thru_1_1_data_player.xhtml" title="The DataPlayer class allows playback of telegrams / binary packets from a recording generated by Data...">DataPlayer</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7c474168931972cfeeb38ed7f08e46bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c474168931972cfeeb38ed7f08e46bb">&sect;&nbsp;</a></span>FileAvailableCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(<a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a>, const std::string&amp;)&gt; <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a7c474168931972cfeeb38ed7f08e46bb">XeThru::DataRecorder::FileAvailableCallback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for std::function&lt;void(Xethru::DataType, const std::string&amp;)&gt;. </p>
<p>This type is used as callback parameter to subscribe_to_file_available.</p>
<p>Declare a standard function: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> on_file_available(<a class="code" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a> type, <span class="keyword">const</span> std::string &amp;filename)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;recorded file available for data type: &quot;</span></div><div class="line">              &lt;&lt; <a class="code" href="class_xe_thru_1_1_data_recorder.xhtml#a8ae81b7bfb01230c62f075905e6651aa">DataRecorder::data_type_to_string</a>(type) &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> Then construct the callback and pass as parameter: </p><div class="fragment"><div class="line">    <a class="code" href="class_xe_thru_1_1_data_recorder.xhtml#a7c474168931972cfeeb38ed7f08e46bb">DataRecorder::FileAvailableCallback</a> callback = std::bind(&amp;on_file_available,</div><div class="line">                                                             std::placeholders::_1,</div><div class="line">                                                             std::placeholders::_2);</div><div class="line">    recorder.<a class="code" href="class_xe_thru_1_1_data_recorder.xhtml#a24c86f560481264af80cee9b7a5e5b86">subscribe_to_file_available</a>(BasebandApDataType | SleepDataType, callback);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For C++ member functions use std::bind(&amp;Class::function, this, ...)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a24c86f560481264af80cee9b7a5e5b86" title="Subscribes to notifications when a recorded file for a data type is available. ">subscribe_to_file_available</a> </dd></dl>

</div>
</div>
<a id="a8446ecbd31b9267f7b216c6cf9046cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8446ecbd31b9267f7b216c6cf9046cbf">&sect;&nbsp;</a></span>MetaFileAvailableCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(const std::string &amp;, const std::string&amp;)&gt; <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a8446ecbd31b9267f7b216c6cf9046cbf">XeThru::DataRecorder::MetaFileAvailableCallback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for std::function&lt;void(const std::string&amp;, const std::string&amp;)&gt;. </p>
<p>This type is used as callback parameter to subscribe_to_meta_file_available.</p>
<p>Declare a standard function: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> on_meta_file_available(<span class="keyword">const</span> std::string &amp;session_id, <span class="keyword">const</span> std::string &amp;meta_filename)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;meta file available for recording with id: &quot;</span> &lt;&lt; session_id &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;file: &quot;</span> &lt;&lt; meta_filename &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> Then construct the callback and pass as parameter: </p><div class="fragment"><div class="line">    <a class="code" href="class_xe_thru_1_1_data_recorder.xhtml#a8446ecbd31b9267f7b216c6cf9046cbf">DataRecorder::MetaFileAvailableCallback</a> callback = std::bind(&amp;on_meta_file_available,</div><div class="line">                                                                 std::placeholders::_1,</div><div class="line">                                                                 std::placeholders::_2);</div><div class="line">    recorder.<a class="code" href="class_xe_thru_1_1_data_recorder.xhtml#a2972e2177738e2a3404518325e9c4124">subscribe_to_meta_file_available</a>(callback);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For C++ member functions use std::bind(&amp;Class::function, this, ...)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a2972e2177738e2a3404518325e9c4124" title="Subscribes to notifications when a meta file is available. ">subscribe_to_meta_file_available</a> </dd></dl>

</div>
</div>
<a id="ab04db519592582f22b495688e7cc142f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04db519592582f22b495688e7cc142f">&sect;&nbsp;</a></span>RecordingErrorCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(const std::string &amp;)&gt; <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#ab04db519592582f22b495688e7cc142f">XeThru::DataRecorder::RecordingErrorCallback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for std::function&lt;void(const std::string &amp;)&gt;. </p>
<p>This type is used as a callback parameter to <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a1bf7553621e6c115d37428770fe30945" title="Supply a function that will be called if an error occurs during recording. ">set_error_callback()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a1bf7553621e6c115d37428770fe30945" title="Supply a function that will be called if an error occurs during recording. ">set_error_callback</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab5268fda508fab3a32c275fbd421c845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5268fda508fab3a32c275fbd421c845">&sect;&nbsp;</a></span>DataRecorder() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::DataRecorder::DataRecorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs recorder. </p>

</div>
</div>
<a id="a0d8d6fc698f9eff1345e6d84b0fe42fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8d6fc698f9eff1345e6d84b0fe42fe">&sect;&nbsp;</a></span>DataRecorder() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::DataRecorder::DataRecorder </td>
          <td>(</td>
          <td class="paramtype">LockedRadarInterfacePtr &amp;&#160;</td>
          <td class="paramname"><em>radar_interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs recorder. </p>
<p>Only useful for internal use. </p>

</div>
</div>
<a id="af58accae9f0b39b0b214131ff2a71a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58accae9f0b39b0b214131ff2a71a74">&sect;&nbsp;</a></span>DataRecorder() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::DataRecorder::DataRecorder </td>
          <td>(</td>
          <td class="paramtype">Logger &amp;&#160;</td>
          <td class="paramname"><em>logger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs recorder initialized with a logger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>Specifies a logger to use when printing messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32d68c4c2b8c6916eccb27a511eef5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d68c4c2b8c6916eccb27a511eef5db">&sect;&nbsp;</a></span>~DataRecorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::DataRecorder::~DataRecorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the recorder. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2a2af7eebc1d244f31db53d1237278a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2af7eebc1d244f31db53d1237278a1">&sect;&nbsp;</a></span>clear_basename_for_data_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XeThru::DataRecorder::clear_basename_for_data_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">XeThru::DataTypes</a>&#160;</td>
          <td class="paramname"><em>data_types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the basename(s) to default value(s) for the specified data type(s). </p>
<p>Most users will not need this functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_types</td><td>DataTypes is a bitmask that consists of a combination of DataType flags. These flags can be combined with the bitwise OR operator (|). For example: BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can also be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#af1750f1a6083f60aec9fb743e8ee2ddb" title="Sets the basename for the specified data type. ">set_basename_for_data_type</a> </dd></dl>

</div>
</div>
<a id="a8ae81b7bfb01230c62f075905e6651aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae81b7bfb01230c62f075905e6651aa">&sect;&nbsp;</a></span>data_type_to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string XeThru::DataRecorder::data_type_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a>&#160;</td>
          <td class="paramname"><em>data_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method for converting data type to human readable string representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_type</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representation of the specified data type </dd></dl>

</div>
</div>
<a id="a418795b4615b9f113d92597ee59709c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418795b4615b9f113d92597ee59709c1">&sect;&nbsp;</a></span>get_basename_for_data_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XeThru::DataRecorder::get_basename_for_data_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a>&#160;</td>
          <td class="paramname"><em>data_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the basename for the specified data type. </p>
<p>Most users will not need this functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_type</td><td>Specifies the data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the basename for the specified data type </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#af1750f1a6083f60aec9fb743e8ee2ddb" title="Sets the basename for the specified data type. ">set_basename_for_data_type</a> </dd></dl>

</div>
</div>
<a id="a7a1441d5a2dc144bf07d123cf956328a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1441d5a2dc144bf07d123cf956328a">&sect;&nbsp;</a></span>get_recording_directory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XeThru::DataRecorder::get_recording_directory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>session_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the output folder for the specified session id. </p>
<p>The folder is relative to the directory specified in start_recording.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_id</td><td>Specifies the session id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output folder if a recording for the given session id is active, otherwise returns an empty string. </dd></dl>

</div>
</div>
<a id="a835e090d998a74bca24f76c5885c3315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835e090d998a74bca24f76c5885c3315">&sect;&nbsp;</a></span>get_recording_directory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XeThru::DataRecorder::get_recording_directory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a>&#160;</td>
          <td class="paramname"><em>data_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the output folder for the specified data type. </p>
<p>The folder is relative to the directory specified in start_recording.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_id</td><td>Specifies the data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output folder if a recording for the given data type is active, otherwise returns an empty string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a2f41cd9969ee450d4f657e5208fe173a">is_recording</a> </dd></dl>

</div>
</div>
<a id="a2f41cd9969ee450d4f657e5208fe173a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f41cd9969ee450d4f657e5208fe173a">&sect;&nbsp;</a></span>is_recording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XeThru::DataRecorder::is_recording </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a>&#160;</td>
          <td class="paramname"><em>data_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if recording is started for the specified data type, otherwise returns false </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a0c0ec22bd31d182f08452c1bfcaf8cf6" title="Starts recording the specified data type(s) and output recorded files to the directory specified...">start_recording</a> </dd></dl>

</div>
</div>
<a id="a736098bcec20e9561d9354ce556dc3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736098bcec20e9561d9354ce556dc3fc">&sect;&nbsp;</a></span>process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XeThru::DataRecorder::process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a>&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Bytes &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should not be used when recording data from a physical xethru device. </p>
<p>It is only relevant for recording data generated elsewhere. Most users will not need this functionality.</p>
<p>Process the specified data for a given data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_type</td><td>Specifies the data type to process </td></tr>
    <tr><td class="paramname">data</td><td>Specifies the bytes to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, otherwise returns false </dd></dl>

</div>
</div>
<a id="af1750f1a6083f60aec9fb743e8ee2ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1750f1a6083f60aec9fb743e8ee2ddb">&sect;&nbsp;</a></span>set_basename_for_data_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XeThru::DataRecorder::set_basename_for_data_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">XeThru::DataType</a>&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the basename for the specified data type. </p>
<p>Most users will not need this functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_type</td><td>Specifies the data type </td></tr>
    <tr><td class="paramname">name</td><td>Specifies the name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a418795b4615b9f113d92597ee59709c1" title="Gets the basename for the specified data type. ">get_basename_for_data_type</a>, <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a2a2af7eebc1d244f31db53d1237278a1" title="Resets the basename(s) to default value(s) for the specified data type(s). ">clear_basename_for_data_types</a> </dd></dl>

</div>
</div>
<a id="a1bf7553621e6c115d37428770fe30945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf7553621e6c115d37428770fe30945">&sect;&nbsp;</a></span>set_error_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XeThru::DataRecorder::set_error_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#ab04db519592582f22b495688e7cc142f">RecordingErrorCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply a function that will be called if an error occurs during recording. </p>
<p>Call this method with nullptr as argument to clear the callback. </p>

</div>
</div>
<a id="a0c0ec22bd31d182f08452c1bfcaf8cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0ec22bd31d182f08452c1bfcaf8cf6">&sect;&nbsp;</a></span>start_recording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::DataRecorder::start_recording </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">XeThru::DataTypes</a>&#160;</td>
          <td class="paramname"><em>data_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_xe_thru_1_1_recording_options.xhtml">XeThru::RecordingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="class_xe_thru_1_1_recording_options.xhtml">XeThru::RecordingOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts recording the specified data type(s) and output recorded files to the directory specified. </p>
<p>This command does not enable data output on the module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_types</td><td>DataTypes is a bitmask that consists of a combination of DataType flags. These flags can be combined with the bitwise OR operator (|). For example: BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can also be specified.</td></tr>
    <tr><td class="paramname">directory</td><td>Output folder where recorded files will be stored.</td></tr>
    <tr><td class="paramname">options</td><td>Specifies advanced options such as splitting of files and directories. By default, this parameter is RecordingOptions() (no advanced options).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_recording_options.xhtml" title="The RecordingOptions class allows specifying options for recording. ">RecordingOptions</a>, <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#ac3b134e910ea00a9edf14a8dea7b25be" title="Stops recording the specified data type(s). ">stop_recording</a> </dd></dl>

</div>
</div>
<a id="ac3b134e910ea00a9edf14a8dea7b25be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b134e910ea00a9edf14a8dea7b25be">&sect;&nbsp;</a></span>stop_recording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XeThru::DataRecorder::stop_recording </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">XeThru::DataTypes</a>&#160;</td>
          <td class="paramname"><em>data_types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops recording the specified data type(s). </p>
<p>This command does not disable data output on the module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_types</td><td>DataTypes is a bitmask that consists of a combination of DataType flags. These flags can be combined with the bitwise OR operator (|). For example: BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can also be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a0c0ec22bd31d182f08452c1bfcaf8cf6" title="Starts recording the specified data type(s) and output recorded files to the directory specified...">start_recording</a> </dd></dl>

</div>
</div>
<a id="a24c86f560481264af80cee9b7a5e5b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c86f560481264af80cee9b7a5e5b86">&sect;&nbsp;</a></span>subscribe_to_file_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::DataRecorder::subscribe_to_file_available </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">DataTypes</a>&#160;</td>
          <td class="paramname"><em>data_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a7c474168931972cfeeb38ed7f08e46bb">FileAvailableCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribes to notifications when a recorded file for a data type is available. </p>
<p>The callback is triggered when a new file is stored on disk, i.e. when module connector is done with the file and no longer will perform I/O operations on it. This usually triggers when recording is stopped or as a result of file splitting. In either case module connector will no longer hold any reference to the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_types</td><td>DataTypes is a bitmask that consists of a combination of DataType flags. These flags can be combined with the bitwise OR operator (|). For example: BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can also be specified.</td></tr>
    <tr><td class="paramname">callback</td><td>Specifies the function to be called when a recorded file is available. For example: void on_file_available(DataType type, const std::string &amp;filename)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a0c0ec22bd31d182f08452c1bfcaf8cf6" title="Starts recording the specified data type(s) and output recorded files to the directory specified...">start_recording</a>, <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#aaf5725c05b02ffac9d5991db898decc2" title="Unsubscribes to notifications when a recorded file for a data type is available. ">unsubscribe_to_file_available</a>, <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a7c474168931972cfeeb38ed7f08e46bb" title="Typedef for std::function&lt;void(Xethru::DataType, const std::string&amp;)&gt;. ">FileAvailableCallback</a> </dd></dl>

</div>
</div>
<a id="a2972e2177738e2a3404518325e9c4124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2972e2177738e2a3404518325e9c4124">&sect;&nbsp;</a></span>subscribe_to_meta_file_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::DataRecorder::subscribe_to_meta_file_available </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a8446ecbd31b9267f7b216c6cf9046cbf">MetaFileAvailableCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribes to notifications when a meta file is available. </p>
<p>The callback is triggered when a new meta file is stored on disk, i.e. when module connector is done with the file and no longer perform I/O operations on it. This usually triggers when recording is stopped or as a result of file/directory splitting. In either case module connector will no longer hold any reference to the file.</p>
<p>The meta file contains detailed information about a particular recording session. For example which data types and files were written during the session. This information is possible to extract via <em><a class="el" href="class_xe_thru_1_1_data_reader.xhtml" title="The DataReader class allows reading of xethru data records from a recording generated by DataRecorder...">DataReader</a></em> and allows for convenient readback of data from disk. The meta file is only intended for use with <em><a class="el" href="class_xe_thru_1_1_data_reader.xhtml" title="The DataReader class allows reading of xethru data records from a recording generated by DataRecorder...">DataReader</a></em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Specifies the function to be called when a meta file is available. For example: void on_meta_file_available(const std::string &amp;session_id, const std::string &amp;filename)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_reader.xhtml" title="The DataReader class allows reading of xethru data records from a recording generated by DataRecorder...">DataReader</a>, <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a0c0ec22bd31d182f08452c1bfcaf8cf6" title="Starts recording the specified data type(s) and output recorded files to the directory specified...">start_recording</a>, <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#ac28266d06a8434134aa6c09d3ca43792" title="Unsubscribes to notifications when a meta file is available. ">unsubscribe_to_meta_file_available</a>, <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a8446ecbd31b9267f7b216c6cf9046cbf" title="Typedef for std::function&lt;void(const std::string&amp;, const std::string&amp;)&gt;. ">MetaFileAvailableCallback</a>, <a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a24c86f560481264af80cee9b7a5e5b86" title="Subscribes to notifications when a recorded file for a data type is available. ">subscribe_to_file_available</a> </dd></dl>

</div>
</div>
<a id="aaf5725c05b02ffac9d5991db898decc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5725c05b02ffac9d5991db898decc2">&sect;&nbsp;</a></span>unsubscribe_to_file_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XeThru::DataRecorder::unsubscribe_to_file_available </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="datatypes_8h.xhtml#afb6eb4f28419b652027fad41104a6d22">XeThru::DataTypes</a>&#160;</td>
          <td class="paramname"><em>data_types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsubscribes to notifications when a recorded file for a data type is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_types</td><td>DataTypes is a bitmask that consists of a combination of DataType flags. These flags can be combined with the bitwise OR operator (|). For example: BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can also be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a24c86f560481264af80cee9b7a5e5b86" title="Subscribes to notifications when a recorded file for a data type is available. ">subscribe_to_file_available</a> </dd></dl>

</div>
</div>
<a id="ac28266d06a8434134aa6c09d3ca43792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28266d06a8434134aa6c09d3ca43792">&sect;&nbsp;</a></span>unsubscribe_to_meta_file_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::DataRecorder::unsubscribe_to_meta_file_available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsubscribes to notifications when a meta file is available. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_data_recorder.xhtml#a2972e2177738e2a3404518325e9c4124" title="Subscribes to notifications when a meta file is available. ">subscribe_to_meta_file_available</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_data_recorder_8hpp_source.xhtml">DataRecorder.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/>
 <address class="footer">
 Copyright &copy; 2016 Novelda AS - <a href="http://www.xethru.com">www.xehtru.com</a><br />
 <small>
  Generated by &#160;<a href="http://www.doxygen.org/index.html">
  <img class="footer" src="doxygen.png" alt="doxygen"/>
  </a> 1.8.12
 </small>
 </address>
</body>
</html>
