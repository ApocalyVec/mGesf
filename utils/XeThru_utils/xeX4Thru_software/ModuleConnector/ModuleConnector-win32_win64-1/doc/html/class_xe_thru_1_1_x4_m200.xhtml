<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ModuleConnector: XeThru::X4M200 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- Platform title -->
    <div class="page-title-bar container-fluid">
      <div id="projectalign" class="row">
        <div id="projectname" class="col-sm-12">ModuleConnector
          &#160;<span id="projectnumber">1.6.2</span>
        </div>
        <div id="projectbrief" class="col-sm-12">Project brief</div>
      </div>
    </div>
    <div class="topbar">
      <div class="container">
        <div id="titlearea">
          <div class="xethru-logo">
            <img src="xethru-logo_220x55HD.png" alt="Novelda XeThru web site" id="logo-image" />
          </div>
        </div>
        <!-- end header part -->
        <!-- Generated by Doxygen 1.8.12 -->
        <!--BEGIN MAIN-NAV AND SEARCHENGINE-->
        <div id="main-nav"></div>
        <!--END MAIN-NAV AND SEARCHENGINE-->
      </div>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_xe_thru.xhtml">XeThru</a></li><li class="navelem"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml">X4M200</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_xe_thru_1_1_x4_m200-members.xhtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XeThru::X4M200 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface to the Xethru <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> Application module.  
 <a href="class_xe_thru_1_1_x4_m200.xhtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_x4_m200_8hpp_source.xhtml">X4M200.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69a8c13fb828bbf27a3c24bcd82ee6ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a69a8c13fb828bbf27a3c24bcd82ee6ae">X4M200</a> (LockedRadarInterfacePtr &amp;radar_interface)</td></tr>
<tr class="memdesc:a69a8c13fb828bbf27a3c24bcd82ee6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a69a8c13fb828bbf27a3c24bcd82ee6ae">More...</a><br /></td></tr>
<tr class="separator:a69a8c13fb828bbf27a3c24bcd82ee6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6359bd91162372401c48b776f5df0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a1d6359bd91162372401c48b776f5df0c">~X4M200</a> ()</td></tr>
<tr class="memdesc:a1d6359bd91162372401c48b776f5df0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a1d6359bd91162372401c48b776f5df0c">More...</a><br /></td></tr>
<tr class="separator:a1d6359bd91162372401c48b776f5df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41104e3d2da276d8a1062a172a96314f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a41104e3d2da276d8a1062a172a96314f">set_debug_level</a> (unsigned char level)</td></tr>
<tr class="memdesc:a41104e3d2da276d8a1062a172a96314f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets debug level in the Xethru module.  <a href="#a41104e3d2da276d8a1062a172a96314f">More...</a><br /></td></tr>
<tr class="separator:a41104e3d2da276d8a1062a172a96314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c261955578f57a0a7ec90e358243d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a52c261955578f57a0a7ec90e358243d7">set_baudrate</a> (uint32_t baudrate)</td></tr>
<tr class="memdesc:a52c261955578f57a0a7ec90e358243d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set baudrate for serial communication during <a class="el" href="class_xe_thru_1_1_module_connector.xhtml" title="This class is responsible for establishing contact with the Xethru module. ">ModuleConnector</a> operation.  <a href="#a52c261955578f57a0a7ec90e358243d7">More...</a><br /></td></tr>
<tr class="separator:a52c261955578f57a0a7ec90e358243d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bf194b6c4db57768425a02bea776ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#af8bf194b6c4db57768425a02bea776ce">ping</a> (uint32_t *pong_value)</td></tr>
<tr class="memdesc:af8bf194b6c4db57768425a02bea776ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure there is a connection to firmware on the Xethru <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> module.  <a href="#af8bf194b6c4db57768425a02bea776ce">More...</a><br /></td></tr>
<tr class="separator:af8bf194b6c4db57768425a02bea776ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e9a8c13407ca3d45b0b11dca08ba33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a15e9a8c13407ca3d45b0b11dca08ba33">get_system_info</a> (const uint8_t info_code, std::string *system_info)</td></tr>
<tr class="memdesc:a15e9a8c13407ca3d45b0b11dca08ba33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing system information given by infocode:<br />
  <a href="#a15e9a8c13407ca3d45b0b11dca08ba33">More...</a><br /></td></tr>
<tr class="separator:a15e9a8c13407ca3d45b0b11dca08ba33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c541b6aeac38360b6b8b7132f36f086"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a4c541b6aeac38360b6b8b7132f36f086">reset</a> ()</td></tr>
<tr class="memdesc:a4c541b6aeac38360b6b8b7132f36f086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets and restart the module.  <a href="#a4c541b6aeac38360b6b8b7132f36f086">More...</a><br /></td></tr>
<tr class="separator:a4c541b6aeac38360b6b8b7132f36f086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0e2fa9756ab51bb666d49abcbd7b5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a6a0e2fa9756ab51bb666d49abcbd7b5f">module_reset</a> ()</td></tr>
<tr class="memdesc:a6a0e2fa9756ab51bb666d49abcbd7b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the module.  <a href="#a6a0e2fa9756ab51bb666d49abcbd7b5f">More...</a><br /></td></tr>
<tr class="separator:a6a0e2fa9756ab51bb666d49abcbd7b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7373c8d262cfbcaf1fd4bc5b81a8154f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a7373c8d262cfbcaf1fd4bc5b81a8154f">reset_to_factory_preset</a> ()</td></tr>
<tr class="memdesc:a7373c8d262cfbcaf1fd4bc5b81a8154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all parameters in the module to factory presets.  <a href="#a7373c8d262cfbcaf1fd4bc5b81a8154f">More...</a><br /></td></tr>
<tr class="separator:a7373c8d262cfbcaf1fd4bc5b81a8154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3c7d9d302abecd825a9fec8e08ec37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a1a3c7d9d302abecd825a9fec8e08ec37">start_bootloader</a> ()</td></tr>
<tr class="memdesc:a1a3c7d9d302abecd825a9fec8e08ec37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters the bootloader for FW upgrades.  <a href="#a1a3c7d9d302abecd825a9fec8e08ec37">More...</a><br /></td></tr>
<tr class="separator:a1a3c7d9d302abecd825a9fec8e08ec37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8f4cc0afbc5dc33098fcc0298a6b2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a7c8f4cc0afbc5dc33098fcc0298a6b2b">inject_frame</a> (uint32_t frame_counter, uint32_t frame_length, const std::vector&lt; float &gt; &amp;frame)</td></tr>
<tr class="memdesc:a7c8f4cc0afbc5dc33098fcc0298a6b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects a radar frame.  <a href="#a7c8f4cc0afbc5dc33098fcc0298a6b2b">More...</a><br /></td></tr>
<tr class="separator:a7c8f4cc0afbc5dc33098fcc0298a6b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407debfbe4b29a50289fa5bf5e2d7f40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a407debfbe4b29a50289fa5bf5e2d7f40">prepare_inject_frame</a> (uint32_t num_frames, uint32_t num_bins, uint32_t mode)</td></tr>
<tr class="memdesc:a407debfbe4b29a50289fa5bf5e2d7f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare for injection of radar frame(s).  <a href="#a407debfbe4b29a50289fa5bf5e2d7f40">More...</a><br /></td></tr>
<tr class="separator:a407debfbe4b29a50289fa5bf5e2d7f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff968deb07f1ea55297a8934486fed24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#aff968deb07f1ea55297a8934486fed24">system_run_test</a> (const uint8_t testcode, Bytes *data)</td></tr>
<tr class="memdesc:aff968deb07f1ea55297a8934486fed24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the different manufacturing tests identified by testcode.  <a href="#aff968deb07f1ea55297a8934486fed24">More...</a><br /></td></tr>
<tr class="separator:aff968deb07f1ea55297a8934486fed24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ed1474ea017d7ed85383d9ec10e23e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#af2ed1474ea017d7ed85383d9ec10e23e">load_profile</a> (const uint32_t profileid)</td></tr>
<tr class="memdesc:af2ed1474ea017d7ed85383d9ec10e23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the profile given by profileid.  <a href="#af2ed1474ea017d7ed85383d9ec10e23e">More...</a><br /></td></tr>
<tr class="separator:af2ed1474ea017d7ed85383d9ec10e23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd81c3e87636f21be43a49affed6266"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a2bd81c3e87636f21be43a49affed6266">set_sensor_mode</a> (const uint8_t mode, const uint8_t param)</td></tr>
<tr class="memdesc:a2bd81c3e87636f21be43a49affed6266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the execution mode of the sensor.  <a href="#a2bd81c3e87636f21be43a49affed6266">More...</a><br /></td></tr>
<tr class="separator:a2bd81c3e87636f21be43a49affed6266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4b7f4e90ee6ca0ba04e720182ee6c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#acb4b7f4e90ee6ca0ba04e720182ee6c5">get_sensor_mode</a> (uint8_t *mode)</td></tr>
<tr class="separator:acb4b7f4e90ee6ca0ba04e720182ee6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8861f297daa6ec6c8ad2c0ee4be9027"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ab8861f297daa6ec6c8ad2c0ee4be9027">set_sensitivity</a> (const uint32_t sensitivity)</td></tr>
<tr class="memdesc:ab8861f297daa6ec6c8ad2c0ee4be9027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the overall sensitivity.  <a href="#ab8861f297daa6ec6c8ad2c0ee4be9027">More...</a><br /></td></tr>
<tr class="separator:ab8861f297daa6ec6c8ad2c0ee4be9027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4ce18fadfa4bff576ce536131e75cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a5a4ce18fadfa4bff576ce536131e75cd">get_sensitivity</a> (uint32_t *sensitivity)</td></tr>
<tr class="memdesc:a5a4ce18fadfa4bff576ce536131e75cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the overall sensitivity.  <a href="#a5a4ce18fadfa4bff576ce536131e75cd">More...</a><br /></td></tr>
<tr class="separator:a5a4ce18fadfa4bff576ce536131e75cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aa19b057f2dc5dc0decb7934734017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ae6aa19b057f2dc5dc0decb7934734017">set_tx_center_frequency</a> (const uint32_t frequency_band)</td></tr>
<tr class="memdesc:ae6aa19b057f2dc5dc0decb7934734017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets TX center frequency.  <a href="#ae6aa19b057f2dc5dc0decb7934734017">More...</a><br /></td></tr>
<tr class="separator:ae6aa19b057f2dc5dc0decb7934734017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6583c3bce8a1282b1977b3758de1cd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ae6583c3bce8a1282b1977b3758de1cd8">get_tx_center_frequency</a> (uint32_t *frequency_band)</td></tr>
<tr class="memdesc:ae6583c3bce8a1282b1977b3758de1cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets TX center frequency.  <a href="#ae6583c3bce8a1282b1977b3758de1cd8">More...</a><br /></td></tr>
<tr class="separator:ae6583c3bce8a1282b1977b3758de1cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6df5cb2557d5d12abbc36b92d154b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#abfd6df5cb2557d5d12abbc36b92d154b">set_detection_zone</a> (const float start, const float end)</td></tr>
<tr class="memdesc:abfd6df5cb2557d5d12abbc36b92d154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current detection zone.  <a href="#abfd6df5cb2557d5d12abbc36b92d154b">More...</a><br /></td></tr>
<tr class="separator:abfd6df5cb2557d5d12abbc36b92d154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fc10d80a5287c4ee8e272edcab0c03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ae1fc10d80a5287c4ee8e272edcab0c03">get_detection_zone</a> (float *start, float *end)</td></tr>
<tr class="memdesc:ae1fc10d80a5287c4ee8e272edcab0c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual detection zone.  <a href="#ae1fc10d80a5287c4ee8e272edcab0c03">More...</a><br /></td></tr>
<tr class="separator:ae1fc10d80a5287c4ee8e272edcab0c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2746a88eddd98977ba793fe684a5179"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#aa2746a88eddd98977ba793fe684a5179">get_detection_zone_limits</a> (float *min, float *max, float *step)</td></tr>
<tr class="memdesc:aa2746a88eddd98977ba793fe684a5179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the potential settings of detection zone from the module.  <a href="#aa2746a88eddd98977ba793fe684a5179">More...</a><br /></td></tr>
<tr class="separator:aa2746a88eddd98977ba793fe684a5179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8be27b4da3f664053c9cd8e81e78e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#aec8be27b4da3f664053c9cd8e81e78e8">set_led_control</a> (const uint8_t mode, uint8_t intensity)</td></tr>
<tr class="memdesc:aec8be27b4da3f664053c9cd8e81e78e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command configures the LED mode.  <a href="#aec8be27b4da3f664053c9cd8e81e78e8">More...</a><br /></td></tr>
<tr class="separator:aec8be27b4da3f664053c9cd8e81e78e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845daf1de4fa3f95f8eebbe4b46e1a8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a845daf1de4fa3f95f8eebbe4b46e1a8b">get_led_control</a> (uint8_t *mode)</td></tr>
<tr class="memdesc:a845daf1de4fa3f95f8eebbe4b46e1a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the LED mode.  <a href="#a845daf1de4fa3f95f8eebbe4b46e1a8b">More...</a><br /></td></tr>
<tr class="separator:a845daf1de4fa3f95f8eebbe4b46e1a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158ed65e4c61cd86bd3a7e52cb83eb52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a158ed65e4c61cd86bd3a7e52cb83eb52">set_output_control</a> (const uint32_t output_feature, const uint32_t output_control)</td></tr>
<tr class="memdesc:a158ed65e4c61cd86bd3a7e52cb83eb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control module profile output.  <a href="#a158ed65e4c61cd86bd3a7e52cb83eb52">More...</a><br /></td></tr>
<tr class="separator:a158ed65e4c61cd86bd3a7e52cb83eb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6781dd2616d5ee50fd71a3bd7fa601ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a6781dd2616d5ee50fd71a3bd7fa601ef">set_debug_output_control</a> (const uint32_t output_feature, const uint32_t output_control)</td></tr>
<tr class="separator:a6781dd2616d5ee50fd71a3bd7fa601ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70bd90c837f67706d89ce57eced1486"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ac70bd90c837f67706d89ce57eced1486">get_output_control</a> (const uint32_t output_feature, uint32_t *output_control)</td></tr>
<tr class="separator:ac70bd90c837f67706d89ce57eced1486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ed05097cd89bd7f85b5cc48b4b9fec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a31ed05097cd89bd7f85b5cc48b4b9fec">get_debug_output_control</a> (const uint32_t output_feature, uint32_t *output_control)</td></tr>
<tr class="separator:a31ed05097cd89bd7f85b5cc48b4b9fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ec1372397f563b5f6d3ce572e655d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ad0ec1372397f563b5f6d3ce572e655d6">peek_message_baseband_ap</a> ()</td></tr>
<tr class="memdesc:ad0ec1372397f563b5f6d3ce572e655d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Python warning: Accessing vectors directly can cause memory corruption if the parent object goes out ...">BasebandApData</a> messages available in queue.  <a href="#ad0ec1372397f563b5f6d3ce572e655d6">More...</a><br /></td></tr>
<tr class="separator:ad0ec1372397f563b5f6d3ce572e655d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea029e840eac0c25d443e1f2cbcc689b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#aea029e840eac0c25d443e1f2cbcc689b">read_message_baseband_ap</a> (<a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml">BasebandApData</a> *baseband_ap)</td></tr>
<tr class="memdesc:aea029e840eac0c25d443e1f2cbcc689b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Python warning: Accessing vectors directly can cause memory corruption if the parent object goes out ...">BasebandApData</a> item from the queue.  <a href="#aea029e840eac0c25d443e1f2cbcc689b">More...</a><br /></td></tr>
<tr class="separator:aea029e840eac0c25d443e1f2cbcc689b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90298563957a1b598a9d01125bb9a402"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a90298563957a1b598a9d01125bb9a402">peek_message_baseband_iq</a> ()</td></tr>
<tr class="memdesc:a90298563957a1b598a9d01125bb9a402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Python warning: Accessing vectors directly can cause memory corruption if the parent object goes out ...">BasebandIqData</a> messages available in queue.  <a href="#a90298563957a1b598a9d01125bb9a402">More...</a><br /></td></tr>
<tr class="separator:a90298563957a1b598a9d01125bb9a402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4754af20f03931ef68609d73fa9e01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ade4754af20f03931ef68609d73fa9e01">read_message_baseband_iq</a> (<a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml">BasebandIqData</a> *baseband_iq)</td></tr>
<tr class="memdesc:ade4754af20f03931ef68609d73fa9e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Python warning: Accessing vectors directly can cause memory corruption if the parent object goes out ...">BasebandIqData</a> item from the queue.  <a href="#ade4754af20f03931ef68609d73fa9e01">More...</a><br /></td></tr>
<tr class="separator:ade4754af20f03931ef68609d73fa9e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fedfdaed9ad94284f244a6318caf865"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a2fedfdaed9ad94284f244a6318caf865">peek_message_respiration_legacy</a> ()</td></tr>
<tr class="memdesc:a2fedfdaed9ad94284f244a6318caf865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of legacy respiration packets available in the queue.  <a href="#a2fedfdaed9ad94284f244a6318caf865">More...</a><br /></td></tr>
<tr class="separator:a2fedfdaed9ad94284f244a6318caf865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb07c1c7cfe12caef8a8c10f5fa5956e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#afb07c1c7cfe12caef8a8c10f5fa5956e">read_message_respiration_legacy</a> (<a class="el" href="class_xe_thru_1_1_respiration_data.xhtml">RespirationData</a> *respiration_data)</td></tr>
<tr class="memdesc:afb07c1c7cfe12caef8a8c10f5fa5956e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="class_xe_thru_1_1_respiration_data.xhtml" title="Represents the respiration status data coming from the module. ">RespirationData</a> item from the queue.  <a href="#afb07c1c7cfe12caef8a8c10f5fa5956e">More...</a><br /></td></tr>
<tr class="separator:afb07c1c7cfe12caef8a8c10f5fa5956e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7edec9ad6533ccd298d23dc86d8644e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#af7edec9ad6533ccd298d23dc86d8644e">peek_message_respiration_sleep</a> ()</td></tr>
<tr class="memdesc:af7edec9ad6533ccd298d23dc86d8644e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of respiration sleep packets available in the queue.  <a href="#af7edec9ad6533ccd298d23dc86d8644e">More...</a><br /></td></tr>
<tr class="separator:af7edec9ad6533ccd298d23dc86d8644e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9946d8957f6c7cb01d3cedb8c1a341"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a9e9946d8957f6c7cb01d3cedb8c1a341">read_message_respiration_sleep</a> (<a class="el" href="class_xe_thru_1_1_sleep_data.xhtml">SleepData</a> *sleep_data)</td></tr>
<tr class="memdesc:a9e9946d8957f6c7cb01d3cedb8c1a341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one sleep data message from subscription queue.  <a href="#a9e9946d8957f6c7cb01d3cedb8c1a341">More...</a><br /></td></tr>
<tr class="separator:a9e9946d8957f6c7cb01d3cedb8c1a341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457b7e533407e35e84fb4eb82de7ced1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a457b7e533407e35e84fb4eb82de7ced1">peek_message_respiration_movinglist</a> ()</td></tr>
<tr class="memdesc:a457b7e533407e35e84fb4eb82de7ced1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of respiration moving list packets available in the queue.  <a href="#a457b7e533407e35e84fb4eb82de7ced1">More...</a><br /></td></tr>
<tr class="separator:a457b7e533407e35e84fb4eb82de7ced1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc62c8e24b43a53dda3a07b2d2f4383"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#afdc62c8e24b43a53dda3a07b2d2f4383">read_message_respiration_movinglist</a> (<a class="el" href="struct_xe_thru_1_1_respiration_moving_list_data.xhtml">RespirationMovingListData</a> *data)</td></tr>
<tr class="memdesc:afdc62c8e24b43a53dda3a07b2d2f4383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one respiration moving list data message from subscription queue.  <a href="#afdc62c8e24b43a53dda3a07b2d2f4383">More...</a><br /></td></tr>
<tr class="separator:afdc62c8e24b43a53dda3a07b2d2f4383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d47f686ccd59b200822404d9d3fd8dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a8d47f686ccd59b200822404d9d3fd8dc">peek_message_respiration_detectionlist</a> ()</td></tr>
<tr class="memdesc:a8d47f686ccd59b200822404d9d3fd8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of respiration detection list packets available in the queue.  <a href="#a8d47f686ccd59b200822404d9d3fd8dc">More...</a><br /></td></tr>
<tr class="separator:a8d47f686ccd59b200822404d9d3fd8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bb5cce20dedeac7c330d484d179b11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a72bb5cce20dedeac7c330d484d179b11">read_message_respiration_detectionlist</a> (<a class="el" href="struct_xe_thru_1_1_respiration_detection_list_data.xhtml">RespirationDetectionListData</a> *data)</td></tr>
<tr class="memdesc:a72bb5cce20dedeac7c330d484d179b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one respiration detection list data message from subscription queue.  <a href="#a72bb5cce20dedeac7c330d484d179b11">More...</a><br /></td></tr>
<tr class="separator:a72bb5cce20dedeac7c330d484d179b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44c4d71387f1a079a37de61afa69d79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ac44c4d71387f1a079a37de61afa69d79">peek_message_respiration_normalizedmovementlist</a> ()</td></tr>
<tr class="memdesc:ac44c4d71387f1a079a37de61afa69d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of respiration normalized movement list packets available in the queue.  <a href="#ac44c4d71387f1a079a37de61afa69d79">More...</a><br /></td></tr>
<tr class="separator:ac44c4d71387f1a079a37de61afa69d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c1ff99a440e1946843a35ab464a78b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ac4c1ff99a440e1946843a35ab464a78b">read_message_respiration_normalizedmovementlist</a> (<a class="el" href="struct_xe_thru_1_1_respiration_normalized_movement_list_data.xhtml">RespirationNormalizedMovementListData</a> *data)</td></tr>
<tr class="memdesc:ac4c1ff99a440e1946843a35ab464a78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one respiration normalized movement list data message from subscription queue.  <a href="#ac4c1ff99a440e1946843a35ab464a78b">More...</a><br /></td></tr>
<tr class="separator:ac4c1ff99a440e1946843a35ab464a78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c41a9652d5318464797222ce1509c87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a9c41a9652d5318464797222ce1509c87">peek_message_vital_signs</a> ()</td></tr>
<tr class="memdesc:a9c41a9652d5318464797222ce1509c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of vital signs packets available in the queue.  <a href="#a9c41a9652d5318464797222ce1509c87">More...</a><br /></td></tr>
<tr class="separator:a9c41a9652d5318464797222ce1509c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c39dd0544f19d737c5db34025ef85a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a48c39dd0544f19d737c5db34025ef85a">read_message_vital_signs</a> (<a class="el" href="struct_xe_thru_1_1_vital_signs_data.xhtml">VitalSignsData</a> *data)</td></tr>
<tr class="memdesc:a48c39dd0544f19d737c5db34025ef85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one vital signs data message from subscription queue.  <a href="#a48c39dd0544f19d737c5db34025ef85a">More...</a><br /></td></tr>
<tr class="separator:a48c39dd0544f19d737c5db34025ef85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6666cf88a6d0a86d790f51760cb74d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#afe6666cf88a6d0a86d790f51760cb74d">peek_message_pulsedoppler_float</a> ()</td></tr>
<tr class="memdesc:afe6666cf88a6d0a86d790f51760cb74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of pulse-Doppler float packets available in the queue.  <a href="#afe6666cf88a6d0a86d790f51760cb74d">More...</a><br /></td></tr>
<tr class="separator:afe6666cf88a6d0a86d790f51760cb74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a96f5482d9df531f402c74ff2d51e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ab4a96f5482d9df531f402c74ff2d51e0">read_message_pulsedoppler_float</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *data)</td></tr>
<tr class="memdesc:ab4a96f5482d9df531f402c74ff2d51e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one pulse-Doppler float data message from subscription queue.  <a href="#ab4a96f5482d9df531f402c74ff2d51e0">More...</a><br /></td></tr>
<tr class="separator:ab4a96f5482d9df531f402c74ff2d51e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e0e81941cfabaca4b92b2c6893ffee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ad6e0e81941cfabaca4b92b2c6893ffee">peek_message_pulsedoppler_byte</a> ()</td></tr>
<tr class="memdesc:ad6e0e81941cfabaca4b92b2c6893ffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of pulse-Doppler byte packets available in the queue.  <a href="#ad6e0e81941cfabaca4b92b2c6893ffee">More...</a><br /></td></tr>
<tr class="separator:ad6e0e81941cfabaca4b92b2c6893ffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8e665b5296d5d99ba84b2017f57476"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a2c8e665b5296d5d99ba84b2017f57476">read_message_pulsedoppler_byte</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *data)</td></tr>
<tr class="memdesc:a2c8e665b5296d5d99ba84b2017f57476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one pulse-Doppler byte data message from subscription queue.  <a href="#a2c8e665b5296d5d99ba84b2017f57476">More...</a><br /></td></tr>
<tr class="separator:a2c8e665b5296d5d99ba84b2017f57476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2fe65eb4686e53fbbaa2dad37e09a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#abb2fe65eb4686e53fbbaa2dad37e09a6">peek_message_noisemap_float</a> ()</td></tr>
<tr class="memdesc:abb2fe65eb4686e53fbbaa2dad37e09a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of noisemap float packets available in the queue.  <a href="#abb2fe65eb4686e53fbbaa2dad37e09a6">More...</a><br /></td></tr>
<tr class="separator:abb2fe65eb4686e53fbbaa2dad37e09a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79edd2912d46d2aa2112e78c803484f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a79edd2912d46d2aa2112e78c803484f4">read_message_noisemap_float</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *data)</td></tr>
<tr class="memdesc:a79edd2912d46d2aa2112e78c803484f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one noisemap float data message from subscription queue.  <a href="#a79edd2912d46d2aa2112e78c803484f4">More...</a><br /></td></tr>
<tr class="separator:a79edd2912d46d2aa2112e78c803484f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73c2c60d44cb22001af967c2e04ea0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ae73c2c60d44cb22001af967c2e04ea0b">peek_message_noisemap_byte</a> ()</td></tr>
<tr class="memdesc:ae73c2c60d44cb22001af967c2e04ea0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of noisemap byte packets available in the queue.  <a href="#ae73c2c60d44cb22001af967c2e04ea0b">More...</a><br /></td></tr>
<tr class="separator:ae73c2c60d44cb22001af967c2e04ea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33180f9c33edb66f1a60d0739a05840"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ac33180f9c33edb66f1a60d0739a05840">read_message_noisemap_byte</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *data)</td></tr>
<tr class="memdesc:ac33180f9c33edb66f1a60d0739a05840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one noisemap byte data message from subscription queue.  <a href="#ac33180f9c33edb66f1a60d0739a05840">More...</a><br /></td></tr>
<tr class="separator:ac33180f9c33edb66f1a60d0739a05840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225c7305fc8f4cd52bb6792d770cfa9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a225c7305fc8f4cd52bb6792d770cfa9c">load_noisemap</a> ()</td></tr>
<tr class="memdesc:a225c7305fc8f4cd52bb6792d770cfa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send command to module to load a previously stored noisemap.  <a href="#a225c7305fc8f4cd52bb6792d770cfa9c">More...</a><br /></td></tr>
<tr class="separator:a225c7305fc8f4cd52bb6792d770cfa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8d6cb2f2e1e21f04b58f210882415c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#adc8d6cb2f2e1e21f04b58f210882415c">store_noisemap</a> ()</td></tr>
<tr class="memdesc:adc8d6cb2f2e1e21f04b58f210882415c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send command to module to store the current noisemap to module flash.  <a href="#adc8d6cb2f2e1e21f04b58f210882415c">More...</a><br /></td></tr>
<tr class="separator:adc8d6cb2f2e1e21f04b58f210882415c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753058427f2f05dbeceb91f63fd01c2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a753058427f2f05dbeceb91f63fd01c2a">delete_noisemap</a> ()</td></tr>
<tr class="memdesc:a753058427f2f05dbeceb91f63fd01c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send command to module to delete stored noisemap from module flash.  <a href="#a753058427f2f05dbeceb91f63fd01c2a">More...</a><br /></td></tr>
<tr class="separator:a753058427f2f05dbeceb91f63fd01c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484cd54798070a8c96fdad5b8b6a68c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a484cd54798070a8c96fdad5b8b6a68c3">set_noisemap_control</a> (uint32_t noisemap_control)</td></tr>
<tr class="memdesc:a484cd54798070a8c96fdad5b8b6a68c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the use of noisemap.  <a href="#a484cd54798070a8c96fdad5b8b6a68c3">More...</a><br /></td></tr>
<tr class="separator:a484cd54798070a8c96fdad5b8b6a68c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b86d5bc9dd43fd35f9a6ff168172f89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a6b86d5bc9dd43fd35f9a6ff168172f89">get_noisemap_control</a> (uint32_t *noisemap_control)</td></tr>
<tr class="memdesc:a6b86d5bc9dd43fd35f9a6ff168172f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current noisemap configuration.  <a href="#a6b86d5bc9dd43fd35f9a6ff168172f89">More...</a><br /></td></tr>
<tr class="separator:a6b86d5bc9dd43fd35f9a6ff168172f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba73a62911239b090527740a532f865"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#adba73a62911239b090527740a532f865">set_periodic_noisemap_store</a> (uint32_t interval_minutes, uint32_t reserved)</td></tr>
<tr class="memdesc:adba73a62911239b090527740a532f865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interval for periodic storing of noisemap.  <a href="#adba73a62911239b090527740a532f865">More...</a><br /></td></tr>
<tr class="separator:adba73a62911239b090527740a532f865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcbcfcf57b17213080d28068f7a86d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a5bcbcfcf57b17213080d28068f7a86d9">get_periodic_noisemap_store</a> (uint32_t *interval_minutes, uint32_t *reserved)</td></tr>
<tr class="memdesc:a5bcbcfcf57b17213080d28068f7a86d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interval for periodic storing of noisemap.  <a href="#a5bcbcfcf57b17213080d28068f7a86d9">More...</a><br /></td></tr>
<tr class="separator:a5bcbcfcf57b17213080d28068f7a86d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64f643a66f18687552691263a705ce0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ac64f643a66f18687552691263a705ce0">get_parameter_file</a> (const std::string &amp;filename, std::string *const data)</td></tr>
<tr class="memdesc:ac64f643a66f18687552691263a705ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the complete parameter file from the module.  <a href="#ac64f643a66f18687552691263a705ce0">More...</a><br /></td></tr>
<tr class="separator:ac64f643a66f18687552691263a705ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75430041f9eea93f587ffc0e1800ec6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a75430041f9eea93f587ffc0e1800ec6d">get_profileid</a> (uint32_t *result)</td></tr>
<tr class="memdesc:a75430041f9eea93f587ffc0e1800ec6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the currently loaded profile.  <a href="#a75430041f9eea93f587ffc0e1800ec6d">More...</a><br /></td></tr>
<tr class="separator:a75430041f9eea93f587ffc0e1800ec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a37be0e31a9151ca98636f5006338"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ae56a37be0e31a9151ca98636f5006338">set_parameter_file</a> (const std::string *filename, const std::string *data)</td></tr>
<tr class="memdesc:ae56a37be0e31a9151ca98636f5006338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a named parameter file on target.  <a href="#ae56a37be0e31a9151ca98636f5006338">More...</a><br /></td></tr>
<tr class="separator:ae56a37be0e31a9151ca98636f5006338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3db4741e952ba8ca791a083c566fa7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a2a3db4741e952ba8ca791a083c566fa7">set_iopin_control</a> (uint32_t pin_id, uint32_t pin_setup, uint32_t pin_feature)</td></tr>
<tr class="memdesc:a2a3db4741e952ba8ca791a083c566fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures GPIO pin.  <a href="#a2a3db4741e952ba8ca791a083c566fa7">More...</a><br /></td></tr>
<tr class="separator:a2a3db4741e952ba8ca791a083c566fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5b519ac487dc0d3505ae9b0eade4d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a8a5b519ac487dc0d3505ae9b0eade4d2">get_iopin_control</a> (uint32_t pin_id, uint32_t *pin_setup, uint32_t *pin_feature)</td></tr>
<tr class="memdesc:a8a5b519ac487dc0d3505ae9b0eade4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets GPIO pin configuration.  <a href="#a8a5b519ac487dc0d3505ae9b0eade4d2">More...</a><br /></td></tr>
<tr class="separator:a8a5b519ac487dc0d3505ae9b0eade4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daae47b218acda782b016ccec9a3673"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a0daae47b218acda782b016ccec9a3673">set_iopin_value</a> (uint32_t pin_id, uint32_t pin_value)</td></tr>
<tr class="memdesc:a0daae47b218acda782b016ccec9a3673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GPIO pin value.  <a href="#a0daae47b218acda782b016ccec9a3673">More...</a><br /></td></tr>
<tr class="separator:a0daae47b218acda782b016ccec9a3673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c86f962aeb3922ebfca417da93b796f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a8c86f962aeb3922ebfca417da93b796f">get_iopin_value</a> (uint32_t pin_id, uint32_t *pin_value)</td></tr>
<tr class="memdesc:a8c86f962aeb3922ebfca417da93b796f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets GPIO pin value.  <a href="#a8c86f962aeb3922ebfca417da93b796f">More...</a><br /></td></tr>
<tr class="separator:a8c86f962aeb3922ebfca417da93b796f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface to the Xethru <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> Application module. </p>
<p>This interface is used to control the <a class="el" href="namespace_xe_thru.xhtml">XeThru</a> <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> module. See the data sheet of the <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> module for more information on the <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> module. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a69a8c13fb828bbf27a3c24bcd82ee6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a8c13fb828bbf27a3c24bcd82ee6ae">&sect;&nbsp;</a></span>X4M200()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::X4M200::X4M200 </td>
          <td>(</td>
          <td class="paramtype">LockedRadarInterfacePtr &amp;&#160;</td>
          <td class="paramname"><em>radar_interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radar_interface</td><td>internal object used to interface the radar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d6359bd91162372401c48b776f5df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6359bd91162372401c48b776f5df0c">&sect;&nbsp;</a></span>~X4M200()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::X4M200::~X4M200 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a753058427f2f05dbeceb91f63fd01c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753058427f2f05dbeceb91f63fd01c2a">&sect;&nbsp;</a></span>delete_noisemap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::delete_noisemap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send command to module to delete stored noisemap from module flash. </p>
<p>Fails in case of flash access issues.</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a31ed05097cd89bd7f85b5cc48b4b9fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ed05097cd89bd7f85b5cc48b4b9fec">&sect;&nbsp;</a></span>get_debug_output_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_debug_output_control </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>output_feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>output_control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1fc10d80a5287c4ee8e272edcab0c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fc10d80a5287c4ee8e272edcab0c03">&sect;&nbsp;</a></span>get_detection_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_detection_zone </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual detection zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">start</td><td>start of detection zone in meters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">end</td><td>end of detection zone in meters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="aa2746a88eddd98977ba793fe684a5179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2746a88eddd98977ba793fe684a5179">&sect;&nbsp;</a></span>get_detection_zone_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_detection_zone_limits </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the potential settings of detection zone from the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>smallest value for detection zone start </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max</td><td>largest value for detection zone end </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">step</td><td>detection zone start and end step size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a8a5b519ac487dc0d3505ae9b0eade4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5b519ac487dc0d3505ae9b0eade4d2">&sect;&nbsp;</a></span>get_iopin_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_iopin_control </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pin_setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pin_feature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets GPIO pin configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pin_id</td><td>Specifies the pin. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pin_setup</td><td>See documentation of set_iopin_control. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pin_feature</td><td>See documentation of set_iopin_control.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a2a3db4741e952ba8ca791a083c566fa7" title="Configures GPIO pin. ">set_iopin_control</a> </dd></dl>

</div>
</div>
<a id="a8c86f962aeb3922ebfca417da93b796f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c86f962aeb3922ebfca417da93b796f">&sect;&nbsp;</a></span>get_iopin_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_iopin_value </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pin_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets GPIO pin value. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a0daae47b218acda782b016ccec9a3673" title="Sets GPIO pin value. ">set_iopin_value</a> </dd></dl>

</div>
</div>
<a id="a845daf1de4fa3f95f8eebbe4b46e1a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845daf1de4fa3f95f8eebbe4b46e1a8b">&sect;&nbsp;</a></span>get_led_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_led_control </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the LED mode. </p>
<p><br />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>(modes are defined in xtid.h) <br />
 mode = XTID_LED_MODE_OFF : OFF <br />
 mode = XTID_LED_MODE_SIMPLE : simple <br />
 mode = XTID_LED_MODE_FULL : full (default) <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a6b86d5bc9dd43fd35f9a6ff168172f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b86d5bc9dd43fd35f9a6ff168172f89">&sect;&nbsp;</a></span>get_noisemap_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_noisemap_control </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>noisemap_control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current noisemap configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">noisemap_control</td><td>A bitfield of the various features. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ac70bd90c837f67706d89ce57eced1486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70bd90c837f67706d89ce57eced1486">&sect;&nbsp;</a></span>get_output_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_output_control </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>output_feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>output_control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac64f643a66f18687552691263a705ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64f643a66f18687552691263a705ce0">&sect;&nbsp;</a></span>get_parameter_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_parameter_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *const&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the complete parameter file from the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>pointer to a string containing the complete paramter file data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a5bcbcfcf57b17213080d28068f7a86d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcbcfcf57b17213080d28068f7a86d9">&sect;&nbsp;</a></span>get_periodic_noisemap_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_periodic_noisemap_store </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>interval_minutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>reserved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interval for periodic storing of noisemap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">interval_minutes</td><td>Interval for storing moisemap </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reserved</td><td>Reserved for future use, must be set to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75430041f9eea93f587ffc0e1800ec6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75430041f9eea93f587ffc0e1800ec6d">&sect;&nbsp;</a></span>get_profileid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_profileid </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the id of the currently loaded profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>pointer to the resulting profile_id. 0 in case of no profile loaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a5a4ce18fadfa4bff576ce536131e75cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4ce18fadfa4bff576ce536131e75cd">&sect;&nbsp;</a></span>get_sensitivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_sensitivity </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>sensitivity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the overall sensitivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sensitivity</td><td>: 0 to 9, 0 = low, 9 = high </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="acb4b7f4e90ee6ca0ba04e720182ee6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4b7f4e90ee6ca0ba04e720182ee6c5">&sect;&nbsp;</a></span>get_sensor_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_sensor_mode </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15e9a8c13407ca3d45b0b11dca08ba33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e9a8c13407ca3d45b0b11dca08ba33">&sect;&nbsp;</a></span>get_system_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_system_info </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>info_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>system_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing system information given by infocode:<br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info_code</td><td>what information to query. Possible values are?<br />
 XTID_SSIC_ITEMNUMBER -&gt; Returns the product Item Number, including revision. This is programmed in Flash during manufacturing<br />
 XTID_SSIC_ORDERCODE -&gt; Returns the product order code<br />
 XTID_SSIC_FIRMWAREID -&gt; Returns the installed Firmware ID. As viewed from the "highest" level of the software, "X4M200"<br />
 XTID_SSIC_VERSION -&gt; Returns the installed Firmware Version. As viewed from the "highest" level of the software<br />
 XTID_SSIC_BUILD -&gt; Returns information of the SW Build installed on the device<br />
 XTID_SSIC_SERIALNUMBER -&gt; Returns the product serial number<br />
 XTID_SSIC_VERSIONLIST -&gt;Returns ID and version of all components. Calls all components and compound a string E.g. "X4M300:1.0.0.3;XEP:2.3.4.5;X4C51:1.0.0.0;DSP:1.1.1.1" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ae6583c3bce8a1282b1977b3758de1cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6583c3bce8a1282b1977b3758de1cd8">&sect;&nbsp;</a></span>get_tx_center_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_tx_center_frequency </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>frequency_band</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets TX center frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">frequency_band</td><td>: 3 for low band, 4 for high band </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a7c8f4cc0afbc5dc33098fcc0298a6b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8f4cc0afbc5dc33098fcc0298a6b2b">&sect;&nbsp;</a></span>inject_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::inject_frame </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects a radar frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_counter</td><td>Frame counter of frame. </td></tr>
    <tr><td class="paramname">frame_length</td><td>Number of bins in the frame. </td></tr>
    <tr><td class="paramname">frame</td><td>The frame data to inject.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>execution status </dd></dl>

</div>
</div>
<a id="a225c7305fc8f4cd52bb6792d770cfa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225c7305fc8f4cd52bb6792d770cfa9c">&sect;&nbsp;</a></span>load_noisemap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::load_noisemap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send command to module to load a previously stored noisemap. </p>
<p>Not yet functional as of FW 1.3</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="af2ed1474ea017d7ed85383d9ec10e23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ed1474ea017d7ed85383d9ec10e23e">&sect;&nbsp;</a></span>load_profile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::load_profile </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>profileid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the profile given by profileid. </p>
<p>If another profile is already loaded, the other profile is unloaded before the new profile is loaded. The profile does not start, the module remains idle. <br />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">profileid</td><td>the id of the profile to load profileid = XTS_ID_APP_RESPIRATION_2 (xtid.h) : sleep profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a6a0e2fa9756ab51bb666d49abcbd7b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0e2fa9756ab51bb666d49abcbd7b5f">&sect;&nbsp;</a></span>module_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::module_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the module. </p>
<p>The client must perform a close and then an open on the <a class="el" href="class_xe_thru_1_1_module_connector.xhtml" title="This class is responsible for establishing contact with the Xethru module. ">ModuleConnector</a> to reeastablish connection.</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ad0ec1372397f563b5f6d3ce572e655d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ec1372397f563b5f6d3ce572e655d6">&sect;&nbsp;</a></span>peek_message_baseband_ap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_baseband_ap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Python warning: Accessing vectors directly can cause memory corruption if the parent object goes out ...">BasebandApData</a> messages available in queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in buffer </dd></dl>

</div>
</div>
<a id="a90298563957a1b598a9d01125bb9a402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90298563957a1b598a9d01125bb9a402">&sect;&nbsp;</a></span>peek_message_baseband_iq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_baseband_iq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Python warning: Accessing vectors directly can cause memory corruption if the parent object goes out ...">BasebandIqData</a> messages available in queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in buffer </dd></dl>

</div>
</div>
<a id="ae73c2c60d44cb22001af967c2e04ea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73c2c60d44cb22001af967c2e04ea0b">&sect;&nbsp;</a></span>peek_message_noisemap_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_noisemap_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of noisemap byte packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="abb2fe65eb4686e53fbbaa2dad37e09a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2fe65eb4686e53fbbaa2dad37e09a6">&sect;&nbsp;</a></span>peek_message_noisemap_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_noisemap_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of noisemap float packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="ad6e0e81941cfabaca4b92b2c6893ffee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e0e81941cfabaca4b92b2c6893ffee">&sect;&nbsp;</a></span>peek_message_pulsedoppler_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_pulsedoppler_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of pulse-Doppler byte packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="afe6666cf88a6d0a86d790f51760cb74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6666cf88a6d0a86d790f51760cb74d">&sect;&nbsp;</a></span>peek_message_pulsedoppler_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_pulsedoppler_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of pulse-Doppler float packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="a8d47f686ccd59b200822404d9d3fd8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d47f686ccd59b200822404d9d3fd8dc">&sect;&nbsp;</a></span>peek_message_respiration_detectionlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_respiration_detectionlist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of respiration detection list packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="a2fedfdaed9ad94284f244a6318caf865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fedfdaed9ad94284f244a6318caf865">&sect;&nbsp;</a></span>peek_message_respiration_legacy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_respiration_legacy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of legacy respiration packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in buffer </dd></dl>

</div>
</div>
<a id="a457b7e533407e35e84fb4eb82de7ced1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457b7e533407e35e84fb4eb82de7ced1">&sect;&nbsp;</a></span>peek_message_respiration_movinglist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_respiration_movinglist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of respiration moving list packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="ac44c4d71387f1a079a37de61afa69d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44c4d71387f1a079a37de61afa69d79">&sect;&nbsp;</a></span>peek_message_respiration_normalizedmovementlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_respiration_normalizedmovementlist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of respiration normalized movement list packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="af7edec9ad6533ccd298d23dc86d8644e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7edec9ad6533ccd298d23dc86d8644e">&sect;&nbsp;</a></span>peek_message_respiration_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_respiration_sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of respiration sleep packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="a9c41a9652d5318464797222ce1509c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c41a9652d5318464797222ce1509c87">&sect;&nbsp;</a></span>peek_message_vital_signs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_vital_signs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of vital signs packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="af8bf194b6c4db57768425a02bea776ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bf194b6c4db57768425a02bea776ce">&sect;&nbsp;</a></span>ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::ping </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pong_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure there is a connection to firmware on the Xethru <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pong</td><td>value: 0xaaeeaeea means system ready and 0xaeeaeeaa means system not ready.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a407debfbe4b29a50289fa5bf5e2d7f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407debfbe4b29a50289fa5bf5e2d7f40">&sect;&nbsp;</a></span>prepare_inject_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::prepare_inject_frame </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare for injection of radar frame(s). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_frame</td><td>Number of frame to inject </td></tr>
    <tr><td class="paramname">num_bins</td><td>Number of bins in each frame. </td></tr>
    <tr><td class="paramname">mode</td><td>The frame injection mode: LOOP, SEQUENTIAL, SINGLE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>execution status </dd></dl>

</div>
</div>
<a id="aea029e840eac0c25d443e1f2cbcc689b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea029e840eac0c25d443e1f2cbcc689b">&sect;&nbsp;</a></span>read_message_baseband_ap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_baseband_ap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml">BasebandApData</a> *&#160;</td>
          <td class="paramname"><em>baseband_ap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Python warning: Accessing vectors directly can cause memory corruption if the parent object goes out ...">BasebandApData</a> item from the queue. </p>
<p>Blocks if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">baseband_ap</td><td>pointer to returned <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Python warning: Accessing vectors directly can cause memory corruption if the parent object goes out ...">BasebandApData</a> item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ade4754af20f03931ef68609d73fa9e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4754af20f03931ef68609d73fa9e01">&sect;&nbsp;</a></span>read_message_baseband_iq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_baseband_iq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml">BasebandIqData</a> *&#160;</td>
          <td class="paramname"><em>baseband_iq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Python warning: Accessing vectors directly can cause memory corruption if the parent object goes out ...">BasebandIqData</a> item from the queue. </p>
<p>Blocks if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">baseband_iq</td><td>pointer to returned <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Python warning: Accessing vectors directly can cause memory corruption if the parent object goes out ...">BasebandIqData</a> item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ac33180f9c33edb66f1a60d0739a05840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33180f9c33edb66f1a60d0739a05840">&sect;&nbsp;</a></span>read_message_noisemap_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_noisemap_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one noisemap byte data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting noisemap byte data </dd></dl>

</div>
</div>
<a id="a79edd2912d46d2aa2112e78c803484f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79edd2912d46d2aa2112e78c803484f4">&sect;&nbsp;</a></span>read_message_noisemap_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_noisemap_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one noisemap float data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting noisemap float data </dd></dl>

</div>
</div>
<a id="a2c8e665b5296d5d99ba84b2017f57476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8e665b5296d5d99ba84b2017f57476">&sect;&nbsp;</a></span>read_message_pulsedoppler_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_pulsedoppler_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one pulse-Doppler byte data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting pulse-Doppler byte data </dd></dl>

</div>
</div>
<a id="ab4a96f5482d9df531f402c74ff2d51e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a96f5482d9df531f402c74ff2d51e0">&sect;&nbsp;</a></span>read_message_pulsedoppler_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_pulsedoppler_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one pulse-Doppler float data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting pulse-Doppler float data </dd></dl>

</div>
</div>
<a id="a72bb5cce20dedeac7c330d484d179b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bb5cce20dedeac7c330d484d179b11">&sect;&nbsp;</a></span>read_message_respiration_detectionlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_respiration_detectionlist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xe_thru_1_1_respiration_detection_list_data.xhtml">RespirationDetectionListData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one respiration detection list data message from subscription queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>A data object holding the resulting respiration detection listdata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="afb07c1c7cfe12caef8a8c10f5fa5956e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb07c1c7cfe12caef8a8c10f5fa5956e">&sect;&nbsp;</a></span>read_message_respiration_legacy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_respiration_legacy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_respiration_data.xhtml">RespirationData</a> *&#160;</td>
          <td class="paramname"><em>respiration_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="class_xe_thru_1_1_respiration_data.xhtml" title="Represents the respiration status data coming from the module. ">RespirationData</a> item from the queue. </p>
<p>Blocks if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">respiration_data</td><td>pointer to returned <a class="el" href="class_xe_thru_1_1_respiration_data.xhtml" title="Represents the respiration status data coming from the module. ">RespirationData</a> item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="afdc62c8e24b43a53dda3a07b2d2f4383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc62c8e24b43a53dda3a07b2d2f4383">&sect;&nbsp;</a></span>read_message_respiration_movinglist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_respiration_movinglist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xe_thru_1_1_respiration_moving_list_data.xhtml">RespirationMovingListData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one respiration moving list data message from subscription queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>A data object holding the resulting respiration moving listdata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ac4c1ff99a440e1946843a35ab464a78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c1ff99a440e1946843a35ab464a78b">&sect;&nbsp;</a></span>read_message_respiration_normalizedmovementlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_respiration_normalizedmovementlist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xe_thru_1_1_respiration_normalized_movement_list_data.xhtml">RespirationNormalizedMovementListData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one respiration normalized movement list data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting respiration normalized movement list data </dd></dl>

</div>
</div>
<a id="a9e9946d8957f6c7cb01d3cedb8c1a341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9946d8957f6c7cb01d3cedb8c1a341">&sect;&nbsp;</a></span>read_message_respiration_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_respiration_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_sleep_data.xhtml">SleepData</a> *&#160;</td>
          <td class="paramname"><em>sleep_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one sleep data message from subscription queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sleep_data</td><td>A data object holding the resulting respiration data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a48c39dd0544f19d737c5db34025ef85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c39dd0544f19d737c5db34025ef85a">&sect;&nbsp;</a></span>read_message_vital_signs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_vital_signs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xe_thru_1_1_vital_signs_data.xhtml">VitalSignsData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one vital signs data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting vital signs data </dd></dl>

</div>
</div>
<a id="a4c541b6aeac38360b6b8b7132f36f086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c541b6aeac38360b6b8b7132f36f086">&sect;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets and restart the module. </p>
<p>This is a convenience method that calls <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a6a0e2fa9756ab51bb666d49abcbd7b5f" title="Resets the module. ">module_reset()</a>, disconnects the communication port, and then reestablishes connection with the module.</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a7373c8d262cfbcaf1fd4bc5b81a8154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7373c8d262cfbcaf1fd4bc5b81a8154f">&sect;&nbsp;</a></span>reset_to_factory_preset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::reset_to_factory_preset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all parameters in the module to factory presets. </p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a52c261955578f57a0a7ec90e358243d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c261955578f57a0a7ec90e358243d7">&sect;&nbsp;</a></span>set_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_baudrate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set baudrate for serial communication during <a class="el" href="class_xe_thru_1_1_module_connector.xhtml" title="This class is responsible for establishing contact with the Xethru module. ">ModuleConnector</a> operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>enum representing the baudrate, XTID_BAUDRATE_XXX in xtid.h. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a41104e3d2da276d8a1062a172a96314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41104e3d2da276d8a1062a172a96314f">&sect;&nbsp;</a></span>set_debug_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_debug_level </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets debug level in the Xethru module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>New debug level. Valid range [0-9]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a6781dd2616d5ee50fd71a3bd7fa601ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6781dd2616d5ee50fd71a3bd7fa601ef">&sect;&nbsp;</a></span>set_debug_output_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_debug_output_control </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>output_feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>output_control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfd6df5cb2557d5d12abbc36b92d154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd6df5cb2557d5d12abbc36b92d154b">&sect;&nbsp;</a></span>set_detection_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_detection_zone </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current detection zone. </p>
<p>Rules: See <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> datasheet. The actual detection zone is determined by profile configuration. Use the get_detection_zone command to get the actual values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start of detection zone in meters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end of detection zone in meters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a2a3db4741e952ba8ca791a083c566fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3db4741e952ba8ca791a083c566fa7">&sect;&nbsp;</a></span>set_iopin_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_iopin_control </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin_setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin_feature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pin_id</td><td>Specifies the IO pin to configure. pin_id = 0 means all IO pins. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pin_setup</td><td>Specifies the direction and drive of the IO pin. bit 0: input = 0, output = 1 bit 1: open-drain = 0, push-pull = 1 bit 2: active-high = 0, active-low = 1 bit 3: no pull-up = 0, pull-up = 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pin_feature</td><td>Specifies the configuration of the IO pin. 0 = Disable all iopin features. 1 = Configure according to datasheet default. This overrides pin_setup. 2 = Passive, set and get iopin level from host. 4 = Movement, see <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> datasheet for details. 5 = Breathing, see <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> datasheet for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a8c86f962aeb3922ebfca417da93b796f" title="Gets GPIO pin value. ">get_iopin_value</a> </dd></dl>

</div>
</div>
<a id="a0daae47b218acda782b016ccec9a3673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0daae47b218acda782b016ccec9a3673">&sect;&nbsp;</a></span>set_iopin_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_iopin_value </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets GPIO pin value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pin_id</td><td>Specifies the pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pin_value</td><td>Specifies the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Pin must be configured as output pin.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise returns 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a2a3db4741e952ba8ca791a083c566fa7" title="Configures GPIO pin. ">set_iopin_control</a> </dd></dl>

</div>
</div>
<a id="aec8be27b4da3f664053c9cd8e81e78e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8be27b4da3f664053c9cd8e81e78e8">&sect;&nbsp;</a></span>set_led_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_led_control </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intensity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command configures the LED mode. </p>
<p><br />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>(modes are defined in xtid.h) <br />
 mode = XTID_LED_MODE_OFF : OFF <br />
 mode = XTID_LED_MODE_SIMPLE : simple <br />
 mode = XTID_LED_MODE_FULL : full (default) <br />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intensity</td><td>0 to 100, 0=low, 100=high, not implemented yet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a484cd54798070a8c96fdad5b8b6a68c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484cd54798070a8c96fdad5b8b6a68c3">&sect;&nbsp;</a></span>set_noisemap_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_noisemap_control </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>noisemap_control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the use of noisemap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">noisemap_control</td><td>A bitfield of the various features. <br />
<ul>
<li>Use Stored Noise Map<ul>
<li>On - XTID_NOISEMAP_CONTROL_USE_STORED<ul>
<li>If a valid Stored Noise Map exists this will be used at reset or when the Profile is started.</li>
<li>If no valid Stored Noise Map exists and Use Default Noise Map is off, a new Noise Map will be created during Initialization state. The newly created Noise Map will be stored in the sensor when Initialization is done. A noise map created with a different Detection Zone is not valid.</li>
<li>If no valid Stored Noise Map exists and Use Default Noise Map is on, the Default Noise Map will be used at reset or when the Profile is started.</li>
</ul>
</li>
<li>Off - XTID_NOISEMAP_CONTROL_INIT_ON_RESET<ul>
<li>If Use Default Noise Map is off, a new Noise Map will always be created at reset or when the Profile is started. Sensor will be in Initialization state during Noise Map creation. A previously Stored Noise Map in the sensor will be ignored, but not overwritten, when the Profile starts.</li>
<li>If Use Default Noise Map is on, the Default Noise Map will be used at reset or when the Profile is started.</li>
</ul>
</li>
</ul>
</li>
<li>Use Default Noise Map<ul>
<li>On - XTID_NOISEMAP_CONTROL_USE_DEFAULT / DISABLE<ul>
<li>If Use Store Noise Map is on and a valid Stored Noise Map exists, Default Noise Map will not be used.</li>
<li>If Use Stored Noise Map is on and no valid Stored Noise Map exists, the Default Noise Map will be used at reset or when the Profile is started.</li>
<li>If Use Stored Noise Map is off, the Default Noise Map will be used at reset or when the Profile is started.</li>
</ul>
</li>
<li>Off - XTID_NOISEMAP_CONTROL_ENABLE<ul>
<li>The Default Noise Map will not be used.</li>
</ul>
</li>
</ul>
</li>
<li>Adaptive Noise Map<ul>
<li>On - XTID_NOISEMAP_CONTROL_ADAPTIVE<ul>
<li>Enables Noise Map adaptation. Noise Map will still not adapt in certain conditions as described in Firmware Algorithms section below.</li>
</ul>
</li>
<li>Off - XTID_NOISEMAP_CONTROL_NONADAPTIVE<ul>
<li>Disables Noise Map adaptation (not implemented).</li>
</ul>
</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a158ed65e4c61cd86bd3a7e52cb83eb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158ed65e4c61cd86bd3a7e52cb83eb52">&sect;&nbsp;</a></span>set_output_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_output_control </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>output_feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>output_control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control module profile output. </p>
<p>Enable and disable data messages. Several calls can be made, one for each available output message the profile provides.</p>
<p>Only one of XTS_ID_BASEBAND_IQ and XTS_ID_BASEBAND_AMPLITUDE_PHASE can be enabled at a time. Enabling one disables the other. Disabling one, even if it is already disabled, disables the other.</p>
<p>Only one of XTS_ID_PULSEDOPPLER_FLOAT and XTS_ID_PULSEDOPPLER_BYTE can be enabled for each of XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE and XTID_OUTPUT_CONTROL_PD_FAST_ENABLE. Same with XTS_ID_NOISEMAP_FLOAT and XTS_ID_NOISEMAP_BYTE. Turning on a float output automatically disables the byte output, and vice versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output_feature</td><td>see values in xtid.h.<br />
 Possible features are:<br />
 XTS_ID_RESPIRATION_MOVINGLIST<br />
 XTS_ID_RESPIRATION_DETECTIONLIST<br />
 XTS_ID_RESP_STATUS<br />
 XTS_ID_RESP_STATUS_EXT<br />
 XTS_ID_BASEBAND_IQ<br />
 XTS_ID_BASEBAND_AMPLITUDE_PHASE<br />
 XTS_ID_PULSEDOPPLER_FLOAT<br />
 XTS_ID_PULSEDOPPLER_BYTE<br />
 XTS_ID_NOISEMAP_FLOAT<br />
 XTS_ID_NOISEMAP_BYTE<br />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_control</td><td>see values in xtid.h<br />
 Typical values:<br />
 XTID_OUTPUT_CONTROL_DISABLE = disable<br />
 XTID_OUTPUT_CONTROL_ENABLE = enable<br />
 <br />
 For pulse-Doppler and noisemap byte/float:<br />
 XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE<br />
 XTID_OUTPUT_CONTROL_PD_FAST_ENABLE<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ae56a37be0e31a9151ca98636f5006338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56a37be0e31a9151ca98636f5006338">&sect;&nbsp;</a></span>set_parameter_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_parameter_file </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a named parameter file on target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The name to call the parameter file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The content of the parameter-file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="adba73a62911239b090527740a532f865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba73a62911239b090527740a532f865">&sect;&nbsp;</a></span>set_periodic_noisemap_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_periodic_noisemap_store </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interval_minutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reserved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interval for periodic storing of noisemap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interval_minutes</td><td>Interval for storing moisemap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reserved</td><td>Reserved for future use, must be set to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8861f297daa6ec6c8ad2c0ee4be9027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8861f297daa6ec6c8ad2c0ee4be9027">&sect;&nbsp;</a></span>set_sensitivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_sensitivity </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sensitivity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the overall sensitivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sensitivity</td><td>: 0 to 9, 0 = low, 9 = high </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a2bd81c3e87636f21be43a49affed6266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd81c3e87636f21be43a49affed6266">&sect;&nbsp;</a></span>set_sensor_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_sensor_mode </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the execution mode of the sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>see xtid.h for profileid values.<br />
 XTID_SM_RUN : Start profile execution<br />
 XTID_SM_IDLE : Halts profile execution. Can be resumed by setting mode to Run.<br />
 XTID_SM_STOP : Stops profile execution. Must do load_profile to continue.<br />
 XTID_SM_MANUAL : Routes X4 radar data directly to host rather than to profile execution. Can then interact directly with <a class="el" href="class_xe_thru_1_1_x_e_p.xhtml" title="XEP class gives access to XEP functionality on target via module connector. ">XEP</a> / X4Driver. Will disrupt profile performance.<br />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Not used, ignored, can be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ae6aa19b057f2dc5dc0decb7934734017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6aa19b057f2dc5dc0decb7934734017">&sect;&nbsp;</a></span>set_tx_center_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_tx_center_frequency </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>frequency_band</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets TX center frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frequency_band</td><td>: 3 for low band, 4 for high band </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a1a3c7d9d302abecd825a9fec8e08ec37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3c7d9d302abecd825a9fec8e08ec37">&sect;&nbsp;</a></span>start_bootloader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::start_bootloader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters the bootloader for FW upgrades. </p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="adc8d6cb2f2e1e21f04b58f210882415c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8d6cb2f2e1e21f04b58f210882415c">&sect;&nbsp;</a></span>store_noisemap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::store_noisemap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send command to module to store the current noisemap to module flash. </p>
<p>Fails if a store already is active, for example during the first initialize with XTID_NOISEMAP_CONTROL_INIT_ON_RESET disabled.</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="aff968deb07f1ea55297a8934486fed24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff968deb07f1ea55297a8934486fed24">&sect;&nbsp;</a></span>system_run_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::system_run_test </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>testcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bytes *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the different manufacturing tests identified by testcode. </p>
<p>Can return any number of results depending on test_mode. Host must know how to parse test results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">testcode</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>data buffer containing the result from a test run. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_x4_m200_8hpp_source.xhtml">X4M200.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/>
 <address class="footer">
 Copyright &copy; 2016 Novelda AS - <a href="http://www.xethru.com">www.xehtru.com</a><br />
 <small>
  Generated by &#160;<a href="http://www.doxygen.org/index.html">
  <img class="footer" src="doxygen.png" alt="doxygen"/>
  </a> 1.8.12
 </small>
 </address>
</body>
</html>
