<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pymoduleconnector: pymoduleconnector.moduleconnectorwrapper.PyDataRecorder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- Platform title -->
    <div class="page-title-bar container-fluid">
      <div id="projectalign" class="row">
        <div id="projectname" class="col-sm-12">pymoduleconnector
          &#160;<span id="projectnumber">1.6.2</span>
        </div>
        <div id="projectbrief" class="col-sm-12">A Python wrapper for XeThru ModuleConnector</div>
      </div>
    </div>
    <div class="topbar">
      <div class="container">
        <div id="titlearea">
          <div class="xethru-logo">
            <img src="xethru-logo_220x55HD.png" alt="Novelda XeThru web site" id="logo-image" />
          </div>
        </div>
        <!-- end header part -->
        <!-- Generated by Doxygen 1.8.12 -->
        <!--BEGIN MAIN-NAV AND SEARCHENGINE-->
        <div id="main-nav"></div>
        <!--END MAIN-NAV AND SEARCHENGINE-->
      </div>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pymoduleconnector</b></li><li class="navelem"><b>moduleconnectorwrapper</b></li><li class="navelem"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml">PyDataRecorder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder-members.xhtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pymoduleconnector.moduleconnectorwrapper.PyDataRecorder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The DataRecorder class allows recording of xethru data types.  
 <a href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a880fae1cd20e7e727bf71d1b4423f738"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#a880fae1cd20e7e727bf71d1b4423f738">__init__</a> (self, radar_interface)</td></tr>
<tr class="memdesc:a880fae1cd20e7e727bf71d1b4423f738"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>init</b>(XeThru::PyDataRecorder self, LockedRadarInterfacePtr &amp; radar_interface) -&gt; <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types. ">PyDataRecorder</a>  <a href="#a880fae1cd20e7e727bf71d1b4423f738">More...</a><br /></td></tr>
<tr class="separator:a880fae1cd20e7e727bf71d1b4423f738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171cd0956ee91e40496653eb1ae408a3"><td class="memItemLeft" align="right" valign="top"><a id="a171cd0956ee91e40496653eb1ae408a3"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>start_recording</b> (self, args)</td></tr>
<tr class="separator:a171cd0956ee91e40496653eb1ae408a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac0e0a0a0a2d0d80d4fee6242f66ba6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#a9ac0e0a0a0a2d0d80d4fee6242f66ba6">stop_recording</a> (self, data_types)</td></tr>
<tr class="memdesc:a9ac0e0a0a0a2d0d80d4fee6242f66ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop_recording(PyDataRecorder self, XeThru::DataTypes data_types)  <a href="#a9ac0e0a0a0a2d0d80d4fee6242f66ba6">More...</a><br /></td></tr>
<tr class="separator:a9ac0e0a0a0a2d0d80d4fee6242f66ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9686c460b0b212a734076e232ff62bee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#a9686c460b0b212a734076e232ff62bee">is_recording</a> (self, data_type)</td></tr>
<tr class="memdesc:a9686c460b0b212a734076e232ff62bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_recording(PyDataRecorder self, uint32_t data_type) -&gt; bool  <a href="#a9686c460b0b212a734076e232ff62bee">More...</a><br /></td></tr>
<tr class="separator:a9686c460b0b212a734076e232ff62bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a8d540baece3bae3415fb95822c01f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#ab9a8d540baece3bae3415fb95822c01f">process</a> (self, data_type, data)</td></tr>
<tr class="memdesc:ab9a8d540baece3bae3415fb95822c01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">process(PyDataRecorder self, uint32_t data_type, ucVector data) -&gt; bool  <a href="#ab9a8d540baece3bae3415fb95822c01f">More...</a><br /></td></tr>
<tr class="separator:ab9a8d540baece3bae3415fb95822c01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d06e507bf5dea4567bd25d8839c8480"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#a9d06e507bf5dea4567bd25d8839c8480">unsubscribe_to_file_available</a> (self, data_types)</td></tr>
<tr class="memdesc:a9d06e507bf5dea4567bd25d8839c8480"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsubscribe_to_file_available(PyDataRecorder self, XeThru::DataTypes data_types)  <a href="#a9d06e507bf5dea4567bd25d8839c8480">More...</a><br /></td></tr>
<tr class="separator:a9d06e507bf5dea4567bd25d8839c8480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d858679c13d464d7795f99d2f73480"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#a36d858679c13d464d7795f99d2f73480">unsubscribe_to_meta_file_available</a> (self)</td></tr>
<tr class="memdesc:a36d858679c13d464d7795f99d2f73480"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsubscribe_to_meta_file_available(PyDataRecorder self) -&gt; int  <a href="#a36d858679c13d464d7795f99d2f73480">More...</a><br /></td></tr>
<tr class="separator:a36d858679c13d464d7795f99d2f73480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff29cb2553fd90cad290a951faddd13"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#aaff29cb2553fd90cad290a951faddd13">set_basename_for_data_type</a> (self, data_type, name)</td></tr>
<tr class="memdesc:aaff29cb2553fd90cad290a951faddd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_basename_for_data_type(PyDataRecorder self, uint32_t data_type, std::string const &amp; name)  <a href="#aaff29cb2553fd90cad290a951faddd13">More...</a><br /></td></tr>
<tr class="separator:aaff29cb2553fd90cad290a951faddd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eec45ad4315791969456d0415a3c83"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#ac4eec45ad4315791969456d0415a3c83">get_basename_for_data_type</a> (self, data_type)</td></tr>
<tr class="memdesc:ac4eec45ad4315791969456d0415a3c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_basename_for_data_type(PyDataRecorder self, uint32_t data_type) -&gt; std::string  <a href="#ac4eec45ad4315791969456d0415a3c83">More...</a><br /></td></tr>
<tr class="separator:ac4eec45ad4315791969456d0415a3c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ab0939bc9ee559daa2d7b4149b49f3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#a51ab0939bc9ee559daa2d7b4149b49f3">clear_basename_for_data_types</a> (self, data_types)</td></tr>
<tr class="memdesc:a51ab0939bc9ee559daa2d7b4149b49f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear_basename_for_data_types(PyDataRecorder self, XeThru::DataTypes data_types)  <a href="#a51ab0939bc9ee559daa2d7b4149b49f3">More...</a><br /></td></tr>
<tr class="separator:a51ab0939bc9ee559daa2d7b4149b49f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750684611b2b9028bfc7cf5349d4bd42"><td class="memItemLeft" align="right" valign="top"><a id="a750684611b2b9028bfc7cf5349d4bd42"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>get_recording_directory</b> (self, args)</td></tr>
<tr class="separator:a750684611b2b9028bfc7cf5349d4bd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4390865ab9b9bf03fda230d85d8469d1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml#a4390865ab9b9bf03fda230d85d8469d1">data_type_to_string</a> (data_type)</td></tr>
<tr class="memdesc:a4390865ab9b9bf03fda230d85d8469d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">data_type_to_string(uint32_t data_type) -&gt; std::string  <a href="#a4390865ab9b9bf03fda230d85d8469d1">More...</a><br /></td></tr>
<tr class="separator:a4390865ab9b9bf03fda230d85d8469d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824d32981194265306bdb42a381f2811"><td class="memItemLeft" align="right" valign="top"><a id="a824d32981194265306bdb42a381f2811"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>subscribe_to_file_available</b> (self, args)</td></tr>
<tr class="separator:a824d32981194265306bdb42a381f2811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd5230c948609fe3c9e336fe5c50c34"><td class="memItemLeft" align="right" valign="top"><a id="aabd5230c948609fe3c9e336fe5c50c34"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>subscribe_to_meta_file_available</b> (self, args)</td></tr>
<tr class="separator:aabd5230c948609fe3c9e336fe5c50c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff19bda0a2866de5e680dcf6ce9d9429"><td class="memItemLeft" align="right" valign="top"><a id="aff19bda0a2866de5e680dcf6ce9d9429"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>set_error_callback</b> (self, args)</td></tr>
<tr class="separator:aff19bda0a2866de5e680dcf6ce9d9429"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3d644047091c54247e7492ec9b65772a"><td class="memItemLeft" align="right" valign="top"><a id="a3d644047091c54247e7492ec9b65772a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>this</b></td></tr>
<tr class="separator:a3d644047091c54247e7492ec9b65772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a65209bbdc59189ed927b8b028979451c"><td class="memItemLeft" align="right" valign="top"><a id="a65209bbdc59189ed927b8b028979451c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>data_type_to_string</b> = staticmethod(data_type_to_string)</td></tr>
<tr class="separator:a65209bbdc59189ed927b8b028979451c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The DataRecorder class allows recording of xethru data types. </p>
<p>The DataRecorder class is a high level recorder class. It can be used to record all data types sent by a xethru device over serial port or similar. All low- level I/O is handled by the recorder itself with no setup required. Data is stored on disk as specified by the XeThru File Formats document and can be easily read back using the <em>DataReader</em> class.</p>
<div class="fragment"></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The DataRecorder has no means to enable or disable data output on a physical xethru device. It simply records the specified data type(s) if sent by the module. Therefore, it is the user's responsibility to enable or disable data ouput on the module itself. If no data is sent, no data will be recorded.</dd></dl>
<p>DataRecorder also supports more advance <em><a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_recording_options.xhtml" title="The RecordingOptions class allows specifying options for recording. ">RecordingOptions</a></em> such as splitting of files and directories.</p>
<p>See start_recording <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_recording_options.xhtml" title="The RecordingOptions class allows specifying options for recording. ">RecordingOptions</a> DataReader.</p>
<p>C++ includes: PyDataRecorder.hpp </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a880fae1cd20e7e727bf71d1b4423f738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880fae1cd20e7e727bf71d1b4423f738">&sect;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataRecorder.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>radar_interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>init</b>(XeThru::PyDataRecorder self, LockedRadarInterfacePtr &amp; radar_interface) -&gt; <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_py_data_recorder.xhtml" title="The DataRecorder class allows recording of xethru data types. ">PyDataRecorder</a> </p>
<p>Constructs recorder. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a51ab0939bc9ee559daa2d7b4149b49f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ab0939bc9ee559daa2d7b4149b49f3">&sect;&nbsp;</a></span>clear_basename_for_data_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataRecorder.clear_basename_for_data_types </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clear_basename_for_data_types(PyDataRecorder self, XeThru::DataTypes data_types) </p>
<p>Resets the basename(s) to default value(s) for the specified data type(s).</p>
<p>Most users will not need this functionality.</p>
<h2>Parameters </h2>
<ul>
<li><code>data_types</code> : DataTypes is a bitmask that consists of a combination of <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_type.xhtml" title="Proxy of C++ XeThru::DataType class. ">DataType</a> flags. These flags can be combined with the bitwise OR operator (|). For example: <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_baseband_iq_data.xhtml">BasebandIqData</a> | <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_sleep_data.xhtml" title="Represents the sleep status data coming from the module. ">SleepData</a>. A convenience value AllDataTypes can also be specified.</li>
</ul>
<p>See set_basename_for_data_type </p>

</div>
</div>
<a id="a4390865ab9b9bf03fda230d85d8469d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4390865ab9b9bf03fda230d85d8469d1">&sect;&nbsp;</a></span>data_type_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataRecorder.data_type_to_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>data_type_to_string(uint32_t data_type) -&gt; std::string </p>
<p>Convenience method for converting data type to human readable string representation.</p>
<h2>Parameters </h2>
<ul>
<li><code>data_type</code> :</li>
</ul>
<h2>Returns </h2>
<p>the string representation of the specified data type </p>

</div>
</div>
<a id="ac4eec45ad4315791969456d0415a3c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4eec45ad4315791969456d0415a3c83">&sect;&nbsp;</a></span>get_basename_for_data_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataRecorder.get_basename_for_data_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_basename_for_data_type(PyDataRecorder self, uint32_t data_type) -&gt; std::string </p>
<p>Gets the basename for the specified data type.</p>
<p>Most users will not need this functionality.</p>
<h2>Parameters </h2>
<ul>
<li><code>data_type</code> : Specifies the data type.</li>
</ul>
<h2>Returns </h2>
<p>the basename for the specified data type</p>
<p>See set_basename_for_data_type </p>

</div>
</div>
<a id="a9686c460b0b212a734076e232ff62bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9686c460b0b212a734076e232ff62bee">&sect;&nbsp;</a></span>is_recording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataRecorder.is_recording </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_recording(PyDataRecorder self, uint32_t data_type) -&gt; bool </p>
<h2>Returns </h2>
<p>true if recording is started for the specified data type, otherwise returns false</p>
<p>See start_recording </p>

</div>
</div>
<a id="ab9a8d540baece3bae3415fb95822c01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a8d540baece3bae3415fb95822c01f">&sect;&nbsp;</a></span>process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataRecorder.process </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>process(PyDataRecorder self, uint32_t data_type, ucVector data) -&gt; bool </p>
<p>This function should not be used when recording data from a physical xethru device.</p>
<p>It is only relevant for recording data generated elsewhere. Most users will not need this functionality.</p>
<p>Process the specified data for a given data type.</p>
<h2>Parameters </h2>
<ul>
<li><code>data_type</code> : Specifies the data type to process</li>
<li><code>data</code> : Specifies the bytes to process</li>
</ul>
<h2>Returns </h2>
<p>true on success, otherwise returns false </p>

</div>
</div>
<a id="aaff29cb2553fd90cad290a951faddd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff29cb2553fd90cad290a951faddd13">&sect;&nbsp;</a></span>set_basename_for_data_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataRecorder.set_basename_for_data_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set_basename_for_data_type(PyDataRecorder self, uint32_t data_type, std::string const &amp; name) </p>
<p>Sets the basename for the specified data type.</p>
<p>Most users will not need this functionality.</p>
<h2>Parameters </h2>
<ul>
<li><code>data_type</code> : Specifies the data type</li>
<li><code>name</code> : Specifies the name</li>
</ul>
<p>See get_basename_for_data_type, clear_basename_for_data_types </p>

</div>
</div>
<a id="a9ac0e0a0a0a2d0d80d4fee6242f66ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac0e0a0a0a2d0d80d4fee6242f66ba6">&sect;&nbsp;</a></span>stop_recording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataRecorder.stop_recording </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stop_recording(PyDataRecorder self, XeThru::DataTypes data_types) </p>
<p>Stops recording the specified data type(s).</p>
<p>This command does not disable data output on the module.</p>
<h2>Parameters </h2>
<ul>
<li><code>data_types</code> : DataTypes is a bitmask that consists of a combination of <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_type.xhtml" title="Proxy of C++ XeThru::DataType class. ">DataType</a> flags. These flags can be combined with the bitwise OR operator (|). For example: <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_baseband_iq_data.xhtml">BasebandIqData</a> | <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_sleep_data.xhtml" title="Represents the sleep status data coming from the module. ">SleepData</a>. A convenience value AllDataTypes can also be specified.</li>
</ul>
<p>See start_recording </p>

</div>
</div>
<a id="a9d06e507bf5dea4567bd25d8839c8480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d06e507bf5dea4567bd25d8839c8480">&sect;&nbsp;</a></span>unsubscribe_to_file_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataRecorder.unsubscribe_to_file_available </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsubscribe_to_file_available(PyDataRecorder self, XeThru::DataTypes data_types) </p>
<p>Unsubscribes to notifications when a recorded file for a data type is available.</p>
<h2>Parameters </h2>
<ul>
<li><code>data_types</code> : DataTypes is a bitmask that consists of a combination of <a class="el" href="classpymoduleconnector_1_1moduleconnectorwrapper_1_1_data_type.xhtml" title="Proxy of C++ XeThru::DataType class. ">DataType</a> flags. These flags can be combined with the bitwise OR operator (|). For example: BasebandIqDataType | SleepDataType. A convenience value AllDataTypes can also be specified.</li>
</ul>
<p>See subscribe_to_file_available </p>

</div>
</div>
<a id="a36d858679c13d464d7795f99d2f73480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d858679c13d464d7795f99d2f73480">&sect;&nbsp;</a></span>unsubscribe_to_meta_file_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pymoduleconnector.moduleconnectorwrapper.PyDataRecorder.unsubscribe_to_meta_file_available </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsubscribe_to_meta_file_available(PyDataRecorder self) -&gt; int </p>
<p>Unsubscribes to notifications when a meta file is available.</p>
<p>See subscribe_to_meta_file_available </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pymoduleconnector/moduleconnectorwrapper/__init__.py</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/>
 <address class="footer">
 Copyright &copy; 2016 Novelda AS - <a href="http://www.xethru.com">www.xehtru.com</a><br />
 <small>
  Generated by &#160;<a href="http://www.doxygen.org/index.html">
  <img class="footer" src="doxygen.png" alt="doxygen"/>
  </a> 1.8.12
 </small>
 </address>
</body>
</html>
